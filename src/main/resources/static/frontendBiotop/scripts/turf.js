!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).turf = {})
}(this, (function (t) {
    "use strict";

    function e(t) {
        return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }, e(t)
    }

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }

    function i(t, e, n) {
        return e && r(t.prototype, e), n && r(t, n), Object.defineProperty(t, "prototype", {writable: !1}), t
    }

    function o(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }

    function s(t, e) {
        return function (t) {
            if (Array.isArray(t)) return t
        }(t) || function (t, e) {
            var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (null == n) return;
            var r, i, o = [], s = !0, a = !1;
            try {
                for (n = n.call(t); !(s = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); s = !0) ;
            } catch (t) {
                a = !0, i = t
            } finally {
                try {
                    s || null == n.return || n.return()
                } finally {
                    if (a) throw i
                }
            }
            return o
        }(t, e) || u(t, e) || function () {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function a(t) {
        return function (t) {
            if (Array.isArray(t)) return l(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
        }(t) || u(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function u(t, e) {
        if (t) {
            if ("string" == typeof t) return l(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(t, e) : void 0
        }
    }

    function l(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r
    }

    function h(t, e) {
        var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
        if (!n) {
            if (Array.isArray(t) || (n = u(t)) || e && t && "number" == typeof t.length) {
                n && (t = n);
                var r = 0, i = function () {
                };
                return {
                    s: i, n: function () {
                        return r >= t.length ? {done: !0} : {done: !1, value: t[r++]}
                    }, e: function (t) {
                        throw t
                    }, f: i
                }
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        var o, s = !0, a = !1;
        return {
            s: function () {
                n = n.call(t)
            }, n: function () {
                var t = n.next();
                return s = t.done, t
            }, e: function (t) {
                a = !0, o = t
            }, f: function () {
                try {
                    s || null == n.return || n.return()
                } finally {
                    if (a) throw o
                }
            }
        }
    }

    var c = 6371008.8, f = {
        centimeters: 637100880,
        centimetres: 637100880,
        degrees: 360 / (2 * Math.PI),
        feet: 20902260.511392,
        inches: 39.37 * c,
        kilometers: 6371.0088,
        kilometres: 6371.0088,
        meters: c,
        metres: c,
        miles: 3958.761333810546,
        millimeters: 6371008800,
        millimetres: 6371008800,
        nauticalmiles: c / 1852,
        radians: 1,
        yards: 6967335.223679999
    }, g = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
    };

    function p(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = {type: "Feature"};
        return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r
    }

    function v(t, e) {
        switch (t) {
            case"Point":
                return d(e).geometry;
            case"LineString":
                return x(e).geometry;
            case"Polygon":
                return m(e).geometry;
            case"MultiPoint":
                return b(e).geometry;
            case"MultiLineString":
                return w(e).geometry;
            case"MultiPolygon":
                return I(e).geometry;
            default:
                throw new Error(t + " is invalid")
        }
    }

    function d(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!t) throw new Error("coordinates is required");
        if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
        if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long");
        if (!D(t[0]) || !D(t[1])) throw new Error("coordinates must contain numbers");
        var r = {type: "Point", coordinates: t};
        return p(r, e, n)
    }

    function y(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return k(t.map((function (t) {
            return d(t, e)
        })), n)
    }

    function m(t, e) {
        var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = h(t);
        try {
            for (i.s(); !(n = i.n()).done;) {
                var o = n.value;
                if (o.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                if (o[o.length - 1].length !== o[0].length) throw new Error("First and last Position are not equivalent.");
                for (var s = 0; s < o[o.length - 1].length; s++) if (o[o.length - 1][s] !== o[0][s]) throw new Error("First and last Position are not equivalent.")
            }
        } catch (t) {
            i.e(t)
        } finally {
            i.f()
        }
        var a = {type: "Polygon", coordinates: t};
        return p(a, e, r)
    }

    function _(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return k(t.map((function (t) {
            return m(t, e)
        })), n)
    }

    function x(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (t.length < 2) throw new Error("coordinates must be an array of two or more positions");
        var r = {type: "LineString", coordinates: t};
        return p(r, e, n)
    }

    function E(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return k(t.map((function (t) {
            return x(t, e)
        })), n)
    }

    function k(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = {type: "FeatureCollection"};
        return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
    }

    function w(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = {type: "MultiLineString", coordinates: t};
        return p(r, e, n)
    }

    function b(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = {type: "MultiPoint", coordinates: t};
        return p(r, e, n)
    }

    function I(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = {type: "MultiPolygon", coordinates: t};
        return p(r, e, n)
    }

    function S(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = {type: "GeometryCollection", geometries: t};
        return p(r, e, n)
    }

    function N(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        if (e && !(e >= 0)) throw new Error("precision must be a positive number");
        var n = Math.pow(10, e || 0);
        return Math.round(t * n) / n
    }

    function M(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "kilometers", n = f[e];
        if (!n) throw new Error(e + " units is invalid");
        return t * n
    }

    function P(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "kilometers", n = f[e];
        if (!n) throw new Error(e + " units is invalid");
        return t / n
    }

    function L(t, e) {
        return R(P(t, e))
    }

    function C(t) {
        var e = t % 360;
        return e < 0 && (e += 360), e
    }

    function R(t) {
        return 180 * (t % (2 * Math.PI)) / Math.PI
    }

    function T(t) {
        return t % 360 * Math.PI / 180
    }

    function O(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "kilometers",
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "kilometers";
        if (!(t >= 0)) throw new Error("length must be a positive number");
        return M(P(t, e), n)
    }

    function A(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "meters",
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "kilometers";
        if (!(t >= 0)) throw new Error("area must be a positive number");
        var r = g[e];
        if (!r) throw new Error("invalid original units");
        var i = g[n];
        if (!i) throw new Error("invalid final units");
        return t / r * i
    }

    function D(t) {
        return !isNaN(t) && null !== t && !Array.isArray(t)
    }

    function F(t) {
        return null !== t && "object" === e(t) && !Array.isArray(t)
    }

    function q(t) {
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be an Array");
        if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers");
        t.forEach((function (t) {
            if (!D(t)) throw new Error("bbox must only contain numbers")
        }))
    }

    function G(t) {
        if (!t) throw new Error("id is required");
        if (-1 === ["string", "number"].indexOf(e(t))) throw new Error("id must be a number or a string")
    }

    var Y = Object.freeze({
        __proto__: null,
        earthRadius: c,
        factors: f,
        areaFactors: g,
        feature: p,
        geometry: v,
        point: d,
        points: y,
        polygon: m,
        polygons: _,
        lineString: x,
        lineStrings: E,
        featureCollection: k,
        multiLineString: w,
        multiPoint: b,
        multiPolygon: I,
        geometryCollection: S,
        round: N,
        radiansToLength: M,
        lengthToRadians: P,
        lengthToDegrees: L,
        bearingToAzimuth: C,
        radiansToDegrees: R,
        degreesToRadians: T,
        convertLength: O,
        convertArea: A,
        isNumber: D,
        isObject: F,
        validateBBox: q,
        validateId: G
    });

    function B(t, e, n) {
        if (null !== t) for (var r, i, o, s, a, u, l, h, c = 0, f = 0, g = t.type, p = "FeatureCollection" === g, v = "Feature" === g, d = p ? t.features.length : 1, y = 0; y < d; y++) {
            a = (h = !!(l = p ? t.features[y].geometry : v ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1;
            for (var m = 0; m < a; m++) {
                var _ = 0, x = 0;
                if (null !== (s = h ? l.geometries[m] : l)) {
                    u = s.coordinates;
                    var E = s.type;
                    switch (c = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) {
                        case null:
                            break;
                        case"Point":
                            if (!1 === e(u, f, y, _, x)) return !1;
                            f++, _++;
                            break;
                        case"LineString":
                        case"MultiPoint":
                            for (r = 0; r < u.length; r++) {
                                if (!1 === e(u[r], f, y, _, x)) return !1;
                                f++, "MultiPoint" === E && _++
                            }
                            "LineString" === E && _++;
                            break;
                        case"Polygon":
                        case"MultiLineString":
                            for (r = 0; r < u.length; r++) {
                                for (i = 0; i < u[r].length - c; i++) {
                                    if (!1 === e(u[r][i], f, y, _, x)) return !1;
                                    f++
                                }
                                "MultiLineString" === E && _++, "Polygon" === E && x++
                            }
                            "Polygon" === E && _++;
                            break;
                        case"MultiPolygon":
                            for (r = 0; r < u.length; r++) {
                                for (x = 0, i = 0; i < u[r].length; i++) {
                                    for (o = 0; o < u[r][i].length - c; o++) {
                                        if (!1 === e(u[r][i][o], f, y, _, x)) return !1;
                                        f++
                                    }
                                    x++
                                }
                                _++
                            }
                            break;
                        case"GeometryCollection":
                            for (r = 0; r < s.geometries.length; r++) if (!1 === B(s.geometries[r], e, n)) return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                    }
                }
            }
        }
    }

    function z(t, e, n, r) {
        var i = n;
        return B(t, (function (t, r, o, s, a) {
            i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a)
        }), r), i
    }

    function X(t, e) {
        var n;
        switch (t.type) {
            case"FeatureCollection":
                for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++) ;
                break;
            case"Feature":
                e(t.properties, 0)
        }
    }

    function j(t, e, n) {
        var r = n;
        return X(t, (function (t, i) {
            r = 0 === i && void 0 === n ? t : e(r, t, i)
        })), r
    }

    function U(t, e) {
        if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++) ;
    }

    function V(t, e, n) {
        var r = n;
        return U(t, (function (t, i) {
            r = 0 === i && void 0 === n ? t : e(r, t, i)
        })), r
    }

    function Z(t) {
        var e = [];
        return B(t, (function (t) {
            e.push(t)
        })), e
    }

    function H(t, e) {
        var n, r, i, o, s, a, u, l, h, c, f = 0, g = "FeatureCollection" === t.type, p = "Feature" === t.type,
            v = g ? t.features.length : 1;
        for (n = 0; n < v; n++) {
            for (a = g ? t.features[n].geometry : p ? t.geometry : t, l = g ? t.features[n].properties : p ? t.properties : {}, h = g ? t.features[n].bbox : p ? t.bbox : void 0, c = g ? t.features[n].id : p ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++) if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) {
                case"Point":
                case"LineString":
                case"MultiPoint":
                case"Polygon":
                case"MultiLineString":
                case"MultiPolygon":
                    if (!1 === e(o, f, l, h, c)) return !1;
                    break;
                case"GeometryCollection":
                    for (r = 0; r < o.geometries.length; r++) if (!1 === e(o.geometries[r], f, l, h, c)) return !1;
                    break;
                default:
                    throw new Error("Unknown Geometry Type")
            } else if (!1 === e(null, f, l, h, c)) return !1;
            f++
        }
    }

    function W(t, e, n) {
        var r = n;
        return H(t, (function (t, i, o, s, a) {
            r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a)
        })), r
    }

    function J(t, e) {
        H(t, (function (t, n, r, i, o) {
            var s, a = null === t ? null : t.type;
            switch (a) {
                case null:
                case"Point":
                case"LineString":
                case"Polygon":
                    return !1 !== e(p(t, r, {bbox: i, id: o}), n, 0) && void 0
            }
            switch (a) {
                case"MultiPoint":
                    s = "Point";
                    break;
                case"MultiLineString":
                    s = "LineString";
                    break;
                case"MultiPolygon":
                    s = "Polygon"
            }
            for (var u = 0; u < t.coordinates.length; u++) {
                var l = t.coordinates[u];
                if (!1 === e(p({type: s, coordinates: l}, r), n, u)) return !1
            }
        }))
    }

    function Q(t, e, n) {
        var r = n;
        return J(t, (function (t, i, o) {
            r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o)
        })), r
    }

    function K(t, e) {
        J(t, (function (t, n, r) {
            var i = 0;
            if (t.geometry) {
                var o = t.geometry.type;
                if ("Point" !== o && "MultiPoint" !== o) {
                    var s, a = 0, u = 0, l = 0;
                    return !1 !== B(t, (function (o, h, c, f, g) {
                        if (void 0 === s || n > a || f > u || g > l) return s = o, a = n, u = f, l = g, void (i = 0);
                        var p = x([s, o], t.properties);
                        if (!1 === e(p, n, r, g, i)) return !1;
                        i++, s = o
                    })) && void 0
                }
            }
        }))
    }

    function $(t, e, n) {
        var r = n, i = !1;
        return K(t, (function (t, o, s, a, u) {
            r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0
        })), r
    }

    function tt(t, e) {
        if (!t) throw new Error("geojson is required");
        J(t, (function (t, n, r) {
            if (null !== t.geometry) {
                var i = t.geometry.type, o = t.geometry.coordinates;
                switch (i) {
                    case"LineString":
                        if (!1 === e(t, n, r, 0, 0)) return !1;
                        break;
                    case"Polygon":
                        for (var s = 0; s < o.length; s++) if (!1 === e(x(o[s], t.properties), n, r, s)) return !1
                }
            }
        }))
    }

    function et(t, e, n) {
        var r = n;
        return tt(t, (function (t, i, o, s) {
            r = 0 === i && void 0 === n ? t : e(r, t, i, o, s)
        })), r
    }

    function nt(t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.segmentIndex || 0,
            a = e.properties;
        switch (t.type) {
            case"FeatureCollection":
                r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;
                break;
            case"Feature":
                a = a || t.properties, n = t.geometry;
                break;
            case"Point":
            case"MultiPoint":
                return null;
            case"LineString":
            case"Polygon":
            case"MultiLineString":
            case"MultiPolygon":
                n = t;
                break;
            default:
                throw new Error("geojson is invalid")
        }
        if (null === n) return null;
        var u = n.coordinates;
        switch (n.type) {
            case"Point":
            case"MultiPoint":
                return null;
            case"LineString":
                return s < 0 && (s = u.length + s - 1), x([u[s], u[s + 1]], a, e);
            case"Polygon":
                return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), x([u[o][s], u[o][s + 1]], a, e);
            case"MultiLineString":
                return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), x([u[i][s], u[i][s + 1]], a, e);
            case"MultiPolygon":
                return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), x([u[i][o][s], u[i][o][s + 1]], a, e)
        }
        throw new Error("geojson is invalid")
    }

    function rt(t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.coordIndex || 0,
            a = e.properties;
        switch (t.type) {
            case"FeatureCollection":
                r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;
                break;
            case"Feature":
                a = a || t.properties, n = t.geometry;
                break;
            case"Point":
            case"MultiPoint":
                return null;
            case"LineString":
            case"Polygon":
            case"MultiLineString":
            case"MultiPolygon":
                n = t;
                break;
            default:
                throw new Error("geojson is invalid")
        }
        if (null === n) return null;
        var u = n.coordinates;
        switch (n.type) {
            case"Point":
                return d(u, a, e);
            case"MultiPoint":
                return i < 0 && (i = u.length + i), d(u[i], a, e);
            case"LineString":
                return s < 0 && (s = u.length + s), d(u[s], a, e);
            case"Polygon":
                return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s), d(u[o][s], a, e);
            case"MultiLineString":
                return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), d(u[i][s], a, e);
            case"MultiPolygon":
                return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s), d(u[i][o][s], a, e)
        }
        throw new Error("geojson is invalid")
    }

    var it = Object.freeze({
        __proto__: null,
        coordAll: Z,
        coordEach: B,
        coordReduce: z,
        featureEach: U,
        featureReduce: V,
        findPoint: rt,
        findSegment: nt,
        flattenEach: J,
        flattenReduce: Q,
        geomEach: H,
        geomReduce: W,
        lineEach: tt,
        lineReduce: et,
        propEach: X,
        propReduce: j,
        segmentEach: K,
        segmentReduce: $
    });

    function ot(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (null != t.bbox && !0 !== e.recompute) return t.bbox;
        var n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return B(t, (function (t) {
            n[0] > t[0] && (n[0] = t[0]), n[1] > t[1] && (n[1] = t[1]), n[2] < t[0] && (n[2] = t[0]), n[3] < t[1] && (n[3] = t[1])
        })), n
    }

    function st(t) {
        if (!t) throw new Error("coord is required");
        if (!Array.isArray(t)) {
            if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type) return a(t.geometry.coordinates);
            if ("Point" === t.type) return a(t.coordinates)
        }
        if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return a(t);
        throw new Error("coord must be GeoJSON Point or an Array of numbers")
    }

    function at(t) {
        if (Array.isArray(t)) return t;
        if ("Feature" === t.type) {
            if (null !== t.geometry) return t.geometry.coordinates
        } else if (t.coordinates) return t.coordinates;
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
    }

    function ut(t) {
        if (t.length > 1 && D(t[0]) && D(t[1])) return !0;
        if (Array.isArray(t[0]) && t[0].length) return ut(t[0]);
        throw new Error("coordinates must only contain numbers")
    }

    function lt(t, e, n) {
        if (!e || !n) throw new Error("type and name required");
        if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
    }

    function ht(t, e, n) {
        if (!t) throw new Error("No feature passed");
        if (!n) throw new Error(".featureOf() requires a name");
        if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
        if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
    }

    function ct(t, e, n) {
        if (!t) throw new Error("No featureCollection passed");
        if (!n) throw new Error(".collectionOf() requires a name");
        if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required");
        var r, i = h(t.features);
        try {
            for (i.s(); !(r = i.n()).done;) {
                var o = r.value;
                if (!o || "Feature" !== o.type || !o.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
                if (!o.geometry || o.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + o.geometry.type)
            }
        } catch (t) {
            i.e(t)
        } finally {
            i.f()
        }
    }

    function ft(t) {
        return "Feature" === t.type ? t.geometry : t
    }

    function gt(t, e) {
        return "FeatureCollection" === t.type ? "FeatureCollection" : "GeometryCollection" === t.type ? "GeometryCollection" : "Feature" === t.type && null !== t.geometry ? t.geometry.type : t.type
    }

    ot.default = ot;
    var pt = Object.freeze({
        __proto__: null,
        getCoord: st,
        getCoords: at,
        containsNumber: ut,
        geojsonType: lt,
        featureOf: ht,
        collectionOf: ct,
        getGeom: ft,
        getType: gt
    }), vt = {successCallback: null, verbose: !1}, dt = {};

    /**
     * @license GNU Affero General Public License.
     * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
     * v. 1.2.0
     * https://github.com/RaumZeit/MarchingSquares.js
     *
     * MarchingSquaresJS is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Affero General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * MarchingSquaresJS is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU Affero General Public License for more details.
     *
     * As additional permission under GNU Affero General Public License version 3
     * section 7, third-party projects (personal or commercial) may distribute,
     * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
     * requirement that said third-party project for that reason alone becomes
     * subject to any requirement of the GNU Affero General Public License version 3.
     * Any modifications to MarchingSquaresJS, however, must be shared with the public
     * and made available.
     *
     * In summary this:
     * - allows you to use MarchingSquaresJS at no cost
     * - allows you to use MarchingSquaresJS for both personal and commercial purposes
     * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
     *   license as long as this license notice is included
     * - enables you to keep the source code of your program that uses MarchingSquaresJS
     *   undisclosed
     * - forces you to share any modifications you have made to MarchingSquaresJS,
     *   e.g. bug-fixes
     *
     * You should have received a copy of the GNU Affero General Public License
     * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
     */function yt(t, e, n) {
        n = n || {};
        for (var r = Object.keys(vt), i = 0; i < r.length; i++) {
            var o = r[i], s = n[o];
            s = null != s ? s : vt[o], dt[o] = s
        }
        dt.verbose && console.log("MarchingSquaresJS-isoContours: computing isocontour for " + e);
        var a = function (t) {
            var e = [], n = 0, r = 1e-7;
            return t.cells.forEach((function (i, o) {
                i.forEach((function (i, s) {
                    if (void 0 !== i && (5 !== (g = i).cval && 10 !== g.cval) && !_t(i)) {
                        var a = function (t, e, n) {
                            var r, i, o = t.length, s = [], a = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0],
                                u = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0],
                                l = ["none", "left", "bottom", "left", "right", "none", "bottom", "left", "top", "top", "none", "top", "right", "right", "bottom", "none"],
                                h = ["none", "bottom", "right", "right", "top", "top", "top", "top", "left", "bottom", "right", "right", "left", "bottom", "left", "none"],
                                c = t[e][n], f = c.cval, g = l[f], p = Et(c, g);
                            s.push([n + p[0], e + p[1]]), g = h[f], p = Et(c, g), s.push([n + p[0], e + p[1]]), xt(c);
                            var v = n + a[f], d = e + u[f], y = f;
                            for (; v >= 0 && d >= 0 && d < o && (v != n || d != e) && void 0 !== (c = t[d][v]);) {
                                if (0 === (f = c.cval) || 15 === f) return {path: s, info: "mergeable"};
                                g = h[f], r = a[f], i = u[f], 5 !== f && 10 !== f || (5 === f ? c.flipped ? -1 === u[y] ? (g = "left", r = -1, i = 0) : (g = "right", r = 1, i = 0) : -1 === a[y] && (g = "bottom", r = 0, i = -1) : 10 === f && (c.flipped ? -1 === a[y] ? (g = "top", r = 0, i = 1) : (g = "bottom", r = 0, i = -1) : 1 === u[y] && (g = "left", r = -1, i = 0))), p = Et(c, g), s.push([v + p[0], d + p[1]]), xt(c), v += r, d += i, y = f
                            }
                            return {path: s, info: "closed"}
                        }(t.cells, o, s), u = !1;
                        if ("mergeable" === a.info) for (var l = a.path[a.path.length - 1][0], h = a.path[a.path.length - 1][1], c = n - 1; c >= 0; c--) if (Math.abs(e[c][0][0] - l) <= r && Math.abs(e[c][0][1] - h) <= r) {
                            for (var f = a.path.length - 2; f >= 0; --f) e[c].unshift(a.path[f]);
                            u = !0;
                            break
                        }
                        u || (e[n++] = a.path)
                    }
                    var g
                }))
            })), e
        }(function (t, e) {
            for (var n = t.length - 1, r = t[0].length - 1, i = {rows: n, cols: r, cells: []}, o = 0; o < n; ++o) {
                i.cells[o] = [];
                for (var s = 0; s < r; ++s) {
                    var a = 0, u = t[o + 1][s], l = t[o + 1][s + 1], h = t[o][s + 1], c = t[o][s];
                    if (!(isNaN(u) || isNaN(l) || isNaN(h) || isNaN(c))) {
                        a |= u >= e ? 8 : 0, a |= l >= e ? 4 : 0, a |= h >= e ? 2 : 0;
                        var f, g, p, v, d = !1;
                        if (5 === (a |= c >= e ? 1 : 0) || 10 === a) {
                            var y = (u + l + h + c) / 4;
                            5 === a && y < e ? (a = 10, d = !0) : 10 === a && y < e && (a = 5, d = !0)
                        }
                        if (0 !== a && 15 !== a) f = g = p = v = .5, 1 === a ? (p = 1 - mt(e, u, c), g = 1 - mt(e, h, c)) : 2 === a ? (g = mt(e, c, h), v = 1 - mt(e, l, h)) : 3 === a ? (p = 1 - mt(e, u, c), v = 1 - mt(e, l, h)) : 4 === a ? (f = mt(e, u, l), v = mt(e, h, l)) : 5 === a ? (f = mt(e, u, l), v = mt(e, h, l), g = 1 - mt(e, h, c), p = 1 - mt(e, u, c)) : 6 === a ? (g = mt(e, c, h), f = mt(e, u, l)) : 7 === a ? (p = 1 - mt(e, u, c), f = mt(e, u, l)) : 8 === a ? (p = mt(e, c, u), f = 1 - mt(e, l, u)) : 9 === a ? (g = 1 - mt(e, h, c), f = 1 - mt(e, l, u)) : 10 === a ? (f = 1 - mt(e, l, u), v = 1 - mt(e, l, h), g = mt(e, c, h), p = mt(e, c, u)) : 11 === a ? (f = 1 - mt(e, l, u), v = 1 - mt(e, l, h)) : 12 === a ? (p = mt(e, c, u), v = mt(e, h, l)) : 13 === a ? (g = 1 - mt(e, h, c), v = mt(e, h, l)) : 14 === a ? (p = mt(e, c, u), g = mt(e, c, h)) : console.log("MarchingSquaresJS-isoContours: Illegal cval detected: " + a), i.cells[o][s] = {
                            cval: a,
                            flipped: d,
                            top: f,
                            right: v,
                            bottom: g,
                            left: p
                        }
                    }
                }
            }
            return i
        }(t, e));
        return "function" == typeof dt.successCallback && dt.successCallback(a), a
    }

    function mt(t, e, n) {
        return (t - e) / (n - e)
    }

    function _t(t) {
        return 0 === t.cval || 15 === t.cval
    }

    function xt(t) {
        _t(t) || 5 === t.cval || 10 === t.cval || (t.cval = 15)
    }

    function Et(t, e) {
        return "top" === e ? [t.top, 1] : "bottom" === e ? [t.bottom, 0] : "right" === e ? [1, t.right] : "left" === e ? [0, t.left] : void 0
    }

    function kt(t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.zProperty || "elevation", r = e.flip, i = e.flags;
        ct(t, "Point", "input must contain Points");
        for (var o = function (t, e) {
            var n = {};
            U(t, (function (t) {
                var e = at(t)[1];
                n[e] || (n[e] = []), n[e].push(t)
            }));
            var r = Object.keys(n).map((function (t) {
                return n[t].sort((function (t, e) {
                    return at(t)[0] - at(e)[0]
                }))
            }));
            return r.sort((function (t, n) {
                return e ? at(t[0])[1] - at(n[0])[1] : at(n[0])[1] - at(t[0])[1]
            }))
        }(t, r), s = [], a = 0; a < o.length; a++) {
            for (var u = o[a], l = [], h = 0; h < u.length; h++) {
                var c = u[h];
                c.properties[n] ? l.push(c.properties[n]) : l.push(0), !0 === i && (c.properties.matrixPosition = [a, h])
            }
            s.push(l)
        }
        return s
    }

    function wt(t, e, n, r, i) {
        bt(t, e, n || 0, r || t.length - 1, i || St)
    }

    function bt(t, e, n, r, i) {
        for (; r > n;) {
            if (r - n > 600) {
                var o = r - n + 1, s = e - n + 1, a = Math.log(o), u = .5 * Math.exp(2 * a / 3),
                    l = .5 * Math.sqrt(a * u * (o - u) / o) * (s - o / 2 < 0 ? -1 : 1);
                bt(t, e, Math.max(n, Math.floor(e - s * u / o + l)), Math.min(r, Math.floor(e + (o - s) * u / o + l)), i)
            }
            var h = t[e], c = n, f = r;
            for (It(t, n, e), i(t[r], h) > 0 && It(t, n, r); c < f;) {
                for (It(t, c, f), c++, f--; i(t[c], h) < 0;) c++;
                for (; i(t[f], h) > 0;) f--
            }
            0 === i(t[n], h) ? It(t, n, f) : It(t, ++f, r), f <= e && (n = f + 1), e <= f && (r = f - 1)
        }
    }

    function It(t, e, n) {
        var r = t[e];
        t[e] = t[n], t[n] = r
    }

    function St(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    var Nt = function () {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 9;
            n(this, t), this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear()
        }

        return i(t, [{
            key: "all", value: function () {
                return this._all(this.data, [])
            }
        }, {
            key: "search", value: function (t) {
                var e = this.data, n = [];
                if (!Ft(t, e)) return n;
                for (var r = this.toBBox, i = []; e;) {
                    for (var o = 0; o < e.children.length; o++) {
                        var s = e.children[o], a = e.leaf ? r(s) : s;
                        Ft(t, a) && (e.leaf ? n.push(s) : Dt(t, a) ? this._all(s, n) : i.push(s))
                    }
                    e = i.pop()
                }
                return n
            }
        }, {
            key: "collides", value: function (t) {
                var e = this.data;
                if (!Ft(t, e)) return !1;
                for (var n = []; e;) {
                    for (var r = 0; r < e.children.length; r++) {
                        var i = e.children[r], o = e.leaf ? this.toBBox(i) : i;
                        if (Ft(t, o)) {
                            if (e.leaf || Dt(t, o)) return !0;
                            n.push(i)
                        }
                    }
                    e = n.pop()
                }
                return !1
            }
        }, {
            key: "load", value: function (t) {
                if (!t || !t.length) return this;
                if (t.length < this._minEntries) {
                    for (var e = 0; e < t.length; e++) this.insert(t[e]);
                    return this
                }
                var n = this._build(t.slice(), 0, t.length - 1, 0);
                if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else {
                    if (this.data.height < n.height) {
                        var r = this.data;
                        this.data = n, n = r
                    }
                    this._insert(n, this.data.height - n.height - 1, !0)
                } else this.data = n;
                return this
            }
        }, {
            key: "insert", value: function (t) {
                return t && this._insert(t, this.data.height - 1), this
            }
        }, {
            key: "clear", value: function () {
                return this.data = qt([]), this
            }
        }, {
            key: "remove", value: function (t, e) {
                if (!t) return this;
                for (var n, r, i, o = this.data, s = this.toBBox(t), a = [], u = []; o || a.length;) {
                    if (o || (o = a.pop(), r = a[a.length - 1], n = u.pop(), i = !0), o.leaf) {
                        var l = Mt(t, o.children, e);
                        if (-1 !== l) return o.children.splice(l, 1), a.push(o), this._condense(a), this
                    }
                    i || o.leaf || !Dt(o, s) ? r ? (n++, o = r.children[n], i = !1) : o = null : (a.push(o), u.push(n), n = 0, r = o, o = o.children[0])
                }
                return this
            }
        }, {
            key: "toBBox", value: function (t) {
                return t
            }
        }, {
            key: "compareMinX", value: function (t, e) {
                return t.minX - e.minX
            }
        }, {
            key: "compareMinY", value: function (t, e) {
                return t.minY - e.minY
            }
        }, {
            key: "toJSON", value: function () {
                return this.data
            }
        }, {
            key: "fromJSON", value: function (t) {
                return this.data = t, this
            }
        }, {
            key: "_all", value: function (t, e) {
                for (var n = []; t;) t.leaf ? e.push.apply(e, a(t.children)) : n.push.apply(n, a(t.children)), t = n.pop();
                return e
            }
        }, {
            key: "_build", value: function (t, e, n, r) {
                var i, o = n - e + 1, s = this._maxEntries;
                if (o <= s) return Pt(i = qt(t.slice(e, n + 1)), this.toBBox), i;
                r || (r = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, r - 1))), (i = qt([])).leaf = !1, i.height = r;
                var a = Math.ceil(o / s), u = a * Math.ceil(Math.sqrt(s));
                Gt(t, e, n, u, this.compareMinX);
                for (var l = e; l <= n; l += u) {
                    var h = Math.min(l + u - 1, n);
                    Gt(t, l, h, a, this.compareMinY);
                    for (var c = l; c <= h; c += a) {
                        var f = Math.min(c + a - 1, h);
                        i.children.push(this._build(t, c, f, r - 1))
                    }
                }
                return Pt(i, this.toBBox), i
            }
        }, {
            key: "_chooseSubtree", value: function (t, e, n, r) {
                for (; r.push(e), !e.leaf && r.length - 1 !== n;) {
                    for (var i = 1 / 0, o = 1 / 0, s = void 0, a = 0; a < e.children.length; a++) {
                        var u = e.children[a], l = Ot(u),
                            h = (c = t, f = u, (Math.max(f.maxX, c.maxX) - Math.min(f.minX, c.minX)) * (Math.max(f.maxY, c.maxY) - Math.min(f.minY, c.minY)) - l);
                        h < o ? (o = h, i = l < i ? l : i, s = u) : h === o && l < i && (i = l, s = u)
                    }
                    e = s || e.children[0]
                }
                var c, f;
                return e
            }
        }, {
            key: "_insert", value: function (t, e, n) {
                var r = n ? t : this.toBBox(t), i = [], o = this._chooseSubtree(r, this.data, e, i);
                for (o.children.push(t), Ct(o, r); e >= 0 && i[e].children.length > this._maxEntries;) this._split(i, e), e--;
                this._adjustParentBBoxes(r, i, e)
            }
        }, {
            key: "_split", value: function (t, e) {
                var n = t[e], r = n.children.length, i = this._minEntries;
                this._chooseSplitAxis(n, i, r);
                var o = this._chooseSplitIndex(n, i, r), s = qt(n.children.splice(o, n.children.length - o));
                s.height = n.height, s.leaf = n.leaf, Pt(n, this.toBBox), Pt(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(n, s)
            }
        }, {
            key: "_splitRoot", value: function (t, e) {
                this.data = qt([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Pt(this.data, this.toBBox)
            }
        }, {
            key: "_chooseSplitIndex", value: function (t, e, n) {
                for (var r, i, o, s, a, u, l, h = 1 / 0, c = 1 / 0, f = e; f <= n - e; f++) {
                    var g = Lt(t, 0, f, this.toBBox), p = Lt(t, f, n, this.toBBox),
                        v = (i = g, o = p, s = void 0, a = void 0, u = void 0, l = void 0, s = Math.max(i.minX, o.minX), a = Math.max(i.minY, o.minY), u = Math.min(i.maxX, o.maxX), l = Math.min(i.maxY, o.maxY), Math.max(0, u - s) * Math.max(0, l - a)),
                        d = Ot(g) + Ot(p);
                    v < h ? (h = v, r = f, c = d < c ? d : c) : v === h && d < c && (c = d, r = f)
                }
                return r || n - e
            }
        }, {
            key: "_chooseSplitAxis", value: function (t, e, n) {
                var r = t.leaf ? this.compareMinX : Rt, i = t.leaf ? this.compareMinY : Tt;
                this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r)
            }
        }, {
            key: "_allDistMargin", value: function (t, e, n, r) {
                t.children.sort(r);
                for (var i = this.toBBox, o = Lt(t, 0, e, i), s = Lt(t, n - e, n, i), a = At(o) + At(s), u = e; u < n - e; u++) {
                    var l = t.children[u];
                    Ct(o, t.leaf ? i(l) : l), a += At(o)
                }
                for (var h = n - e - 1; h >= e; h--) {
                    var c = t.children[h];
                    Ct(s, t.leaf ? i(c) : c), a += At(s)
                }
                return a
            }
        }, {
            key: "_adjustParentBBoxes", value: function (t, e, n) {
                for (var r = n; r >= 0; r--) Ct(e[r], t)
            }
        }, {
            key: "_condense", value: function (t) {
                for (var e, n = t.length - 1; n >= 0; n--) 0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : Pt(t[n], this.toBBox)
            }
        }]), t
    }();

    function Mt(t, e, n) {
        if (!n) return e.indexOf(t);
        for (var r = 0; r < e.length; r++) if (n(t, e[r])) return r;
        return -1
    }

    function Pt(t, e) {
        Lt(t, 0, t.children.length, e, t)
    }

    function Lt(t, e, n, r, i) {
        i || (i = qt(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
        for (var o = e; o < n; o++) {
            var s = t.children[o];
            Ct(i, t.leaf ? r(s) : s)
        }
        return i
    }

    function Ct(t, e) {
        return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
    }

    function Rt(t, e) {
        return t.minX - e.minX
    }

    function Tt(t, e) {
        return t.minY - e.minY
    }

    function Ot(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY)
    }

    function At(t) {
        return t.maxX - t.minX + (t.maxY - t.minY)
    }

    function Dt(t, e) {
        return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
    }

    function Ft(t, e) {
        return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
    }

    function qt(t) {
        return {children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0}
    }

    function Gt(t, e, n, r, i) {
        for (var o = [e, n]; o.length;) if (!((n = o.pop()) - (e = o.pop()) <= r)) {
            var s = e + Math.ceil((n - e) / r / 2) * r;
            wt(t, s, e, n, i), o.push(e, s, s, n)
        }
    }

    var Yt = Object.freeze({__proto__: null, default: Nt}), Bt = function () {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : zt;
            if (n(this, t), this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i)
        }

        return i(t, [{
            key: "push", value: function (t) {
                this.data.push(t), this.length++, this._up(this.length - 1)
            }
        }, {
            key: "pop", value: function () {
                if (0 !== this.length) {
                    var t = this.data[0], e = this.data.pop();
                    return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t
                }
            }
        }, {
            key: "peek", value: function () {
                return this.data[0]
            }
        }, {
            key: "_up", value: function (t) {
                for (var e = this.data, n = this.compare, r = e[t]; t > 0;) {
                    var i = t - 1 >> 1, o = e[i];
                    if (n(r, o) >= 0) break;
                    e[t] = o, t = i
                }
                e[t] = r
            }
        }, {
            key: "_down", value: function (t) {
                for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) {
                    var o = 1 + (t << 1), s = e[o], a = o + 1;
                    if (a < this.length && n(e[a], s) < 0 && (o = a, s = e[a]), n(s, i) >= 0) break;
                    e[t] = s, t = o
                }
                e[t] = i
            }
        }]), t
    }();

    function zt(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    var Xt = Object.freeze({__proto__: null, default: Bt}), jt = function (t, e, n, r) {
        var i = t[0], o = t[1], s = !1;
        void 0 === n && (n = 0), void 0 === r && (r = e.length);
        for (var a = (r - n) / 2, u = 0, l = a - 1; u < a; l = u++) {
            var h = e[n + 2 * u + 0], c = e[n + 2 * u + 1], f = e[n + 2 * l + 0], g = e[n + 2 * l + 1];
            c > o != g > o && i < (f - h) * (o - c) / (g - c) + h && (s = !s)
        }
        return s
    }, Ut = function (t, e, n, r) {
        var i = t[0], o = t[1], s = !1;
        void 0 === n && (n = 0), void 0 === r && (r = e.length);
        for (var a = r - n, u = 0, l = a - 1; u < a; l = u++) {
            var h = e[u + n][0], c = e[u + n][1], f = e[l + n][0], g = e[l + n][1];
            c > o != g > o && i < (f - h) * (o - c) / (g - c) + h && (s = !s)
        }
        return s
    }, Vt = function (t, e, n, r) {
        return e.length > 0 && Array.isArray(e[0]) ? Ut(t, e, n, r) : jt(t, e, n, r)
    }, Zt = jt;
    Vt.nested = Ut, Vt.flat = Zt;
    "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;

    function Ht(t) {
        if (t.__esModule) return t;
        var e = Object.defineProperty({}, "__esModule", {value: !0});
        return Object.keys(t).forEach((function (n) {
            var r = Object.getOwnPropertyDescriptor(t, n);
            Object.defineProperty(e, n, r.get ? r : {
                enumerable: !0, get: function () {
                    return t[n]
                }
            })
        })), e
    }

    function Wt(t) {
        var e = {exports: {}};
        return t(e, e.exports), e.exports
    }

    var Jt = Wt((function (t, e) {
        !function (t) {
            var e = 134217729, n = 33306690738754706e-32;

            function r(t, e, n, r, i) {
                var o, s, a, u, l = e[0], h = r[0], c = 0, f = 0;
                h > l == h > -l ? (o = l, l = e[++c]) : (o = h, h = r[++f]);
                var g = 0;
                if (c < t && f < n) for (h > l == h > -l ? (a = o - ((s = l + o) - l), l = e[++c]) : (a = o - ((s = h + o) - h), h = r[++f]), o = s, 0 !== a && (i[g++] = a); c < t && f < n;) h > l == h > -l ? (a = o - ((s = o + l) - (u = s - o)) + (l - u), l = e[++c]) : (a = o - ((s = o + h) - (u = s - o)) + (h - u), h = r[++f]), o = s, 0 !== a && (i[g++] = a);
                for (; c < t;) a = o - ((s = o + l) - (u = s - o)) + (l - u), l = e[++c], o = s, 0 !== a && (i[g++] = a);
                for (; f < n;) a = o - ((s = o + h) - (u = s - o)) + (h - u), h = r[++f], o = s, 0 !== a && (i[g++] = a);
                return 0 === o && 0 !== g || (i[g++] = o), g
            }

            function i(t) {
                return new Float64Array(t)
            }

            var o = 33306690738754716e-32, s = 22204460492503146e-32, a = 11093356479670487e-47, u = i(4), l = i(8),
                h = i(12), c = i(16), f = i(4);
            t.orient2d = function (t, i, g, p, v, d) {
                var y = (i - d) * (g - v), m = (t - v) * (p - d), _ = y - m;
                if (0 === y || 0 === m || y > 0 != m > 0) return _;
                var x = Math.abs(y + m);
                return Math.abs(_) >= o * x ? _ : -function (t, i, o, g, p, v, d) {
                    var y, m, _, x, E, k, w, b, I, S, N, M, P, L, C, R, T, O, A = t - p, D = o - p, F = i - v,
                        q = g - v;
                    E = (C = (b = A - (w = (k = e * A) - (k - A))) * (S = q - (I = (k = e * q) - (k - q))) - ((L = A * q) - w * I - b * I - w * S)) - (N = C - (T = (b = F - (w = (k = e * F) - (k - F))) * (S = D - (I = (k = e * D) - (k - D))) - ((R = F * D) - w * I - b * I - w * S))), u[0] = C - (N + E) + (E - T), E = (P = L - ((M = L + N) - (E = M - L)) + (N - E)) - (N = P - R), u[1] = P - (N + E) + (E - R), E = (O = M + N) - M, u[2] = M - (O - E) + (N - E), u[3] = O;
                    var G = function (t, e) {
                        for (var n = e[0], r = 1; r < t; r++) n += e[r];
                        return n
                    }(4, u), Y = s * d;
                    if (G >= Y || -G >= Y) return G;
                    if (y = t - (A + (E = t - A)) + (E - p), _ = o - (D + (E = o - D)) + (E - p), m = i - (F + (E = i - F)) + (E - v), x = g - (q + (E = g - q)) + (E - v), 0 === y && 0 === m && 0 === _ && 0 === x) return G;
                    if (Y = a * d + n * Math.abs(G), (G += A * x + q * y - (F * _ + D * m)) >= Y || -G >= Y) return G;
                    E = (C = (b = y - (w = (k = e * y) - (k - y))) * (S = q - (I = (k = e * q) - (k - q))) - ((L = y * q) - w * I - b * I - w * S)) - (N = C - (T = (b = m - (w = (k = e * m) - (k - m))) * (S = D - (I = (k = e * D) - (k - D))) - ((R = m * D) - w * I - b * I - w * S))), f[0] = C - (N + E) + (E - T), E = (P = L - ((M = L + N) - (E = M - L)) + (N - E)) - (N = P - R), f[1] = P - (N + E) + (E - R), E = (O = M + N) - M, f[2] = M - (O - E) + (N - E), f[3] = O;
                    var B = r(4, u, 4, f, l);
                    E = (C = (b = A - (w = (k = e * A) - (k - A))) * (S = x - (I = (k = e * x) - (k - x))) - ((L = A * x) - w * I - b * I - w * S)) - (N = C - (T = (b = F - (w = (k = e * F) - (k - F))) * (S = _ - (I = (k = e * _) - (k - _))) - ((R = F * _) - w * I - b * I - w * S))), f[0] = C - (N + E) + (E - T), E = (P = L - ((M = L + N) - (E = M - L)) + (N - E)) - (N = P - R), f[1] = P - (N + E) + (E - R), E = (O = M + N) - M, f[2] = M - (O - E) + (N - E), f[3] = O;
                    var z = r(B, l, 4, f, h);
                    E = (C = (b = y - (w = (k = e * y) - (k - y))) * (S = x - (I = (k = e * x) - (k - x))) - ((L = y * x) - w * I - b * I - w * S)) - (N = C - (T = (b = m - (w = (k = e * m) - (k - m))) * (S = _ - (I = (k = e * _) - (k - _))) - ((R = m * _) - w * I - b * I - w * S))), f[0] = C - (N + E) + (E - T), E = (P = L - ((M = L + N) - (E = M - L)) + (N - E)) - (N = P - R), f[1] = P - (N + E) + (E - R), E = (O = M + N) - M, f[2] = M - (O - E) + (N - E), f[3] = O;
                    var X = r(z, h, 4, f, c);
                    return c[X - 1]
                }(t, i, g, p, v, d, x)
            }, t.orient2dfast = function (t, e, n, r, i, o) {
                return (e - o) * (n - i) - (t - i) * (r - o)
            }, Object.defineProperty(t, "__esModule", {value: !0})
        }(e)
    })), Qt = Ht(Yt), Kt = Ht(Xt), $t = Jt.orient2d;
    Kt.default && (Kt = Kt.default);
    var te = ne, ee = ne;

    function ne(t, e, n) {
        e = Math.max(0, void 0 === e ? 2 : e), n = n || 0;
        var r = function (t) {
            for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) {
                var s = t[o];
                s[0] < e[0] && (e = s), s[0] > r[0] && (r = s), s[1] < n[1] && (n = s), s[1] > i[1] && (i = s)
            }
            var a = [e, n, r, i], u = a.slice();
            for (o = 0; o < t.length; o++) Vt(t[o], a) || u.push(t[o]);
            return function (t) {
                t.sort(pe);
                for (var e = [], n = 0; n < t.length; n++) {
                    for (; e.length >= 2 && ue(e[e.length - 2], e[e.length - 1], t[n]) <= 0;) e.pop();
                    e.push(t[n])
                }
                for (var r = [], i = t.length - 1; i >= 0; i--) {
                    for (; r.length >= 2 && ue(r[r.length - 2], r[r.length - 1], t[i]) <= 0;) r.pop();
                    r.push(t[i])
                }
                return r.pop(), e.pop(), e.concat(r)
            }(u)
        }(t), i = new Qt(16);
        i.toBBox = function (t) {
            return {minX: t[0], minY: t[1], maxX: t[0], maxY: t[1]}
        }, i.compareMinX = function (t, e) {
            return t[0] - e[0]
        }, i.compareMinY = function (t, e) {
            return t[1] - e[1]
        }, i.load(t);
        for (var o, s = [], a = 0; a < r.length; a++) {
            var u = r[a];
            i.remove(u), o = he(u, o), s.push(o)
        }
        var l = new Qt(16);
        for (a = 0; a < s.length; a++) l.insert(le(s[a]));
        for (var h = e * e, c = n * n; s.length;) {
            var f = s.shift(), g = f.p, p = f.next.p, v = ce(g, p);
            if (!(v < c)) {
                var d = v / h;
                (u = re(i, f.prev.p, g, p, f.next.next.p, d, l)) && Math.min(ce(u, g), ce(u, p)) <= d && (s.push(f), s.push(he(u, f)), i.remove(u), l.remove(f), l.insert(le(f)), l.insert(le(f.next)))
            }
        }
        f = o;
        var y = [];
        do {
            y.push(f.p), f = f.next
        } while (f !== o);
        return y.push(f.p), y
    }

    function re(t, e, n, r, i, o, s) {
        for (var a = new Kt([], ie), u = t.data; u;) {
            for (var l = 0; l < u.children.length; l++) {
                var h = u.children[l], c = u.leaf ? fe(h, n, r) : oe(n, r, h);
                c > o || a.push({node: h, dist: c})
            }
            for (; a.length && !a.peek().node.children;) {
                var f = a.pop(), g = f.node, p = fe(g, e, n), v = fe(g, r, i);
                if (f.dist < p && f.dist < v && ae(n, g, s) && ae(r, g, s)) return g
            }
            (u = a.pop()) && (u = u.node)
        }
        return null
    }

    function ie(t, e) {
        return t.dist - e.dist
    }

    function oe(t, e, n) {
        if (se(t, n) || se(e, n)) return 0;
        var r = ge(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY);
        if (0 === r) return 0;
        var i = ge(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY);
        if (0 === i) return 0;
        var o = ge(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY);
        if (0 === o) return 0;
        var s = ge(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY);
        return 0 === s ? 0 : Math.min(r, i, o, s)
    }

    function se(t, e) {
        return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY
    }

    function ae(t, e, n) {
        for (var r, i, o, s, a = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), l = Math.max(t[0], e[0]), h = Math.max(t[1], e[1]), c = n.search({
            minX: a,
            minY: u,
            maxX: l,
            maxY: h
        }), f = 0; f < c.length; f++) if (r = c[f].p, i = c[f].next.p, o = t, r !== (s = e) && i !== o && ue(r, i, o) > 0 != ue(r, i, s) > 0 && ue(o, s, r) > 0 != ue(o, s, i) > 0) return !1;
        return !0
    }

    function ue(t, e, n) {
        return $t(t[0], t[1], e[0], e[1], n[0], n[1])
    }

    function le(t) {
        var e = t.p, n = t.next.p;
        return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t
    }

    function he(t, e) {
        var n = {p: t, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0};
        return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n
    }

    function ce(t, e) {
        var n = t[0] - e[0], r = t[1] - e[1];
        return n * n + r * r
    }

    function fe(t, e, n) {
        var r = e[0], i = e[1], o = n[0] - r, s = n[1] - i;
        if (0 !== o || 0 !== s) {
            var a = ((t[0] - r) * o + (t[1] - i) * s) / (o * o + s * s);
            a > 1 ? (r = n[0], i = n[1]) : a > 0 && (r += o * a, i += s * a)
        }
        return (o = t[0] - r) * o + (s = t[1] - i) * s
    }

    function ge(t, e, n, r, i, o, s, a) {
        var u, l, h, c, f = n - t, g = r - e, p = s - i, v = a - o, d = t - i, y = e - o, m = f * f + g * g,
            _ = f * p + g * v, x = p * p + v * v, E = f * d + g * y, k = p * d + v * y, w = m * x - _ * _, b = w, I = w;
        0 === w ? (l = 0, b = 1, c = k, I = x) : (c = m * k - _ * E, (l = _ * k - x * E) < 0 ? (l = 0, c = k, I = x) : l > b && (l = b, c = k + _, I = x)), c < 0 ? (c = 0, -E < 0 ? l = 0 : -E > m ? l = b : (l = -E, b = m)) : c > I && (c = I, -E + _ < 0 ? l = 0 : -E + _ > m ? l = b : (l = -E + _, b = m));
        var S = (1 - (h = 0 === c ? 0 : c / I)) * i + h * s - ((1 - (u = 0 === l ? 0 : l / b)) * t + u * n),
            N = (1 - h) * o + h * a - ((1 - u) * e + u * r);
        return S * S + N * N
    }

    function pe(t, e) {
        return t[0] === e[0] ? t[1] - e[1] : t[0] - e[0]
    }

    function ve(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        e.concavity = e.concavity || 1 / 0;
        var n = [];
        if (B(t, (function (t) {
            n.push([t[0], t[1]])
        })), !n.length) return null;
        var r = te(n, e.concavity);
        return r.length > 3 ? m([r]) : null
    }

    function de(t, e) {
        for (var n = 0, r = 0, i = 0, o = 0, s = 0, a = 0, u = 0, l = 0, h = null, c = null, f = t[0], g = t[1], p = e.length; n < p; n++) {
            r = 0;
            var v = e[n].length - 1, d = e[n];
            if ((h = d[0])[0] !== d[v][0] && h[1] !== d[v][1]) throw new Error("First and last coordinates in a ring must be the same");
            for (s = h[0] - f, a = h[1] - g; r < v; r++) if (l = (c = d[r + 1])[1] - g, a < 0 && l < 0 || a > 0 && l > 0) a = l, s = (h = c)[0] - f; else {
                if (u = c[0] - t[0], l > 0 && a <= 0) {
                    if ((o = s * l - u * a) > 0) i += 1; else if (0 === o) return 0
                } else if (a > 0 && l <= 0) {
                    if ((o = s * l - u * a) < 0) i += 1; else if (0 === o) return 0
                } else if (0 === l && a < 0) {
                    if (0 === (o = s * l - u * a)) return 0
                } else if (0 === a && l < 0) {
                    if (0 === (o = s * l - u * a)) return 0
                } else if (0 === a && 0 === l) {
                    if (u <= 0 && s >= 0) return 0;
                    if (s <= 0 && u >= 0) return 0
                }
                h = c, a = l, s = u
            }
        }
        return i % 2 != 0
    }

    function ye(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!t) throw new Error("point is required");
        if (!e) throw new Error("polygon is required");
        var r = st(t), i = ft(e), o = i.type, s = e.bbox, a = i.coordinates;
        if (s && !1 === me(r, s)) return !1;
        "Polygon" === o && (a = [a]);
        for (var u = !1, l = 0; l < a.length; ++l) {
            var h = de(r, a[l]);
            if (0 === h) return !n.ignoreBoundary;
            h && (u = !0)
        }
        return u
    }

    function me(t, e) {
        return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1]
    }

    function _e(t, e) {
        var n = [];
        return U(t, (function (t) {
            var r = !1;
            if ("Point" === t.geometry.type) H(e, (function (e) {
                ye(t, e) && (r = !0)
            })), r && n.push(t); else {
                if ("MultiPoint" !== t.geometry.type) throw new Error("Input geometry must be a Point or MultiPoint");
                var i = [];
                H(e, (function (e) {
                    B(t, (function (t) {
                        ye(t, e) && (r = !0, i.push(t))
                    }))
                })), r && n.push(b(i, t.properties || {}))
            }
        })), k(n)
    }

    function xe(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = st(t), i = st(e),
            o = T(i[1] - r[1]), s = T(i[0] - r[0]), a = T(r[1]), u = T(i[1]),
            l = Math.pow(Math.sin(o / 2), 2) + Math.pow(Math.sin(s / 2), 2) * Math.cos(a) * Math.cos(u);
        return M(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), n.units)
    }

    function Ee(t, e) {
        var n = !1;
        return k(function (t) {
            if (t.length < 3) return [];
            t.sort(we);
            var e, n, r, i, o, s, a = t.length - 1, u = t[a].x, l = t[0].x, h = t[a].y, c = h, f = 1e-12;
            for (; a--;) t[a].y < h && (h = t[a].y), t[a].y > c && (c = t[a].y);
            var g, p = l - u, v = c - h, d = p > v ? p : v, y = .5 * (l + u), m = .5 * (c + h),
                _ = [new ke({__sentinel: !0, x: y - 20 * d, y: m - d}, {
                    __sentinel: !0,
                    x: y,
                    y: m + 20 * d
                }, {__sentinel: !0, x: y + 20 * d, y: m - d})], x = [], E = [];
            a = t.length;
            for (; a--;) {
                for (E.length = 0, g = _.length; g--;) (p = t[a].x - _[g].x) > 0 && p * p > _[g].r ? (x.push(_[g]), _.splice(g, 1)) : p * p + (v = t[a].y - _[g].y) * v > _[g].r || (E.push(_[g].a, _[g].b, _[g].b, _[g].c, _[g].c, _[g].a), _.splice(g, 1));
                for (be(E), g = E.length; g;) n = E[--g], e = E[--g], r = t[a], i = n.x - e.x, o = n.y - e.y, s = 2 * (i * (r.y - n.y) - o * (r.x - n.x)), Math.abs(s) > f && _.push(new ke(e, n, r))
            }
            Array.prototype.push.apply(x, _), a = x.length;
            for (; a--;) (x[a].a.__sentinel || x[a].b.__sentinel || x[a].c.__sentinel) && x.splice(a, 1);
            return x
        }(t.features.map((function (t) {
            var r = {x: t.geometry.coordinates[0], y: t.geometry.coordinates[1]};
            return e ? r.z = t.properties[e] : 3 === t.geometry.coordinates.length && (n = !0, r.z = t.geometry.coordinates[2]), r
        }))).map((function (t) {
            var e = [t.a.x, t.a.y], r = [t.b.x, t.b.y], i = [t.c.x, t.c.y], o = {};
            return n ? (e.push(t.a.z), r.push(t.b.z), i.push(t.c.z)) : o = {
                a: t.a.z,
                b: t.b.z,
                c: t.c.z
            }, m([[e, r, i, e]], o)
        })))
    }

    te.default = ee;
    var ke = i((function t(e, r, i) {
        n(this, t), this.a = e, this.b = r, this.c = i;
        var o, s, a = r.x - e.x, u = r.y - e.y, l = i.x - e.x, h = i.y - e.y, c = a * (e.x + r.x) + u * (e.y + r.y),
            f = l * (e.x + i.x) + h * (e.y + i.y), g = 2 * (a * (i.y - r.y) - u * (i.x - r.x));
        this.x = (h * c - u * f) / g, this.y = (a * f - l * c) / g, o = this.x - e.x, s = this.y - e.y, this.r = o * o + s * s
    }));

    function we(t, e) {
        return e.x - t.x
    }

    function be(t) {
        var e, n, r, i, o, s = t.length;
        t:for (; s;) for (n = t[--s], e = t[--s], r = s; r;) if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) {
            t.splice(s, 2), t.splice(r, 2), s -= 2;
            continue t
        }
    }

    function Ie(t) {
        if (!t) throw new Error("geojson is required");
        switch (t.type) {
            case"Feature":
                return Se(t);
            case"FeatureCollection":
                return function (t) {
                    var e = {type: "FeatureCollection"};
                    return Object.keys(t).forEach((function (n) {
                        switch (n) {
                            case"type":
                            case"features":
                                return;
                            default:
                                e[n] = t[n]
                        }
                    })), e.features = t.features.map((function (t) {
                        return Se(t)
                    })), e
                }(t);
            case"Point":
            case"LineString":
            case"Polygon":
            case"MultiPoint":
            case"MultiLineString":
            case"MultiPolygon":
            case"GeometryCollection":
                return Me(t);
            default:
                throw new Error("unknown GeoJSON type")
        }
    }

    function Se(t) {
        var e = {type: "Feature"};
        return Object.keys(t).forEach((function (n) {
            switch (n) {
                case"type":
                case"properties":
                case"geometry":
                    return;
                default:
                    e[n] = t[n]
            }
        })), e.properties = Ne(t.properties), null == t.geometry ? e.geometry = null : e.geometry = Me(t.geometry), e
    }

    function Ne(t) {
        var n = {};
        return t ? (Object.keys(t).forEach((function (r) {
            var i = t[r];
            "object" === e(i) ? null === i ? n[r] = null : Array.isArray(i) ? n[r] = i.map((function (t) {
                return t
            })) : n[r] = Ne(i) : n[r] = i
        })), n) : n
    }

    function Me(t) {
        var e = {type: t.type};
        return t.bbox && (e.bbox = t.bbox), "GeometryCollection" === t.type ? (e.geometries = t.geometries.map((function (t) {
            return Me(t)
        })), e) : (e.coordinates = Pe(t.coordinates), e)
    }

    function Pe(t) {
        var n = t;
        return "object" !== e(n[0]) ? n.slice() : n.map((function (t) {
            return Pe(t)
        }))
    }

    function Le(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.mutate;
        if ("FeatureCollection" !== gt(t)) throw new Error("geojson must be a FeatureCollection");
        if (!t.features.length) throw new Error("geojson is empty");
        !1 !== n && void 0 !== n || (t = Ie(t));
        var r = [], i = et(t, (function (t, e) {
            var n = Re(t, e);
            return n || (r.push(t), e)
        }));
        return i && r.push(i), r.length ? 1 === r.length ? r[0] : w(r.map((function (t) {
            return t.coordinates
        }))) : null
    }

    function Ce(t) {
        return t[0].toString() + "," + t[1].toString()
    }

    function Re(t, e) {
        var n, r = t.geometry.coordinates, i = e.geometry.coordinates, o = Ce(r[0]), s = Ce(r[r.length - 1]),
            a = Ce(i[0]), u = Ce(i[i.length - 1]);
        if (o === u) n = i.concat(r.slice(1)); else if (a === s) n = r.concat(i.slice(1)); else if (o === a) n = r.slice(1).reverse().concat(i); else {
            if (s !== u) return null;
            n = r.concat(i.reverse().slice(1))
        }
        return x(n)
    }

    function Te(t) {
        return t
    }

    function Oe(t, e) {
        var n = function (t) {
            if (null == t) return Te;
            var e, n, r = t.scale[0], i = t.scale[1], o = t.translate[0], s = t.translate[1];
            return function (t, a) {
                a || (e = n = 0);
                var u = 2, l = t.length, h = new Array(l);
                for (h[0] = (e += t[0]) * r + o, h[1] = (n += t[1]) * i + s; u < l;) h[u] = t[u], ++u;
                return h
            }
        }(t.transform), r = t.arcs;

        function i(t, e) {
            e.length && e.pop();
            for (var i = r[t < 0 ? ~t : t], o = 0, s = i.length; o < s; ++o) e.push(n(i[o], o));
            t < 0 && function (t, e) {
                for (var n, r = t.length, i = r - e; i < --r;) n = t[i], t[i++] = t[r], t[r] = n
            }(e, s)
        }

        function o(t) {
            return n(t)
        }

        function s(t) {
            for (var e = [], n = 0, r = t.length; n < r; ++n) i(t[n], e);
            return e.length < 2 && e.push(e[0]), e
        }

        function a(t) {
            for (var e = s(t); e.length < 4;) e.push(e[0]);
            return e
        }

        function u(t) {
            return t.map(a)
        }

        return function t(e) {
            var n, r = e.type;
            switch (r) {
                case"GeometryCollection":
                    return {type: r, geometries: e.geometries.map(t)};
                case"Point":
                    n = o(e.coordinates);
                    break;
                case"MultiPoint":
                    n = e.coordinates.map(o);
                    break;
                case"LineString":
                    n = s(e.arcs);
                    break;
                case"MultiLineString":
                    n = e.arcs.map(s);
                    break;
                case"Polygon":
                    n = u(e.arcs);
                    break;
                case"MultiPolygon":
                    n = e.arcs.map(u);
                    break;
                default:
                    return null
            }
            return {type: r, coordinates: n}
        }(e)
    }

    function Ae(t, e) {
        var n = {}, r = {}, i = {}, o = [], s = -1;

        function a(t, e) {
            for (var r in t) {
                var i = t[r];
                delete e[i.start], delete i.start, delete i.end, i.forEach((function (t) {
                    n[t < 0 ? ~t : t] = 1
                })), o.push(i)
            }
        }

        return e.forEach((function (n, r) {
            var i, o = t.arcs[n < 0 ? ~n : n];
            o.length < 3 && !o[1][0] && !o[1][1] && (i = e[++s], e[s] = n, e[r] = i)
        })), e.forEach((function (e) {
            var n, o, s = function (e) {
                var n, r = t.arcs[e < 0 ? ~e : e], i = r[0];
                t.transform ? (n = [0, 0], r.forEach((function (t) {
                    n[0] += t[0], n[1] += t[1]
                }))) : n = r[r.length - 1];
                return e < 0 ? [n, i] : [i, n]
            }(e), a = s[0], u = s[1];
            if (n = i[a]) if (delete i[n.end], n.push(e), n.end = u, o = r[u]) {
                delete r[o.start];
                var l = o === n ? n : n.concat(o);
                r[l.start = n.start] = i[l.end = o.end] = l
            } else r[n.start] = i[n.end] = n; else if (n = r[u]) if (delete r[n.start], n.unshift(e), n.start = a, o = i[a]) {
                delete i[o.end];
                var h = o === n ? n : o.concat(n);
                r[h.start = o.start] = i[h.end = n.end] = h
            } else r[n.start] = i[n.end] = n; else r[(n = [e]).start = a] = i[n.end = u] = n
        })), a(i, r), a(r, i), e.forEach((function (t) {
            n[t < 0 ? ~t : t] || o.push([t])
        })), o
    }

    function De(t) {
        return Oe(t, Fe.apply(this, arguments))
    }

    function Fe(t, e) {
        var n = {}, r = [], i = [];

        function o(t) {
            t.forEach((function (e) {
                e.forEach((function (e) {
                    (n[e = e < 0 ? ~e : e] || (n[e] = [])).push(t)
                }))
            })), r.push(t)
        }

        function s(e) {
            return function (t) {
                for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;) e = i, i = t[n], o += e[0] * i[1] - e[1] * i[0];
                return Math.abs(o)
            }(Oe(t, {type: "Polygon", arcs: [e]}).coordinates[0])
        }

        return e.forEach((function t(e) {
            switch (e.type) {
                case"GeometryCollection":
                    e.geometries.forEach(t);
                    break;
                case"Polygon":
                    o(e.arcs);
                    break;
                case"MultiPolygon":
                    e.arcs.forEach(o)
            }
        })), r.forEach((function (t) {
            if (!t._) {
                var e = [], r = [t];
                for (t._ = 1, i.push(e); t = r.pop();) e.push(t), t.forEach((function (t) {
                    t.forEach((function (t) {
                        n[t < 0 ? ~t : t].forEach((function (t) {
                            t._ || (t._ = 1, r.push(t))
                        }))
                    }))
                }))
            }
        })), r.forEach((function (t) {
            delete t._
        })), {
            type: "MultiPolygon", arcs: i.map((function (e) {
                var r, i = [];
                if (e.forEach((function (t) {
                    t.forEach((function (t) {
                        t.forEach((function (t) {
                            n[t < 0 ? ~t : t].length < 2 && i.push(t)
                        }))
                    }))
                })), (r = (i = Ae(t, i)).length) > 1) for (var o, a, u = 1, l = s(i[0]); u < r; ++u) (o = s(i[u])) > l && (a = i[0], i[0] = i[u], i[u] = a, l = o);
                return i
            })).filter((function (t) {
                return t.length > 0
            }))
        }
    }

    var qe = Object.prototype.hasOwnProperty;

    function Ge(t, e, n, r, i, o) {
        3 === arguments.length && (r = o = Array, i = null);
        for (var s = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = new o(t), u = t - 1, l = 0; l < t; ++l) s[l] = i;

        function h(r, o) {
            for (var l = e(r) & u, h = s[l], c = 0; h != i;) {
                if (n(h, r)) return a[l] = o;
                if (++c >= t) throw new Error("full hashmap");
                h = s[l = l + 1 & u]
            }
            return s[l] = r, a[l] = o, o
        }

        function c(r, o) {
            for (var l = e(r) & u, h = s[l], c = 0; h != i;) {
                if (n(h, r)) return a[l];
                if (++c >= t) throw new Error("full hashmap");
                h = s[l = l + 1 & u]
            }
            return s[l] = r, a[l] = o, o
        }

        function f(r, o) {
            for (var l = e(r) & u, h = s[l], c = 0; h != i;) {
                if (n(h, r)) return a[l];
                if (++c >= t) break;
                h = s[l = l + 1 & u]
            }
            return o
        }

        function g() {
            for (var t = [], e = 0, n = s.length; e < n; ++e) {
                var r = s[e];
                r != i && t.push(r)
            }
            return t
        }

        return {set: h, maybeSet: c, get: f, keys: g}
    }

    function Ye(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    var Be = new ArrayBuffer(16), ze = new Float64Array(Be), Xe = new Uint32Array(Be);

    function je(t) {
        ze[0] = t[0], ze[1] = t[1];
        var e = Xe[0] ^ Xe[1];
        return 2147483647 & (e = e << 5 ^ e >> 7 ^ Xe[2] ^ Xe[3])
    }

    function Ue(t) {
        var e, n, r, i, o = t.coordinates, s = t.lines, a = t.rings, u = function () {
                for (var t = Ge(1.4 * o.length, E, k, Int32Array, -1, Int32Array), e = new Int32Array(o.length), n = 0, r = o.length; n < r; ++n) e[n] = t.maybeSet(n, n);
                return e
            }(), l = new Int32Array(o.length), h = new Int32Array(o.length), c = new Int32Array(o.length),
            f = new Int8Array(o.length), g = 0;
        for (e = 0, n = o.length; e < n; ++e) l[e] = h[e] = c[e] = -1;
        for (e = 0, n = s.length; e < n; ++e) {
            var p = s[e], v = p[0], d = p[1];
            for (r = u[v], i = u[++v], ++g, f[r] = 1; ++v <= d;) x(e, r, r = i, i = u[v]);
            ++g, f[i] = 1
        }
        for (e = 0, n = o.length; e < n; ++e) l[e] = -1;
        for (e = 0, n = a.length; e < n; ++e) {
            var y = a[e], m = y[0] + 1, _ = y[1];
            for (x(e, u[_ - 1], r = u[m - 1], i = u[m]); ++m <= _;) x(e, r, r = i, i = u[m])
        }

        function x(t, e, n, r) {
            if (l[n] !== t) {
                l[n] = t;
                var i = h[n];
                if (i >= 0) {
                    var o = c[n];
                    i === e && o === r || i === r && o === e || (++g, f[n] = 1)
                } else h[n] = e, c[n] = r
            }
        }

        function E(t) {
            return je(o[t])
        }

        function k(t, e) {
            return Ye(o[t], o[e])
        }

        l = h = c = null;
        var w, b = function (t, e, n, r, i) {
            3 === arguments.length && (r = Array, i = null);
            for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), s = t - 1, a = 0; a < t; ++a) o[a] = i;

            function u(r) {
                for (var a = e(r) & s, u = o[a], l = 0; u != i;) {
                    if (n(u, r)) return !0;
                    if (++l >= t) throw new Error("full hashset");
                    u = o[a = a + 1 & s]
                }
                return o[a] = r, !0
            }

            function l(r) {
                for (var a = e(r) & s, u = o[a], l = 0; u != i;) {
                    if (n(u, r)) return !0;
                    if (++l >= t) break;
                    u = o[a = a + 1 & s]
                }
                return !1
            }

            function h() {
                for (var t = [], e = 0, n = o.length; e < n; ++e) {
                    var r = o[e];
                    r != i && t.push(r)
                }
                return t
            }

            return {add: u, has: l, values: h}
        }(1.4 * g, je, Ye);
        for (e = 0, n = o.length; e < n; ++e) f[w = u[e]] && b.add(o[w]);
        return b
    }

    function Ve(t, e, n, r) {
        Ze(t, e, n), Ze(t, e, e + r), Ze(t, e + r, n)
    }

    function Ze(t, e, n) {
        for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n) r = t[e], t[e] = t[n], t[n] = r
    }

    function He(t) {
        var e, n, r = {};
        for (e in t) r[e] = null == (n = t[e]) ? {type: null} : ("FeatureCollection" === n.type ? We : "Feature" === n.type ? Je : Qe)(n);
        return r
    }

    function We(t) {
        var e = {type: "GeometryCollection", geometries: t.features.map(Je)};
        return null != t.bbox && (e.bbox = t.bbox), e
    }

    function Je(t) {
        var e, n = Qe(t.geometry);
        for (e in null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties) {
            n.properties = t.properties;
            break
        }
        return n
    }

    function Qe(t) {
        if (null == t) return {type: null};
        var e = "GeometryCollection" === t.type ? {
            type: "GeometryCollection",
            geometries: t.geometries.map(Qe)
        } : "Point" === t.type || "MultiPoint" === t.type ? {type: t.type, coordinates: t.coordinates} : {
            type: t.type,
            arcs: t.coordinates
        };
        return null != t.bbox && (e.bbox = t.bbox), e
    }

    function Ke(t, e) {
        var n = function (t) {
            var e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0;

            function o(t) {
                null != t && qe.call(s, t.type) && s[t.type](t)
            }

            var s = {
                GeometryCollection: function (t) {
                    t.geometries.forEach(o)
                }, Point: function (t) {
                    a(t.coordinates)
                }, MultiPoint: function (t) {
                    t.coordinates.forEach(a)
                }, LineString: function (t) {
                    u(t.arcs)
                }, MultiLineString: function (t) {
                    t.arcs.forEach(u)
                }, Polygon: function (t) {
                    t.arcs.forEach(u)
                }, MultiPolygon: function (t) {
                    t.arcs.forEach(l)
                }
            };

            function a(t) {
                var o = t[0], s = t[1];
                o < e && (e = o), o > r && (r = o), s < n && (n = s), s > i && (i = s)
            }

            function u(t) {
                t.forEach(a)
            }

            function l(t) {
                t.forEach(u)
            }

            for (var h in t) o(t[h]);
            return r >= e && i >= n ? [e, n, r, i] : void 0
        }(t = He(t)), r = e > 0 && n && function (t, e, n) {
            var r = e[0], i = e[1], o = e[2], s = e[3], a = o - r ? (n - 1) / (o - r) : 1,
                u = s - i ? (n - 1) / (s - i) : 1;

            function l(t) {
                return [Math.round((t[0] - r) * a), Math.round((t[1] - i) * u)]
            }

            function h(t, e) {
                for (var n, o, s, l, h, c = -1, f = 0, g = t.length, p = new Array(g); ++c < g;) n = t[c], l = Math.round((n[0] - r) * a), h = Math.round((n[1] - i) * u), l === o && h === s || (p[f++] = [o = l, s = h]);
                for (p.length = f; f < e;) f = p.push([p[0][0], p[0][1]]);
                return p
            }

            function c(t) {
                return h(t, 2)
            }

            function f(t) {
                return h(t, 4)
            }

            function g(t) {
                return t.map(f)
            }

            function p(t) {
                null != t && qe.call(v, t.type) && v[t.type](t)
            }

            var v = {
                GeometryCollection: function (t) {
                    t.geometries.forEach(p)
                }, Point: function (t) {
                    t.coordinates = l(t.coordinates)
                }, MultiPoint: function (t) {
                    t.coordinates = t.coordinates.map(l)
                }, LineString: function (t) {
                    t.arcs = c(t.arcs)
                }, MultiLineString: function (t) {
                    t.arcs = t.arcs.map(c)
                }, Polygon: function (t) {
                    t.arcs = g(t.arcs)
                }, MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(g)
                }
            };
            for (var d in t) p(t[d]);
            return {scale: [1 / a, 1 / u], translate: [r, i]}
        }(t, n, e), i = function (t) {
            var e, n, r, i, o = t.coordinates, s = t.lines, a = t.rings, u = s.length + a.length;
            for (delete t.lines, delete t.rings, r = 0, i = s.length; r < i; ++r) for (e = s[r]; e = e.next;) ++u;
            for (r = 0, i = a.length; r < i; ++r) for (n = a[r]; n = n.next;) ++u;
            var l = Ge(2 * u * 1.4, je, Ye), h = t.arcs = [];
            for (r = 0, i = s.length; r < i; ++r) {
                e = s[r];
                do {
                    c(e)
                } while (e = e.next)
            }
            for (r = 0, i = a.length; r < i; ++r) if ((n = a[r]).next) do {
                c(n)
            } while (n = n.next); else f(n);

            function c(t) {
                var e, n, r, i, s, a, u, c;
                if (r = l.get(e = o[t[0]])) for (u = 0, c = r.length; u < c; ++u) if (g(i = r[u], t)) return t[0] = i[0], void (t[1] = i[1]);
                if (s = l.get(n = o[t[1]])) for (u = 0, c = s.length; u < c; ++u) if (p(a = s[u], t)) return t[1] = a[0], void (t[0] = a[1]);
                r ? r.push(t) : l.set(e, [t]), s ? s.push(t) : l.set(n, [t]), h.push(t)
            }

            function f(t) {
                var e, n, r, i, s;
                if (n = l.get(o[t[0]])) for (i = 0, s = n.length; i < s; ++i) {
                    if (v(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]);
                    if (d(r, t)) return t[0] = r[1], void (t[1] = r[0])
                }
                if (n = l.get(e = o[t[0] + y(t)])) for (i = 0, s = n.length; i < s; ++i) {
                    if (v(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]);
                    if (d(r, t)) return t[0] = r[1], void (t[1] = r[0])
                }
                n ? n.push(t) : l.set(e, [t]), h.push(t)
            }

            function g(t, e) {
                var n = t[0], r = e[0], i = t[1];
                if (n - i != r - e[1]) return !1;
                for (; n <= i; ++n, ++r) if (!Ye(o[n], o[r])) return !1;
                return !0
            }

            function p(t, e) {
                var n = t[0], r = e[0], i = t[1], s = e[1];
                if (n - i != r - s) return !1;
                for (; n <= i; ++n, --s) if (!Ye(o[n], o[s])) return !1;
                return !0
            }

            function v(t, e) {
                var n = t[0], r = e[0], i = t[1] - n;
                if (i !== e[1] - r) return !1;
                for (var s = y(t), a = y(e), u = 0; u < i; ++u) if (!Ye(o[n + (u + s) % i], o[r + (u + a) % i])) return !1;
                return !0
            }

            function d(t, e) {
                var n = t[0], r = e[0], i = t[1], s = e[1], a = i - n;
                if (a !== s - r) return !1;
                for (var u = y(t), l = a - y(e), h = 0; h < a; ++h) if (!Ye(o[n + (h + u) % a], o[s - (h + l) % a])) return !1;
                return !0
            }

            function y(t) {
                for (var e = t[0], n = t[1], r = e, i = r, s = o[r]; ++r < n;) {
                    var a = o[r];
                    (a[0] < s[0] || a[0] === s[0] && a[1] < s[1]) && (i = r, s = a)
                }
                return i - e
            }

            return t
        }(function (t) {
            var e, n, r, i = Ue(t), o = t.coordinates, s = t.lines, a = t.rings;
            for (n = 0, r = s.length; n < r; ++n) for (var u = s[n], l = u[0], h = u[1]; ++l < h;) i.has(o[l]) && (e = {
                0: l,
                1: u[1]
            }, u[1] = l, u = u.next = e);
            for (n = 0, r = a.length; n < r; ++n) for (var c = a[n], f = c[0], g = f, p = c[1], v = i.has(o[f]); ++g < p;) i.has(o[g]) && (v ? (e = {
                0: g,
                1: c[1]
            }, c[1] = g, c = c.next = e) : (Ve(o, f, p, p - g), o[p] = o[f], v = !0, g = f));
            return t
        }(function (t) {
            var e = -1, n = [], r = [], i = [];

            function o(t) {
                t && qe.call(s, t.type) && s[t.type](t)
            }

            var s = {
                GeometryCollection: function (t) {
                    t.geometries.forEach(o)
                }, LineString: function (t) {
                    t.arcs = a(t.arcs)
                }, MultiLineString: function (t) {
                    t.arcs = t.arcs.map(a)
                }, Polygon: function (t) {
                    t.arcs = t.arcs.map(u)
                }, MultiPolygon: function (t) {
                    t.arcs = t.arcs.map(l)
                }
            };

            function a(t) {
                for (var r = 0, o = t.length; r < o; ++r) i[++e] = t[r];
                var s = {0: e - o + 1, 1: e};
                return n.push(s), s
            }

            function u(t) {
                for (var n = 0, o = t.length; n < o; ++n) i[++e] = t[n];
                var s = {0: e - o + 1, 1: e};
                return r.push(s), s
            }

            function l(t) {
                return t.map(u)
            }

            for (var h in t) o(t[h]);
            return {type: "Topology", coordinates: i, lines: n, rings: r, objects: t}
        }(t))), o = i.coordinates, s = Ge(1.4 * i.arcs.length, $e, tn);

        function a(t) {
            t && qe.call(u, t.type) && u[t.type](t)
        }

        t = i.objects, i.bbox = n, i.arcs = i.arcs.map((function (t, e) {
            return s.set(t, e), o.slice(t[0], t[1] + 1)
        })), delete i.coordinates, o = null;
        var u = {
            GeometryCollection: function (t) {
                t.geometries.forEach(a)
            }, LineString: function (t) {
                t.arcs = l(t.arcs)
            }, MultiLineString: function (t) {
                t.arcs = t.arcs.map(l)
            }, Polygon: function (t) {
                t.arcs = t.arcs.map(l)
            }, MultiPolygon: function (t) {
                t.arcs = t.arcs.map(h)
            }
        };

        function l(t) {
            var e = [];
            do {
                var n = s.get(t);
                e.push(t[0] < t[1] ? n : ~n)
            } while (t = t.next);
            return e
        }

        function h(t) {
            return t.map(l)
        }

        for (var c in t) a(t[c]);
        return r && (i.transform = r, i.arcs = function (t) {
            for (var e = -1, n = t.length; ++e < n;) {
                for (var r, i, o = t[e], s = 0, a = 1, u = o.length, l = o[0], h = l[0], c = l[1]; ++s < u;) r = (l = o[s])[0], i = l[1], r === h && i === c || (o[a++] = [r - h, i - c], h = r, c = i);
                1 === a && (o[a++] = [0, 0]), o.length = a
            }
            return t
        }(i.arcs)), i
    }

    function $e(t) {
        var e, n = t[0], r = t[1];
        return r < n && (e = n, n = r, r = e), n + 31 * r
    }

    function tn(t, e) {
        var n, r = t[0], i = t[1], o = e[0], s = e[1];
        return i < r && (n = r, r = i, i = n), s < o && (n = o, o = s, s = n), r === o && i === s
    }

    function en(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if ("FeatureCollection" !== gt(t)) throw new Error("geojson must be a FeatureCollection");
        if (!t.features.length) throw new Error("geojson is empty");
        !1 !== e.mutate && void 0 !== e.mutate || (t = Ie(t));
        var n = [];
        J(t, (function (t) {
            n.push(t.geometry)
        }));
        var r = Ke({geoms: S(n).geometry}), i = De(r, r.objects.geoms.geometries);
        return i
    }

    function nn(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.mutate;
        if ("FeatureCollection" !== gt(t)) throw new Error("geojson must be a FeatureCollection");
        if (!t.features.length) throw new Error("geojson is empty");
        !1 !== n && void 0 !== n || (t = Ie(t));
        var r = rn(t);
        if (!r) throw new Error("geojson must be homogenous");
        var i = t;
        switch (r) {
            case"LineString":
                return Le(i, e);
            case"Polygon":
                return en(i, e);
            default:
                throw new Error(r + " is not supported")
        }
    }

    function rn(t) {
        var e = {};
        J(t, (function (t) {
            e[t.geometry.type] = !0
        }));
        var n = Object.keys(e);
        return 1 === n.length ? n[0] : null
    }

    function on(t) {
        var e = [], n = {};
        return U(t, (function (t) {
            if (t.geometry) {
                var r = t.geometry.coordinates.join("-");
                Object.prototype.hasOwnProperty.call(n, r) || (e.push(t), n[r] = !0)
            }
        })), k(e)
    }

    function sn(t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            r = "object" === e(n) ? n.mutate : n;
        if (!t) throw new Error("geojson is required");
        var i = gt(t), o = [];
        switch (i) {
            case"LineString":
                o = an(t, i);
                break;
            case"MultiLineString":
            case"Polygon":
                at(t).forEach((function (t) {
                    o.push(an(t, i))
                }));
                break;
            case"MultiPolygon":
                at(t).forEach((function (t) {
                    var e = [];
                    t.forEach((function (t) {
                        e.push(an(t, i))
                    })), o.push(e)
                }));
                break;
            case"Point":
                return t;
            case"MultiPoint":
                var s = {};
                at(t).forEach((function (t) {
                    var e = t.join("-");
                    Object.prototype.hasOwnProperty.call(s, e) || (o.push(t), s[e] = !0)
                }));
                break;
            default:
                throw new Error(i + " geometry not supported")
        }
        return t.coordinates ? !0 === r ? (t.coordinates = o, t) : {
            type: i,
            coordinates: o
        } : !0 === r ? (t.geometry.coordinates = o, t) : p({type: i, coordinates: o}, t.properties, {
            bbox: t.bbox,
            id: t.id
        })
    }

    function an(t, e) {
        var n = at(t);
        if (2 === n.length && !un(n[0], n[1])) return n;
        var r = [], i = n.length - 1, o = r.length;
        r.push(n[0]);
        for (var s = 1; s < i; s++) {
            var a = r[r.length - 1];
            n[s][0] === a[0] && n[s][1] === a[1] || (r.push(n[s]), (o = r.length) > 2 && ln(r[o - 3], r[o - 1], r[o - 2]) && r.splice(r.length - 2, 1))
        }
        if (r.push(n[n.length - 1]), o = r.length, ("Polygon" === e || "MultiPolygon" === e) && un(n[0], n[n.length - 1]) && o < 4) throw new Error("invalid polygon");
        return ln(r[o - 3], r[o - 1], r[o - 2]) && r.splice(r.length - 2, 1), r
    }

    function un(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function ln(t, e, n) {
        var r = n[0], i = n[1], o = t[0], s = t[1], a = e[0], u = e[1], l = a - o, h = u - s;
        return 0 === (r - o) * h - (i - s) * l && (Math.abs(l) >= Math.abs(h) ? l > 0 ? o <= r && r <= a : a <= r && r <= o : h > 0 ? s <= i && i <= u : u <= i && i <= s)
    }

    function hn(t, e, n) {
        var r = e.x, i = e.y, o = n.x - r, s = n.y - i;
        if (0 !== o || 0 !== s) {
            var a = ((t.x - r) * o + (t.y - i) * s) / (o * o + s * s);
            a > 1 ? (r = n.x, i = n.y) : a > 0 && (r += o * a, i += s * a)
        }
        return (o = t.x - r) * o + (s = t.y - i) * s
    }

    function cn(t, e, n, r, i) {
        for (var o, s = r, a = e + 1; a < n; a++) {
            var u = hn(t[a], t[e], t[n]);
            u > s && (o = a, s = u)
        }
        s > r && (o - e > 1 && cn(t, e, o, r, i), i.push(t[o]), n - o > 1 && cn(t, o, n, r, i))
    }

    function fn(t, e) {
        var n = t.length - 1, r = [t[0]];
        return cn(t, 0, n, e, r), r.push(t[n]), r
    }

    function gn(t, e, n) {
        if (t.length <= 2) return t;
        var r = void 0 !== e ? e * e : 1;
        return t = n ? t : function (t, e) {
            for (var n, r, i, o, s, a = t[0], u = [a], l = 1, h = t.length; l < h; l++) n = t[l], i = a, o = void 0, s = void 0, o = (r = n).x - i.x, s = r.y - i.y, o * o + s * s > e && (u.push(n), a = n);
            return a !== n && u.push(n), u
        }(t, r), t = fn(t, r)
    }

    function pn(t, e, n) {
        return gn(t.map((function (t) {
            return {x: t[0], y: t[1], z: t[2]}
        })), e, n).map((function (t) {
            return t.z ? [t.x, t.y, t.z] : [t.x, t.y]
        }))
    }

    function vn(t, e, n) {
        return t.map((function (t) {
            var r = t.map((function (t) {
                return {x: t[0], y: t[1]}
            }));
            if (r.length < 4) throw new Error("invalid polygon");
            for (var i = gn(r, e, n).map((function (t) {
                return [t.x, t.y]
            })); !dn(i);) i = gn(r, e -= .01 * e, n).map((function (t) {
                return [t.x, t.y]
            }));
            return i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1] || i.push(i[0]), i
        }))
    }

    function dn(t) {
        return !(t.length < 3) && !(3 === t.length && t[2][0] === t[0][0] && t[2][1] === t[0][1])
    }

    /**
     * BezierSpline
     * https://github.com/leszekr/bezier-spline-js
     *
     * @private
     * @copyright
     * Copyright (c) 2013 Leszek Rybicki
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */var yn = function () {
        function t(e) {
            n(this, t), this.points = e.points || [], this.duration = e.duration || 1e4, this.sharpness = e.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = e.stepLength || 60, this.length = this.points.length, this.delay = 0;
            for (var r = 0; r < this.length; r++) this.points[r].z = this.points[r].z || 0;
            for (var i = 0; i < this.length - 1; i++) {
                var o = this.points[i], s = this.points[i + 1];
                this.centers.push({x: (o.x + s.x) / 2, y: (o.y + s.y) / 2, z: (o.z + s.z) / 2})
            }
            this.controls.push([this.points[0], this.points[0]]);
            for (var a = 0; a < this.centers.length - 1; a++) {
                var u = this.points[a + 1].x - (this.centers[a].x + this.centers[a + 1].x) / 2,
                    l = this.points[a + 1].y - (this.centers[a].y + this.centers[a + 1].y) / 2,
                    h = this.points[a + 1].z - (this.centers[a].y + this.centers[a + 1].z) / 2;
                this.controls.push([{
                    x: (1 - this.sharpness) * this.points[a + 1].x + this.sharpness * (this.centers[a].x + u),
                    y: (1 - this.sharpness) * this.points[a + 1].y + this.sharpness * (this.centers[a].y + l),
                    z: (1 - this.sharpness) * this.points[a + 1].z + this.sharpness * (this.centers[a].z + h)
                }, {
                    x: (1 - this.sharpness) * this.points[a + 1].x + this.sharpness * (this.centers[a + 1].x + u),
                    y: (1 - this.sharpness) * this.points[a + 1].y + this.sharpness * (this.centers[a + 1].y + l),
                    z: (1 - this.sharpness) * this.points[a + 1].z + this.sharpness * (this.centers[a + 1].z + h)
                }])
            }
            return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this
        }

        return i(t, [{
            key: "cacheSteps", value: function (t) {
                var e = [], n = this.pos(0);
                e.push(0);
                for (var r = 0; r < this.duration; r += 10) {
                    var i = this.pos(r);
                    Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t && (e.push(r), n = i)
                }
                return e
            }
        }, {
            key: "vector", value: function (t) {
                var e = this.pos(t + 10), n = this.pos(t - 10);
                return {
                    angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,
                    speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))
                }
            }
        }, {
            key: "pos", value: function (t) {
                var e = t - this.delay;
                e < 0 && (e = 0), e > this.duration && (e = this.duration - 1);
                var n = e / this.duration;
                if (n >= 1) return this.points[this.length - 1];
                var r = Math.floor((this.points.length - 1) * n);
                return function (t, e, n, r, i) {
                    var o = function (t) {
                        var e = t * t;
                        return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)]
                    }(t);
                    return {
                        x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3],
                        y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3],
                        z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3]
                    }
                }((this.length - 1) * n - r, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1])
            }
        }]), t
    }();

    function mn(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = Number(t[0]), r = Number(t[1]),
            i = Number(t[2]), o = Number(t[3]);
        if (6 === t.length) throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
        var s = [n, r], a = [n, o], u = [i, o], l = [i, r];
        return m([[s, l, u, a, s]], e.properties, {bbox: t, id: e.id})
    }

    function _n(t) {
        return mn(ot(t))
    }

    function xn(t) {
        var e = t[0], n = t[1], r = t[2], i = t[3];
        if (xe(t.slice(0, 2), [r, n]) >= xe(t.slice(0, 2), [e, i])) {
            var o = (n + i) / 2;
            return [e, o - (r - e) / 2, r, o + (r - e) / 2]
        }
        var s = (e + r) / 2;
        return [s - (i - n) / 2, n, s + (i - n) / 2, i]
    }

    function En(t, e, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = st(t), o = T(i[0]),
            s = T(i[1]), a = T(n), u = P(e, r.units),
            l = Math.asin(Math.sin(s) * Math.cos(u) + Math.cos(s) * Math.sin(u) * Math.cos(a)),
            h = o + Math.atan2(Math.sin(a) * Math.sin(u) * Math.cos(s), Math.cos(u) - Math.sin(s) * Math.sin(l)),
            c = R(h), f = R(l);
        return d([c, f], r.properties)
    }

    function kn(t, e) {
        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.steps || 64, i = n.properties ? n.properties : !Array.isArray(t) && "Feature" === t.type && t.properties ? t.properties : {}, o = [], s = 0; s < r; s++) o.push(En(t, e, -360 * s / r, n).geometry.coordinates);
        return o.push(o[0]), m([o], i)
    }

    function wn(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!0 === n.final) return bn(t, e);
        var r = st(t), i = st(e), o = T(r[0]), s = T(i[0]), a = T(r[1]), u = T(i[1]), l = Math.sin(s - o) * Math.cos(u),
            h = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(s - o);
        return R(Math.atan2(l, h))
    }

    function bn(t, e) {
        var n = wn(e, t);
        return n = (n + 180) % 360
    }

    function In(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = ot(t), r = (n[0] + n[2]) / 2,
            i = (n[1] + n[3]) / 2;
        return d([r, i], e.properties, e)
    }

    function Sn(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = 0, r = 0, i = 0;
        return B(t, (function (t) {
            n += t[0], r += t[1], i++
        }), !0), d([n / i, r / i], e.properties)
    }

    function Nn(t) {
        var e = [];
        return "FeatureCollection" === t.type ? U(t, (function (t) {
            B(t, (function (n) {
                e.push(d(n, t.properties))
            }))
        })) : B(t, (function (n) {
            e.push(d(n, t.properties))
        })), k(e)
    }

    var Mn = Ln, Pn = Ln;

    function Ln(t, e, n) {
        n = n || 2;
        var r, i, o, s, a, u, l, h = e && e.length, c = h ? e[0] * n : t.length, f = Cn(t, 0, c, n, !0), g = [];
        if (!f) return g;
        if (h && (f = function (t, e, n, r) {
            var i, o, s, a = [];
            for (i = 0, o = e.length; i < o; i++) (s = Cn(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === s.next && (s.steiner = !0), a.push(Bn(s));
            for (a.sort(qn), i = 0; i < a.length; i++) Gn(a[i], n), n = Rn(n, n.next);
            return n
        }(t, e, f, n)), t.length > 80 * n) {
            r = o = t[0], i = s = t[1];
            for (var p = n; p < c; p += n) (a = t[p]) < r && (r = a), (u = t[p + 1]) < i && (i = u), a > o && (o = a), u > s && (s = u);
            l = 0 !== (l = Math.max(o - r, s - i)) ? 1 / l : 0
        }
        return Tn(f, g, n, r, i, l), g
    }

    function Cn(t, e, n, r, i) {
        var o, s;
        if (i === Kn(t, e, n, r) > 0) for (o = e; o < n; o += r) s = Wn(o, t[o], t[o + 1], s); else for (o = n - r; o >= e; o -= r) s = Wn(o, t[o], t[o + 1], s);
        return s && Un(s, s.next) && (Jn(s), s = s.next), s
    }

    function Rn(t, e) {
        if (!t) return t;
        e || (e = t);
        var n, r = t;
        do {
            if (n = !1, r.steiner || !Un(r, r.next) && 0 !== jn(r.prev, r, r.next)) r = r.next; else {
                if (Jn(r), (r = e = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== e);
        return e
    }

    function Tn(t, e, n, r, i, o, s) {
        if (t) {
            !s && o && function (t, e, n, r) {
                var i = t;
                do {
                    null === i.z && (i.z = Yn(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                } while (i !== t);
                i.prevZ.nextZ = null, i.prevZ = null, function (t) {
                    var e, n, r, i, o, s, a, u, l = 1;
                    do {
                        for (n = t, t = null, o = null, s = 0; n;) {
                            for (s++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ); e++) ;
                            for (u = l; a > 0 || u > 0 && r;) 0 !== a && (0 === u || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                            n = r
                        }
                        o.nextZ = null, l *= 2
                    } while (s > 1)
                }(i)
            }(t, r, i, o);
            for (var a, u, l = t; t.prev !== t.next;) if (a = t.prev, u = t.next, o ? An(t, r, i, o) : On(t)) e.push(a.i / n), e.push(t.i / n), e.push(u.i / n), Jn(t), t = u.next, l = u.next; else if ((t = u) === l) {
                s ? 1 === s ? Tn(t = Dn(t, e, n), e, n, r, i, o, 2) : 2 === s && Fn(t, e, n, r, i, o) : Tn(Rn(t), e, n, r, i, o, 1);
                break
            }
        }
    }

    function On(t) {
        var e = t.prev, n = t, r = t.next;
        if (jn(e, n, r) >= 0) return !1;
        for (var i = t.next.next; i !== t.prev;) {
            if (zn(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && jn(i.prev, i, i.next) >= 0) return !1;
            i = i.next
        }
        return !0
    }

    function An(t, e, n, r) {
        var i = t.prev, o = t, s = t.next;
        if (jn(i, o, s) >= 0) return !1;
        for (var a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x, u = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y, l = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x, h = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, c = Yn(a, u, e, n, r), f = Yn(l, h, e, n, r), g = t.prevZ, p = t.nextZ; g && g.z >= c && p && p.z <= f;) {
            if (g !== t.prev && g !== t.next && zn(i.x, i.y, o.x, o.y, s.x, s.y, g.x, g.y) && jn(g.prev, g, g.next) >= 0) return !1;
            if (g = g.prevZ, p !== t.prev && p !== t.next && zn(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) && jn(p.prev, p, p.next) >= 0) return !1;
            p = p.nextZ
        }
        for (; g && g.z >= c;) {
            if (g !== t.prev && g !== t.next && zn(i.x, i.y, o.x, o.y, s.x, s.y, g.x, g.y) && jn(g.prev, g, g.next) >= 0) return !1;
            g = g.prevZ
        }
        for (; p && p.z <= f;) {
            if (p !== t.prev && p !== t.next && zn(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) && jn(p.prev, p, p.next) >= 0) return !1;
            p = p.nextZ
        }
        return !0
    }

    function Dn(t, e, n) {
        var r = t;
        do {
            var i = r.prev, o = r.next.next;
            !Un(i, o) && Vn(i, r, r.next, o) && Zn(i, o) && Zn(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Jn(r), Jn(r.next), r = t = o), r = r.next
        } while (r !== t);
        return r
    }

    function Fn(t, e, n, r, i, o) {
        var s = t;
        do {
            for (var a = s.next.next; a !== s.prev;) {
                if (s.i !== a.i && Xn(s, a)) {
                    var u = Hn(s, a);
                    return s = Rn(s, s.next), u = Rn(u, u.next), Tn(s, e, n, r, i, o), void Tn(u, e, n, r, i, o)
                }
                a = a.next
            }
            s = s.next
        } while (s !== t)
    }

    function qn(t, e) {
        return t.x - e.x
    }

    function Gn(t, e) {
        if (e = function (t, e) {
            var n, r = e, i = t.x, o = t.y, s = -1 / 0;
            do {
                if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                    var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                    if (a <= i && a > s) {
                        if (s = a, a === i) {
                            if (o === r.y) return r;
                            if (o === r.next.y) return r.next
                        }
                        n = r.x < r.next.x ? r : r.next
                    }
                }
                r = r.next
            } while (r !== e);
            if (!n) return null;
            if (i === s) return n.prev;
            var u, l = n, h = n.x, c = n.y, f = 1 / 0;
            r = n.next;
            for (; r !== l;) i >= r.x && r.x >= h && i !== r.x && zn(o < c ? i : s, o, h, c, o < c ? s : i, o, r.x, r.y) && ((u = Math.abs(o - r.y) / (i - r.x)) < f || u === f && r.x > n.x) && Zn(r, t) && (n = r, f = u), r = r.next;
            return n
        }(t, e), e) {
            var n = Hn(e, t);
            Rn(n, n.next)
        }
    }

    function Yn(t, e, n, r, i) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function Bn(t) {
        var e = t, n = t;
        do {
            e.x < n.x && (n = e), e = e.next
        } while (e !== t);
        return n
    }

    function zn(t, e, n, r, i, o, s, a) {
        return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0
    }

    function Xn(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
            var n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Vn(n, n.next, t, e)) return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && Zn(t, e) && Zn(e, t) && function (t, e) {
            var n = t, r = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
            } while (n !== t);
            return r
        }(t, e)
    }

    function jn(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }

    function Un(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function Vn(t, e, n, r) {
        return !!(Un(t, e) && Un(n, r) || Un(t, r) && Un(n, e)) || jn(t, e, n) > 0 != jn(t, e, r) > 0 && jn(n, r, t) > 0 != jn(n, r, e) > 0
    }

    function Zn(t, e) {
        return jn(t.prev, t, t.next) < 0 ? jn(t, e, t.next) >= 0 && jn(t, t.prev, e) >= 0 : jn(t, e, t.prev) < 0 || jn(t, t.next, e) < 0
    }

    function Hn(t, e) {
        var n = new Qn(t.i, t.x, t.y), r = new Qn(e.i, e.x, e.y), i = t.next, o = e.prev;
        return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
    }

    function Wn(t, e, n, r) {
        var i = new Qn(t, e, n);
        return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
    }

    function Jn(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function Qn(t, e, n) {
        this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }

    function Kn(t, e, n, r) {
        for (var i = 0, o = e, s = n - r; o < n; o += r) i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
        return i
    }

    function $n(t) {
        var e = function (t) {
            for (var e = t[0][0].length, n = {
                vertices: [],
                holes: [],
                dimensions: e
            }, r = 0, i = 0; i < t.length; i++) {
                for (var o = 0; o < t[i].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);
                i > 0 && (r += t[i - 1].length, n.holes.push(r))
            }
            return n
        }(t), n = Mn(e.vertices, e.holes, 2), r = [], i = [];
        n.forEach((function (t, r) {
            var o = n[r];
            i.push([e.vertices[2 * o], e.vertices[2 * o + 1]])
        }));
        for (var o = 0; o < i.length; o += 3) {
            var s = i.slice(o, o + 3);
            s.push(i[o]), r.push(m([s]))
        }
        return r
    }

    function tr(t, e) {
        if (!t) throw new Error("targetPoint is required");
        if (!e) throw new Error("points is required");
        var n = 1 / 0, r = 0;
        U(e, (function (e, i) {
            var o = xe(t, e);
            o < n && (r = i, n = o)
        }));
        var i = Ie(e.features[r]);
        return Object.assign(Object.assign({}, i), {
            properties: Object.assign(Object.assign({}, i.properties), {
                featureIndex: r,
                distanceToPoint: n
            })
        })
    }

    Ln.deviation = function (t, e, n, r) {
        var i = e && e.length, o = i ? e[0] * n : t.length, s = Math.abs(Kn(t, 0, o, n));
        if (i) for (var a = 0, u = e.length; a < u; a++) {
            var l = e[a] * n, h = a < u - 1 ? e[a + 1] * n : t.length;
            s -= Math.abs(Kn(t, l, h, n))
        }
        var c = 0;
        for (a = 0; a < r.length; a += 3) {
            var f = r[a] * n, g = r[a + 1] * n, p = r[a + 2] * n;
            c += Math.abs((t[f] - t[p]) * (t[g + 1] - t[f + 1]) - (t[f] - t[g]) * (t[p + 1] - t[f + 1]))
        }
        return 0 === s && 0 === c ? 0 : Math.abs((c - s) / s)
    }, Ln.flatten = function (t) {
        for (var e = t[0][0].length, n = {vertices: [], holes: [], dimensions: e}, r = 0, i = 0; i < t.length; i++) {
            for (var o = 0; o < t[i].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);
            i > 0 && (r += t[i - 1].length, n.holes.push(r))
        }
        return n
    }, Mn.default = Pn;
    var er = function () {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : nr;
            if (n(this, t), this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i)
        }

        return i(t, [{
            key: "push", value: function (t) {
                this.data.push(t), this.length++, this._up(this.length - 1)
            }
        }, {
            key: "pop", value: function () {
                if (0 !== this.length) {
                    var t = this.data[0], e = this.data.pop();
                    return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t
                }
            }
        }, {
            key: "peek", value: function () {
                return this.data[0]
            }
        }, {
            key: "_up", value: function (t) {
                for (var e = this.data, n = this.compare, r = e[t]; t > 0;) {
                    var i = t - 1 >> 1, o = e[i];
                    if (n(r, o) >= 0) break;
                    e[t] = o, t = i
                }
                e[t] = r
            }
        }, {
            key: "_down", value: function (t) {
                for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) {
                    var o = 1 + (t << 1), s = e[o], a = o + 1;
                    if (a < this.length && n(e[a], s) < 0 && (o = a, s = e[a]), n(s, i) >= 0) break;
                    e[t] = s, t = o
                }
                e[t] = i
            }
        }]), t
    }();

    function nr(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    function rr(t, e) {
        return t.p.x > e.p.x ? 1 : t.p.x < e.p.x ? -1 : t.p.y !== e.p.y ? t.p.y > e.p.y ? 1 : -1 : 1
    }

    function ir(t, e) {
        return t.rightSweepEvent.p.x > e.rightSweepEvent.p.x ? 1 : t.rightSweepEvent.p.x < e.rightSweepEvent.p.x ? -1 : t.rightSweepEvent.p.y !== e.rightSweepEvent.p.y ? t.rightSweepEvent.p.y < e.rightSweepEvent.p.y ? 1 : -1 : 1
    }

    var or = function () {
        function t(e, r, i, o) {
            n(this, t), this.p = {
                x: e[0],
                y: e[1]
            }, this.featureId = r, this.ringId = i, this.eventId = o, this.otherEvent = null, this.isLeftEndpoint = null
        }

        return i(t, [{
            key: "isSamePoint", value: function (t) {
                return this.p.x === t.p.x && this.p.y === t.p.y
            }
        }]), t
    }();
    var sr = 0, ar = 0, ur = 0;

    function lr(t, e) {
        var n = "Feature" === t.type ? t.geometry : t, r = n.coordinates;
        "Polygon" !== n.type && "MultiLineString" !== n.type || (r = [r]), "LineString" === n.type && (r = [[r]]);
        for (var i = 0; i < r.length; i++) for (var o = 0; o < r[i].length; o++) {
            var s = r[i][o][0], a = null;
            ar += 1;
            for (var u = 0; u < r[i][o].length - 1; u++) {
                a = r[i][o][u + 1];
                var l = new or(s, sr, ar, ur), h = new or(a, sr, ar, ur + 1);
                l.otherEvent = h, h.otherEvent = l, rr(l, h) > 0 ? (h.isLeftEndpoint = !0, l.isLeftEndpoint = !1) : (l.isLeftEndpoint = !0, h.isLeftEndpoint = !1), e.push(l), e.push(h), s = a, ur += 1
            }
        }
        sr += 1
    }

    var hr = i((function t(e) {
        n(this, t), this.leftSweepEvent = e, this.rightSweepEvent = e.otherEvent
    }));

    function cr(t, e) {
        if (null === t || null === e) return !1;
        if (t.leftSweepEvent.ringId === e.leftSweepEvent.ringId && (t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.rightSweepEvent) || t.leftSweepEvent.isSamePoint(e.leftSweepEvent) || t.leftSweepEvent.isSamePoint(e.rightSweepEvent))) return !1;
        var n = t.leftSweepEvent.p.x, r = t.leftSweepEvent.p.y, i = t.rightSweepEvent.p.x, o = t.rightSweepEvent.p.y,
            s = e.leftSweepEvent.p.x, a = e.leftSweepEvent.p.y, u = e.rightSweepEvent.p.x, l = e.rightSweepEvent.p.y,
            h = (l - a) * (i - n) - (u - s) * (o - r), c = (u - s) * (r - a) - (l - a) * (n - s),
            f = (i - n) * (r - a) - (o - r) * (n - s);
        if (0 === h) return !1;
        var g = c / h, p = f / h;
        return g >= 0 && g <= 1 && p >= 0 && p <= 1 && [n + g * (i - n), r + g * (o - r)]
    }

    function fr(t, e) {
        var n = new er([], rr);
        return function (t, e) {
            if ("FeatureCollection" === t.type) for (var n = t.features, r = 0; r < n.length; r++) lr(n[r], e); else lr(t, e)
        }(t, n), function (t, e) {
            e = e || !1;
            for (var n = [], r = new er([], ir); t.length;) {
                var i = t.pop();
                if (i.isLeftEndpoint) {
                    for (var o = new hr(i), s = 0; s < r.data.length; s++) {
                        var a = r.data[s];
                        if (!e || a.leftSweepEvent.featureId !== i.featureId) {
                            var u = cr(o, a);
                            !1 !== u && n.push(u)
                        }
                    }
                    r.push(o)
                } else !1 === i.isLeftEndpoint && r.pop()
            }
            return n
        }(n, e)
    }

    function gr(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.removeDuplicates,
            i = void 0 === r || r, o = n.ignoreSelfIntersections, s = void 0 !== o && o, a = [];
        "FeatureCollection" === t.type ? a = a.concat(t.features) : "Feature" === t.type ? a.push(t) : "LineString" !== t.type && "Polygon" !== t.type && "MultiLineString" !== t.type && "MultiPolygon" !== t.type || a.push(p(t)), "FeatureCollection" === e.type ? a = a.concat(e.features) : "Feature" === e.type ? a.push(e) : "LineString" !== e.type && "Polygon" !== e.type && "MultiLineString" !== e.type && "MultiPolygon" !== e.type || a.push(p(e));
        var u = fr(k(a), s), l = [];
        if (i) {
            var h = {};
            u.forEach((function (t) {
                var e = t.join(",");
                h[e] || (h[e] = !0, l.push(t))
            }))
        } else l = u;
        return k(l.map((function (t) {
            return d(t)
        })))
    }

    function pr(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!t || !e) throw new Error("lines and pt are required arguments");
        var r = d([1 / 0, 1 / 0], {dist: 1 / 0, index: -1, location: -1}), i = 0;
        return J(t, (function (t) {
            for (var o = at(t), s = 0; s < o.length - 1; s++) {
                var a = d(o[s]);
                a.properties.dist = xe(e, a, n);
                var u = d(o[s + 1]);
                u.properties.dist = xe(e, u, n);
                var l = xe(a, u, n), h = Math.max(a.properties.dist, u.properties.dist), c = wn(a, u),
                    f = En(e, h, c + 90, n), g = En(e, h, c - 90, n),
                    p = gr(x([f.geometry.coordinates, g.geometry.coordinates]), x([a.geometry.coordinates, u.geometry.coordinates])),
                    v = void 0;
                p.features.length > 0 && p.features[0] && (v = Object.assign(Object.assign({}, p.features[0]), {
                    properties: {
                        dist: xe(e, p.features[0], n),
                        location: i + xe(a, p.features[0], n)
                    }
                })), a.properties.dist < r.properties.dist && (r = Object.assign(Object.assign({}, a), {
                    properties: Object.assign(Object.assign({}, a.properties), {
                        index: s,
                        location: i
                    })
                })), u.properties.dist < r.properties.dist && (r = Object.assign(Object.assign({}, u), {
                    properties: Object.assign(Object.assign({}, u.properties), {
                        index: s + 1,
                        location: i + l
                    })
                })), v && v.properties.dist < r.properties.dist && (r = Object.assign(Object.assign({}, v), {properties: Object.assign(Object.assign({}, v.properties), {index: s})})), i += l
            }
        })), r
    }

    function vr(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = st(t), i = st(e);
        i[0] += i[0] - r[0] > 180 ? -360 : r[0] - i[0] > 180 ? 360 : 0;
        var o = dr(r, i), s = O(o, "meters", n.units);
        return s
    }

    function dr(t, e, n) {
        var r = n = void 0 === n ? c : Number(n), i = t[1] * Math.PI / 180, o = e[1] * Math.PI / 180, s = o - i,
            a = Math.abs(e[0] - t[0]) * Math.PI / 180;
        a > Math.PI && (a -= 2 * Math.PI);
        var u = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)),
            l = Math.abs(u) > 1e-11 ? s / u : Math.cos(i);
        return Math.sqrt(s * s + l * l * a * a) * r
    }

    function yr(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (n.method || (n.method = "geodesic"), n.units || (n.units = "kilometers"), !t) throw new Error("pt is required");
        if (Array.isArray(t) ? t = d(t) : "Point" === t.type ? t = p(t) : ht(t, "Point", "point"), !e) throw new Error("line is required");
        Array.isArray(e) ? e = x(e) : "LineString" === e.type ? e = p(e) : ht(e, "LineString", "line");
        var r = 1 / 0, i = t.geometry.coordinates;
        return K(e, (function (t) {
            var e = t.geometry.coordinates[0], o = t.geometry.coordinates[1], s = mr(i, e, o, n);
            s < r && (r = s)
        })), O(r, "degrees", n.units)
    }

    function mr(t, e, n, r) {
        var i = [n[0] - e[0], n[1] - e[1]], o = _r([t[0] - e[0], t[1] - e[1]], i);
        if (o <= 0) return xr(t, e, {method: r.method, units: "degrees"});
        var s = _r(i, i);
        if (s <= o) return xr(t, n, {method: r.method, units: "degrees"});
        var a = o / s;
        return xr(t, [e[0] + a * i[0], e[1] + a * i[1]], {method: r.method, units: "degrees"})
    }

    function _r(t, e) {
        return t[0] * e[0] + t[1] * e[1]
    }

    function xr(t, e, n) {
        return "planar" === n.method ? vr(t, e, n) : xe(t, e, n)
    }

    function Er(t) {
        var e = [];
        switch (t.geometry ? t.geometry.type : t.type) {
            case"GeometryCollection":
                return H(t, (function (t) {
                    "Point" === t.type && e.push({type: "Feature", properties: {}, geometry: t})
                })), {type: "FeatureCollection", features: e};
            case"FeatureCollection":
                return t.features = t.features.filter((function (t) {
                    return "Point" === t.geometry.type
                })), t;
            default:
                throw new Error("points must be a Point Collection")
        }
    }

    var kr = function () {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : wr;
            if (n(this, t), this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i)
        }

        return i(t, [{
            key: "push", value: function (t) {
                this.data.push(t), this.length++, this._up(this.length - 1)
            }
        }, {
            key: "pop", value: function () {
                if (0 !== this.length) {
                    var t = this.data[0], e = this.data.pop();
                    return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t
                }
            }
        }, {
            key: "peek", value: function () {
                return this.data[0]
            }
        }, {
            key: "_up", value: function (t) {
                for (var e = this.data, n = this.compare, r = e[t]; t > 0;) {
                    var i = t - 1 >> 1, o = e[i];
                    if (n(r, o) >= 0) break;
                    e[t] = o, t = i
                }
                e[t] = r
            }
        }, {
            key: "_down", value: function (t) {
                for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) {
                    var o = 1 + (t << 1), s = e[o], a = o + 1;
                    if (a < this.length && n(e[a], s) < 0 && (o = a, s = e[a]), n(s, i) >= 0) break;
                    e[t] = s, t = o
                }
                e[t] = i
            }
        }]), t
    }();

    function wr(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    function br(t, e) {
        return t.p.x > e.p.x ? 1 : t.p.x < e.p.x ? -1 : t.p.y !== e.p.y ? t.p.y > e.p.y ? 1 : -1 : 1
    }

    function Ir(t, e) {
        return t.rightSweepEvent.p.x > e.rightSweepEvent.p.x ? 1 : t.rightSweepEvent.p.x < e.rightSweepEvent.p.x ? -1 : t.rightSweepEvent.p.y !== e.rightSweepEvent.p.y ? t.rightSweepEvent.p.y < e.rightSweepEvent.p.y ? 1 : -1 : 1
    }

    var Sr = function () {
        function t(e, r, i, o) {
            n(this, t), this.p = {
                x: e[0],
                y: e[1]
            }, this.featureId = r, this.ringId = i, this.eventId = o, this.otherEvent = null, this.isLeftEndpoint = null
        }

        return i(t, [{
            key: "isSamePoint", value: function (t) {
                return this.p.x === t.p.x && this.p.y === t.p.y
            }
        }]), t
    }();
    var Nr = 0, Mr = 0, Pr = 0;

    function Lr(t, e) {
        var n = "Feature" === t.type ? t.geometry : t, r = n.coordinates;
        "Polygon" !== n.type && "MultiLineString" !== n.type || (r = [r]), "LineString" === n.type && (r = [[r]]);
        for (var i = 0; i < r.length; i++) for (var o = 0; o < r[i].length; o++) {
            var s = r[i][o][0], a = null;
            Mr += 1;
            for (var u = 0; u < r[i][o].length - 1; u++) {
                a = r[i][o][u + 1];
                var l = new Sr(s, Nr, Mr, Pr), h = new Sr(a, Nr, Mr, Pr + 1);
                l.otherEvent = h, h.otherEvent = l, br(l, h) > 0 ? (h.isLeftEndpoint = !0, l.isLeftEndpoint = !1) : (l.isLeftEndpoint = !0, h.isLeftEndpoint = !1), e.push(l), e.push(h), s = a, Pr += 1
            }
        }
        Nr += 1
    }

    var Cr = i((function t(e) {
        n(this, t), this.leftSweepEvent = e, this.rightSweepEvent = e.otherEvent
    }));

    function Rr(t, e) {
        if (null === t || null === e) return !1;
        if (t.leftSweepEvent.ringId === e.leftSweepEvent.ringId && (t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.rightSweepEvent) || t.leftSweepEvent.isSamePoint(e.leftSweepEvent) || t.leftSweepEvent.isSamePoint(e.rightSweepEvent))) return !1;
        var n = t.leftSweepEvent.p.x, r = t.leftSweepEvent.p.y, i = t.rightSweepEvent.p.x, o = t.rightSweepEvent.p.y,
            s = e.leftSweepEvent.p.x, a = e.leftSweepEvent.p.y, u = e.rightSweepEvent.p.x, l = e.rightSweepEvent.p.y,
            h = (l - a) * (i - n) - (u - s) * (o - r), c = (u - s) * (r - a) - (l - a) * (n - s),
            f = (i - n) * (r - a) - (o - r) * (n - s);
        if (0 === h) return !1;
        var g = c / h, p = f / h;
        return g >= 0 && g <= 1 && p >= 0 && p <= 1 && [n + g * (i - n), r + g * (o - r)]
    }

    function Tr(t, e) {
        var n = new kr([], br);
        return function (t, e) {
            if ("FeatureCollection" === t.type) for (var n = t.features, r = 0; r < n.length; r++) Lr(n[r], e); else Lr(t, e)
        }(t, n), function (t, e) {
            e = e || !1;
            for (var n = [], r = new kr([], Ir); t.length;) {
                var i = t.pop();
                if (i.isLeftEndpoint) {
                    for (var o = new Cr(i), s = 0; s < r.data.length; s++) {
                        var a = r.data[s];
                        if (!e || a.leftSweepEvent.featureId !== i.featureId) {
                            var u = Rr(o, a);
                            !1 !== u && n.push(u)
                        }
                    }
                    r.push(o)
                } else !1 === i.isLeftEndpoint && r.pop()
            }
            return n
        }(n, e)
    }

    function Or(t, e, n, r, i, o) {
        return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e))
    }

    function Ar(t) {
        return W(t, (function (t, e) {
            return t + function (t) {
                var e, n = 0;
                switch (t.type) {
                    case"Polygon":
                        return Dr(t.coordinates);
                    case"MultiPolygon":
                        for (e = 0; e < t.coordinates.length; e++) n += Dr(t.coordinates[e]);
                        return n;
                    case"Point":
                    case"MultiPoint":
                    case"LineString":
                    case"MultiLineString":
                        return 0
                }
                return 0
            }(e)
        }), 0)
    }

    function Dr(t) {
        var e = 0;
        if (t && t.length > 0) {
            e += Math.abs(Fr(t[0]));
            for (var n = 1; n < t.length; n++) e -= Math.abs(Fr(t[n]))
        }
        return e
    }

    function Fr(t) {
        var e, n, r, i, o, s, a = 0, u = t.length;
        if (u > 2) {
            for (s = 0; s < u; s++) s === u - 2 ? (r = u - 2, i = u - 1, o = 0) : s === u - 1 ? (r = u - 1, i = 0, o = 1) : (r = s, i = s + 1, o = s + 2), e = t[r], n = t[i], a += (qr(t[o][0]) - qr(e[0])) * Math.sin(qr(n[1]));
            a = a * c * c / 2
        }
        return a
    }

    function qr(t) {
        return t * Math.PI / 180
    }

    function Gr(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return $(t, (function (t, n) {
            var r = n.geometry.coordinates;
            return t + xe(r[0], r[1], e)
        }), 0)
    }

    function Yr(t, e, n, r) {
        if (!F(r = r || {})) throw new Error("options is invalid");
        var i, o = [];
        if ("Feature" === t.type) i = t.geometry.coordinates; else {
            if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
            i = t.coordinates
        }
        for (var s, a, u, l = i.length, h = 0, c = 0; c < i.length && !(e >= h && c === i.length - 1); c++) {
            if (h > e && 0 === o.length) {
                if (!(s = e - h)) return o.push(i[c]), x(o);
                a = wn(i[c], i[c - 1]) - 180, u = En(i[c], s, a, r), o.push(u.geometry.coordinates)
            }
            if (h >= n) return (s = n - h) ? (a = wn(i[c], i[c - 1]) - 180, u = En(i[c], s, a, r), o.push(u.geometry.coordinates), x(o)) : (o.push(i[c]), x(o));
            if (h >= e && o.push(i[c]), c === i.length - 1) return x(o);
            h += xe(i[c], i[c + 1], r)
        }
        if (h < e && i.length === l) throw new Error("Start position is beyond line");
        var f = i[i.length - 1];
        return x([f, f])
    }

    function Br(t, e) {
        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = st(t), i = at(e), o = 0; o < i.length - 1; o++) {
            var s = !1;
            if (n.ignoreEndVertices && (0 === o && (s = "start"), o === i.length - 2 && (s = "end"), 0 === o && o + 1 === i.length - 1 && (s = "both")), zr(i[o], i[o + 1], r, s, void 0 === n.epsilon ? null : n.epsilon)) return !0
        }
        return !1
    }

    function zr(t, e, n, r, i) {
        var o = n[0], s = n[1], a = t[0], u = t[1], l = e[0], h = e[1], c = l - a, f = h - u,
            g = (n[0] - a) * f - (n[1] - u) * c;
        if (null !== i) {
            if (Math.abs(g) > i) return !1
        } else if (0 !== g) return !1;
        return r ? "start" === r ? Math.abs(c) >= Math.abs(f) ? c > 0 ? a < o && o <= l : l <= o && o < a : f > 0 ? u < s && s <= h : h <= s && s < u : "end" === r ? Math.abs(c) >= Math.abs(f) ? c > 0 ? a <= o && o < l : l < o && o <= a : f > 0 ? u <= s && s < h : h < s && s <= u : "both" === r && (Math.abs(c) >= Math.abs(f) ? c > 0 ? a < o && o < l : l < o && o < a : f > 0 ? u < s && s < h : h < s && s < u) : Math.abs(c) >= Math.abs(f) ? c > 0 ? a <= o && o <= l : l <= o && o <= a : f > 0 ? u <= s && s <= h : h <= s && s <= u
    }

    function Xr(t, e) {
        var n = ft(t), r = ft(e), i = n.type, o = r.type;
        switch (i) {
            case"Point":
                switch (o) {
                    case"MultiPoint":
                        return function (t, e) {
                            var n, r = !1;
                            for (n = 0; n < e.coordinates.length; n++) if (Ur(e.coordinates[n], t.coordinates)) {
                                r = !0;
                                break
                            }
                            return r
                        }(n, r);
                    case"LineString":
                        return Br(n, r, {ignoreEndVertices: !0});
                    case"Polygon":
                    case"MultiPolygon":
                        return ye(n, r, {ignoreBoundary: !0});
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"MultiPoint":
                switch (o) {
                    case"MultiPoint":
                        return function (t, e) {
                            for (var n = 0; n < t.coordinates.length; n++) {
                                for (var r = !1, i = 0; i < e.coordinates.length; i++) Ur(t.coordinates[n], e.coordinates[i]) && (r = !0);
                                if (!r) return !1
                            }
                            return !0
                        }(n, r);
                    case"LineString":
                        return function (t, e) {
                            for (var n = !1, r = 0; r < t.coordinates.length; r++) {
                                if (!Br(t.coordinates[r], e)) return !1;
                                n || (n = Br(t.coordinates[r], e, {ignoreEndVertices: !0}))
                            }
                            return n
                        }(n, r);
                    case"Polygon":
                    case"MultiPolygon":
                        return function (t, e) {
                            for (var n = !0, r = !1, i = 0; i < t.coordinates.length; i++) {
                                if (!(r = ye(t.coordinates[i], e))) {
                                    n = !1;
                                    break
                                }
                                r = ye(t.coordinates[i], e, {ignoreBoundary: !0})
                            }
                            return n && r
                        }(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"LineString":
                switch (o) {
                    case"LineString":
                        return function (t, e) {
                            for (var n = 0; n < t.coordinates.length; n++) if (!Br(t.coordinates[n], e)) return !1;
                            return !0
                        }(n, r);
                    case"Polygon":
                    case"MultiPolygon":
                        return function (t, e) {
                            var n = ot(e), r = ot(t);
                            if (!jr(n, r)) return !1;
                            for (var i = !1, o = 0; o < t.coordinates.length - 1; o++) {
                                if (!ye(t.coordinates[o], e)) return !1;
                                if (i || (i = ye(t.coordinates[o], e, {ignoreBoundary: !0})), !i) i = ye(Vr(t.coordinates[o], t.coordinates[o + 1]), e, {ignoreBoundary: !0})
                            }
                            return i
                        }(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"Polygon":
                switch (o) {
                    case"Polygon":
                    case"MultiPolygon":
                        return function (t, e) {
                            var n = ot(t);
                            if (!jr(ot(e), n)) return !1;
                            for (var r = 0; r < t.coordinates[0].length; r++) if (!ye(t.coordinates[0][r], e)) return !1;
                            return !0
                        }(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + i + " geometry not supported")
        }
    }

    function jr(t, e) {
        return !(t[0] > e[0]) && (!(t[2] < e[2]) && (!(t[1] > e[1]) && !(t[3] < e[3])))
    }

    function Ur(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function Vr(t, e) {
        return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2]
    }

    function Zr(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        n.mask && !n.units && (n.units = "kilometers");
        for (var r = [], i = t[0], o = t[1], s = t[2], a = t[3], u = e / xe([i, o], [s, o], n), l = u * (s - i), h = e / xe([i, o], [i, a], n), c = h * (a - o), f = s - i, g = a - o, p = Math.floor(f / l), v = Math.floor(g / c), y = (f - p * l) / 2, m = (g - v * c) / 2, _ = i + y; _ <= s;) {
            for (var x = o + m; x <= a;) {
                var E = d([_, x], n.properties);
                n.mask ? Xr(E, n.mask) && r.push(E) : r.push(E), x += c
            }
            _ += l
        }
        return k(r)
    }

    function Hr(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.precision, r = e.coordinates,
            i = e.mutate;
        if (n = null == n || isNaN(n) ? 6 : n, r = null == r || isNaN(r) ? 3 : r, !t) throw new Error("<geojson> is required");
        if ("number" != typeof n) throw new Error("<precision> must be a number");
        if ("number" != typeof r) throw new Error("<coordinates> must be a number");
        !1 !== i && void 0 !== i || (t = JSON.parse(JSON.stringify(t)));
        var o = Math.pow(10, n);
        return B(t, (function (t) {
            Wr(t, o, r)
        })), t
    }

    function Wr(t, e, n) {
        t.length > n && t.splice(n, t.length);
        for (var r = 0; r < t.length; r++) t[r] = Math.round(t[r] * e) / e;
        return t
    }

    function Jr(t) {
        if (!t) throw new Error("geojson is required");
        var e = [];
        return J(t, (function (t) {
            e.push(t)
        })), k(e)
    }

    function Qr(t, e, n) {
        if ("Polygon" !== t.geometry.type) throw new Error("The input feature must be a Polygon");
        void 0 === n && (n = 1);
        var r = t.geometry.coordinates, i = [], o = {};
        if (n) {
            for (var s = [], a = 0; a < r.length; a++) for (var u = 0; u < r[a].length - 1; u++) s.push(v(a, u));
            var l = new Nt;
            l.load(s)
        }
        for (var h = 0; h < r.length; h++) for (var c = 0; c < r[h].length - 1; c++) {
            if (n) l.search(v(h, c)).forEach((function (t) {
                var e = t.ring, n = t.edge;
                p(h, c, e, n)
            })); else for (var f = 0; f < r.length; f++) for (var g = 0; g < r[f].length - 1; g++) p(h, c, f, g)
        }
        return e || (i = {type: "Feature", geometry: {type: "MultiPoint", coordinates: i}}), i;

        function p(t, n, s, a) {
            var u, l, h = r[t][n], c = r[t][n + 1], f = r[s][a], g = r[s][a + 1], p = function (t, e, n, r) {
                if (Kr(t, n) || Kr(t, r) || Kr(e, n) || Kr(r, n)) return null;
                var i = t[0], o = t[1], s = e[0], a = e[1], u = n[0], l = n[1], h = r[0], c = r[1],
                    f = (i - s) * (l - c) - (o - a) * (u - h);
                return 0 === f ? null : [((i * a - o * s) * (u - h) - (i - s) * (u * c - l * h)) / f, ((i * a - o * s) * (l - c) - (o - a) * (u * c - l * h)) / f]
            }(h, c, f, g);
            if (null !== p && (u = c[0] !== h[0] ? (p[0] - h[0]) / (c[0] - h[0]) : (p[1] - h[1]) / (c[1] - h[1]), l = g[0] !== f[0] ? (p[0] - f[0]) / (g[0] - f[0]) : (p[1] - f[1]) / (g[1] - f[1]), !(u >= 1 || u <= 0 || l >= 1 || l <= 0))) {
                var v = p, d = !o[v];
                d && (o[v] = !0), e ? i.push(e(p, t, n, h, c, u, s, a, f, g, l, d)) : i.push(p)
            }
        }

        function v(t, e) {
            var n, i, o, s, a = r[t][e], u = r[t][e + 1];
            return a[0] < u[0] ? (n = a[0], i = u[0]) : (n = u[0], i = a[0]), a[1] < u[1] ? (o = a[1], s = u[1]) : (o = u[1], s = a[1]), {
                minX: n,
                minY: o,
                maxX: i,
                maxY: s,
                ring: t,
                edge: e
            }
        }
    }

    function Kr(t, e) {
        if (!t || !e) return !1;
        if (t.length !== e.length) return !1;
        for (var n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) {
            if (!Kr(t[n], e[n])) return !1
        } else if (t[n] !== e[n]) return !1;
        return !0
    }

    function $r(t) {
        if ("Feature" != t.type) throw new Error("The input must a geojson object of type Feature");
        if (void 0 === t.geometry || null == t.geometry) throw new Error("The input must a geojson object with a non-empty geometry");
        if ("Polygon" != t.geometry.type) throw new Error("The input must be a geojson Polygon");
        for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) {
            var i = t.geometry.coordinates[r];
            ii(i[0], i[i.length - 1]) || i.push(i[0]), n.push.apply(n, i.slice(0, i.length - 1))
        }
        if (!function (t) {
            for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) {
                if (Object.prototype.hasOwnProperty.call(e, t[r])) {
                    n = 0;
                    break
                }
                e[t[r]] = 1
            }
            return n
        }(n)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
        var o = n.length, s = Qr(t, (function (t, e, n, r, i, o, s, a, u, l, h, c) {
            return [t, e, n, r, i, o, s, a, u, l, h, c]
        })), a = s.length;
        if (0 == a) {
            var u = [];
            for (r = 0; r < e; r++) u.push(m([t.geometry.coordinates[r]], {
                parent: -1,
                winding: ri(t.geometry.coordinates[r])
            }));
            var l = k(u);
            return q(), G(), l
        }
        var h = [], c = [];
        for (r = 0; r < e; r++) {
            h.push([]);
            for (var f = 0; f < t.geometry.coordinates[r].length - 1; f++) h[r].push([new ti(t.geometry.coordinates[r][oi(f + 1, t.geometry.coordinates[r].length - 1)], 1, [r, f], [r, oi(f + 1, t.geometry.coordinates[r].length - 1)], void 0)]), c.push(new ei(t.geometry.coordinates[r][f], [r, oi(f - 1, t.geometry.coordinates[r].length - 1)], [r, f], void 0, void 0, !1, !0))
        }
        for (r = 0; r < a; r++) h[s[r][1]][s[r][2]].push(new ti(s[r][0], s[r][5], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0)), s[r][11] && c.push(new ei(s[r][0], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0, void 0, !0, !0));
        var g = c.length;
        for (r = 0; r < h.length; r++) for (f = 0; f < h[r].length; f++) h[r][f].sort((function (t, e) {
            return t.param < e.param ? -1 : 1
        }));
        var p = [];
        for (r = 0; r < g; r++) p.push({
            minX: c[r].coord[0],
            minY: c[r].coord[1],
            maxX: c[r].coord[0],
            maxY: c[r].coord[1],
            index: r
        });
        var v = new Nt;
        v.load(p);
        for (r = 0; r < h.length; r++) for (f = 0; f < h[r].length; f++) for (var d = 0; d < h[r][f].length; d++) {
            _ = d == h[r][f].length - 1 ? h[r][oi(f + 1, t.geometry.coordinates[r].length - 1)][0].coord : h[r][f][d + 1].coord;
            var y = v.search({minX: _[0], minY: _[1], maxX: _[0], maxY: _[1]})[0];
            h[r][f][d].nxtIsectAlongEdgeIn = y.index
        }
        for (r = 0; r < h.length; r++) for (f = 0; f < h[r].length; f++) for (d = 0; d < h[r][f].length; d++) {
            var _ = h[r][f][d].coord, x = (y = v.search({minX: _[0], minY: _[1], maxX: _[0], maxY: _[1]})[0]).index;
            x < o ? c[x].nxtIsectAlongRingAndEdge2 = h[r][f][d].nxtIsectAlongEdgeIn : ii(c[x].ringAndEdge1, h[r][f][d].ringAndEdgeIn) ? c[x].nxtIsectAlongRingAndEdge1 = h[r][f][d].nxtIsectAlongEdgeIn : c[x].nxtIsectAlongRingAndEdge2 = h[r][f][d].nxtIsectAlongEdgeIn
        }
        var E = [];
        for (r = 0, f = 0; f < e; f++) {
            var w = r;
            for (d = 0; d < t.geometry.coordinates[f].length - 1; d++) c[r].coord[0] < c[w].coord[0] && (w = r), r++;
            var b = c[w].nxtIsectAlongRingAndEdge2;
            for (d = 0; d < c.length; d++) if (c[d].nxtIsectAlongRingAndEdge1 == w || c[d].nxtIsectAlongRingAndEdge2 == w) {
                var I = d;
                break
            }
            var S = ni([c[I].coord, c[w].coord, c[b].coord], !0) ? 1 : -1;
            E.push({isect: w, parent: -1, winding: S})
        }
        E.sort((function (t, e) {
            return c[t.isect].coord > c[e.isect].coord ? -1 : 1
        }));
        for (u = []; E.length > 0;) {
            var N = E.pop(), M = N.isect, P = N.parent, L = N.winding, C = u.length, R = [c[M].coord], T = M;
            if (c[M].ringAndEdge1Walkable) var O = c[M].ringAndEdge1,
                A = c[M].nxtIsectAlongRingAndEdge1; else O = c[M].ringAndEdge2, A = c[M].nxtIsectAlongRingAndEdge2;
            for (; !ii(c[M].coord, c[A].coord);) {
                R.push(c[A].coord);
                var D = void 0;
                for (r = 0; r < E.length; r++) if (E[r].isect == A) {
                    D = r;
                    break
                }
                if (null != D && E.splice(D, 1), ii(O, c[A].ringAndEdge1)) {
                    if (O = c[A].ringAndEdge2, c[A].ringAndEdge2Walkable = !1, c[A].ringAndEdge1Walkable) {
                        var F = {isect: A};
                        ni([c[T].coord, c[A].coord, c[c[A].nxtIsectAlongRingAndEdge2].coord], 1 == L) ? (F.parent = P, F.winding = -L) : (F.parent = C, F.winding = L), E.push(F)
                    }
                    T = A, A = c[A].nxtIsectAlongRingAndEdge2
                } else {
                    if (O = c[A].ringAndEdge1, c[A].ringAndEdge1Walkable = !1, c[A].ringAndEdge2Walkable) {
                        F = {isect: A};
                        ni([c[T].coord, c[A].coord, c[c[A].nxtIsectAlongRingAndEdge1].coord], 1 == L) ? (F.parent = P, F.winding = -L) : (F.parent = C, F.winding = L), E.push(F)
                    }
                    T = A, A = c[A].nxtIsectAlongRingAndEdge1
                }
            }
            R.push(c[A].coord), u.push(m([R], {index: C, parent: P, winding: L, netWinding: void 0}))
        }
        l = k(u);

        function q() {
            for (var t = [], e = 0; e < l.features.length; e++) -1 == l.features[e].properties.parent && t.push(e);
            if (t.length > 1) for (e = 0; e < t.length; e++) {
                for (var n = -1, r = 0; r < l.features.length; r++) t[e] != r && ye(l.features[t[e]].geometry.coordinates[0][0], l.features[r], {ignoreBoundary: !0}) && Ar(l.features[r]) < Infinity && (n = r);
                l.features[t[e]].properties.parent = n
            }
        }

        function G() {
            for (var t = 0; t < l.features.length; t++) if (-1 == l.features[t].properties.parent) {
                var e = l.features[t].properties.winding;
                l.features[t].properties.netWinding = e, Y(t, e)
            }
        }

        function Y(t, e) {
            for (var n = 0; n < l.features.length; n++) if (l.features[n].properties.parent == t) {
                var r = e + l.features[n].properties.winding;
                l.features[n].properties.netWinding = r, Y(n, r)
            }
        }

        return q(), G(), l
    }

    var ti = function (t, e, n, r, i) {
        this.coord = t, this.param = e, this.ringAndEdgeIn = n, this.ringAndEdgeOut = r, this.nxtIsectAlongEdgeIn = i
    }, ei = function (t, e, n, r, i, o, s) {
        this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = n, this.nxtIsectAlongRingAndEdge1 = r, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = o, this.ringAndEdge2Walkable = s
    };

    function ni(t, e) {
        if (void 0 === e && (e = !0), 3 != t.length) throw new Error("This function requires an array of three points [x,y]");
        return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e
    }

    function ri(t) {
        for (var e = 0, n = 0; n < t.length - 1; n++) t[n][0] < t[e][0] && (e = n);
        if (ni([t[oi(e - 1, t.length - 1)], t[e], t[oi(e + 1, t.length - 1)]], !0)) var r = 1; else r = -1;
        return r
    }

    function ii(t, e) {
        if (!t || !e) return !1;
        if (t.length != e.length) return !1;
        for (var n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) {
            if (!ii(t[n], e[n])) return !1
        } else if (t[n] != e[n]) return !1;
        return !0
    }

    function oi(t, e) {
        return (t % e + e) % e
    }

    /*!
       * Copyright (c) 2019, Dane Springmeyer
       *
       * Redistribution and use in source and binary forms, with or without
       * modification, are permitted provided that the following conditions are
       * met:
       *
       *     * Redistributions of source code must retain the above copyright
       *       notice, this list of conditions and the following disclaimer.
       *     * Redistributions in binary form must reproduce the above copyright
       *       notice, this list of conditions and the following disclaimer in
       *       the documentation and/or other materials provided with the
       *       distribution.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
       * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
       * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
       * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
       * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
       * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
       * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
       * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
       * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
       * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
       * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       */
    var si = Math.PI / 180, ai = 180 / Math.PI, ui = function (t, e) {
        this.lon = t, this.lat = e, this.x = si * t, this.y = si * e
    };
    ui.prototype.view = function () {
        return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4)
    }, ui.prototype.antipode = function () {
        var t = -1 * this.lat, e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon);
        return new ui(e, t)
    };
    var li = function () {
        this.coords = [], this.length = 0
    };
    li.prototype.move_to = function (t) {
        this.length++, this.coords.push(t)
    };
    var hi = function (t) {
        this.properties = t || {}, this.geometries = []
    };
    hi.prototype.json = function () {
        if (this.geometries.length <= 0) return {
            geometry: {type: "LineString", coordinates: null},
            type: "Feature",
            properties: this.properties
        };
        if (1 === this.geometries.length) return {
            geometry: {
                type: "LineString",
                coordinates: this.geometries[0].coords
            }, type: "Feature", properties: this.properties
        };
        for (var t = [], e = 0; e < this.geometries.length; e++) t.push(this.geometries[e].coords);
        return {geometry: {type: "MultiLineString", coordinates: t}, type: "Feature", properties: this.properties}
    }, hi.prototype.wkt = function () {
        for (var t = "", e = "LINESTRING(", n = function (t) {
            e += t[0] + " " + t[1] + ","
        }, r = 0; r < this.geometries.length; r++) {
            if (0 === this.geometries[r].coords.length) return "LINESTRING(empty)";
            this.geometries[r].coords.forEach(n), t += e.substring(0, e.length - 1) + ")"
        }
        return t
    };
    var ci = function (t, e, n) {
        if (!t || void 0 === t.x || void 0 === t.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
        if (!e || void 0 === e.x || void 0 === e.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
        this.start = new ui(t.x, t.y), this.end = new ui(e.x, e.y), this.properties = n || {};
        var r = this.start.x - this.end.x, i = this.start.y - this.end.y,
            o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2);
        if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI) throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
        if (isNaN(this.g)) throw new Error("could not calculate great circle between " + t + " and " + e)
    };

    function fi(t) {
        if (!t) throw new Error("geojson is required");
        var e = [];
        return J(t, (function (t) {
            !function (t, e) {
                var n = [], r = t.geometry;
                if (null !== r) {
                    switch (r.type) {
                        case"Polygon":
                            n = at(r);
                            break;
                        case"LineString":
                            n = [at(r)]
                    }
                    n.forEach((function (n) {
                        var r = function (t, e) {
                            var n = [];
                            return t.reduce((function (t, r) {
                                var i = x([t, r], e);
                                return i.bbox = function (t, e) {
                                    var n = t[0], r = t[1], i = e[0], o = e[1];
                                    return [n < i ? n : i, r < o ? r : o, n > i ? n : i, r > o ? r : o]
                                }(t, r), n.push(i), r
                            })), n
                        }(n, t.properties);
                        r.forEach((function (t) {
                            t.id = e.length, e.push(t)
                        }))
                    }))
                }
            }(t, e)
        })), k(e)
    }

    ci.prototype.interpolate = function (t) {
        var e = Math.sin((1 - t) * this.g) / Math.sin(this.g), n = Math.sin(t * this.g) / Math.sin(this.g),
            r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x),
            i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x),
            o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y),
            s = ai * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2)));
        return [ai * Math.atan2(i, r), s]
    }, ci.prototype.Arc = function (t, e) {
        var n = [];
        if (!t || t <= 2) n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]); else for (var r = 1 / (t - 1), i = 0; i < t; ++i) {
            var o = r * i, s = this.interpolate(o);
            n.push(s)
        }
        for (var a = !1, u = 0, l = e && e.offset ? e.offset : 10, h = 180 - l, c = -180 + l, f = 360 - l, g = 1; g < n.length; ++g) {
            var p = n[g - 1][0], v = n[g][0], d = Math.abs(v - p);
            d > f && (v > h && p < c || p > h && v < c) ? a = !0 : d > u && (u = d)
        }
        var y = [];
        if (a && u < l) {
            var m = [];
            y.push(m);
            for (var _ = 0; _ < n.length; ++_) {
                var x = parseFloat(n[_][0]);
                if (_ > 0 && Math.abs(x - n[_ - 1][0]) > f) {
                    var E = parseFloat(n[_ - 1][0]), k = parseFloat(n[_ - 1][1]), w = parseFloat(n[_][0]),
                        b = parseFloat(n[_][1]);
                    if (E > -180 && E < c && 180 === w && _ + 1 < n.length && n[_ - 1][0] > -180 && n[_ - 1][0] < c) {
                        m.push([-180, n[_][1]]), _++, m.push([n[_][0], n[_][1]]);
                        continue
                    }
                    if (E > h && E < 180 && -180 === w && _ + 1 < n.length && n[_ - 1][0] > h && n[_ - 1][0] < 180) {
                        m.push([180, n[_][1]]), _++, m.push([n[_][0], n[_][1]]);
                        continue
                    }
                    if (E < c && w > h) {
                        var I = E;
                        E = w, w = I;
                        var S = k;
                        k = b, b = S
                    }
                    if (E > h && w < c && (w += 360), E <= 180 && w >= 180 && E < w) {
                        var N = (180 - E) / (w - E), M = N * b + (1 - N) * k;
                        m.push([n[_ - 1][0] > h ? 180 : -180, M]), (m = []).push([n[_ - 1][0] > h ? -180 : 180, M]), y.push(m)
                    } else m = [], y.push(m);
                    m.push([x, n[_][1]])
                } else m.push([n[_][0], n[_][1]])
            }
        } else {
            var P = [];
            y.push(P);
            for (var L = 0; L < n.length; ++L) P.push([n[L][0], n[L][1]])
        }
        for (var C = new hi(this.properties), R = 0; R < y.length; ++R) {
            var T = new li;
            C.geometries.push(T);
            for (var O = y[R], A = 0; A < O.length; ++A) T.move_to(O[A])
        }
        return C
    };
    var gi = Wt((function (t, e) {
        t.exports = function () {
            function t(t, n, i, o, s) {
                e(t, n, i || 0, o || t.length - 1, s || r)
            }

            function e(t, r, i, o, s) {
                for (; o > i;) {
                    if (o - i > 600) {
                        var a = o - i + 1, u = r - i + 1, l = Math.log(a), h = .5 * Math.exp(2 * l / 3),
                            c = .5 * Math.sqrt(l * h * (a - h) / a) * (u - a / 2 < 0 ? -1 : 1);
                        e(t, r, Math.max(i, Math.floor(r - u * h / a + c)), Math.min(o, Math.floor(r + (a - u) * h / a + c)), s)
                    }
                    var f = t[r], g = i, p = o;
                    for (n(t, i, r), s(t[o], f) > 0 && n(t, i, o); g < p;) {
                        for (n(t, g, p), g++, p--; s(t[g], f) < 0;) g++;
                        for (; s(t[p], f) > 0;) p--
                    }
                    0 === s(t[i], f) ? n(t, i, p) : n(t, ++p, o), p <= r && (i = p + 1), r <= p && (o = p - 1)
                }
            }

            function n(t, e, n) {
                var r = t[e];
                t[e] = t[n], t[n] = r
            }

            function r(t, e) {
                return t < e ? -1 : t > e ? 1 : 0
            }

            var i = function (t) {
                void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear()
            };

            function o(t, e, n) {
                if (!n) return e.indexOf(t);
                for (var r = 0; r < e.length; r++) if (n(t, e[r])) return r;
                return -1
            }

            function s(t, e) {
                a(t, 0, t.children.length, e, t)
            }

            function a(t, e, n, r, i) {
                i || (i = y(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
                for (var o = e; o < n; o++) {
                    var s = t.children[o];
                    u(i, t.leaf ? r(s) : s)
                }
                return i
            }

            function u(t, e) {
                return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
            }

            function l(t, e) {
                return t.minX - e.minX
            }

            function h(t, e) {
                return t.minY - e.minY
            }

            function c(t) {
                return (t.maxX - t.minX) * (t.maxY - t.minY)
            }

            function f(t) {
                return t.maxX - t.minX + (t.maxY - t.minY)
            }

            function g(t, e) {
                return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY))
            }

            function p(t, e) {
                var n = Math.max(t.minX, e.minX), r = Math.max(t.minY, e.minY), i = Math.min(t.maxX, e.maxX),
                    o = Math.min(t.maxY, e.maxY);
                return Math.max(0, i - n) * Math.max(0, o - r)
            }

            function v(t, e) {
                return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
            }

            function d(t, e) {
                return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
            }

            function y(t) {
                return {children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0}
            }

            function m(e, n, r, i, o) {
                for (var s = [n, r]; s.length;) if (!((r = s.pop()) - (n = s.pop()) <= i)) {
                    var a = n + Math.ceil((r - n) / i / 2) * i;
                    t(e, a, n, r, o), s.push(n, a, a, r)
                }
            }

            return i.prototype.all = function () {
                return this._all(this.data, [])
            }, i.prototype.search = function (t) {
                var e = this.data, n = [];
                if (!d(t, e)) return n;
                for (var r = this.toBBox, i = []; e;) {
                    for (var o = 0; o < e.children.length; o++) {
                        var s = e.children[o], a = e.leaf ? r(s) : s;
                        d(t, a) && (e.leaf ? n.push(s) : v(t, a) ? this._all(s, n) : i.push(s))
                    }
                    e = i.pop()
                }
                return n
            }, i.prototype.collides = function (t) {
                var e = this.data;
                if (!d(t, e)) return !1;
                for (var n = []; e;) {
                    for (var r = 0; r < e.children.length; r++) {
                        var i = e.children[r], o = e.leaf ? this.toBBox(i) : i;
                        if (d(t, o)) {
                            if (e.leaf || v(t, o)) return !0;
                            n.push(i)
                        }
                    }
                    e = n.pop()
                }
                return !1
            }, i.prototype.load = function (t) {
                if (!t || !t.length) return this;
                if (t.length < this._minEntries) {
                    for (var e = 0; e < t.length; e++) this.insert(t[e]);
                    return this
                }
                var n = this._build(t.slice(), 0, t.length - 1, 0);
                if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else {
                    if (this.data.height < n.height) {
                        var r = this.data;
                        this.data = n, n = r
                    }
                    this._insert(n, this.data.height - n.height - 1, !0)
                } else this.data = n;
                return this
            }, i.prototype.insert = function (t) {
                return t && this._insert(t, this.data.height - 1), this
            }, i.prototype.clear = function () {
                return this.data = y([]), this
            }, i.prototype.remove = function (t, e) {
                if (!t) return this;
                for (var n, r, i, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) {
                    if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), i = !0), s.leaf) {
                        var h = o(t, s.children, e);
                        if (-1 !== h) return s.children.splice(h, 1), u.push(s), this._condense(u), this
                    }
                    i || s.leaf || !v(s, a) ? r ? (n++, s = r.children[n], i = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0])
                }
                return this
            }, i.prototype.toBBox = function (t) {
                return t
            }, i.prototype.compareMinX = function (t, e) {
                return t.minX - e.minX
            }, i.prototype.compareMinY = function (t, e) {
                return t.minY - e.minY
            }, i.prototype.toJSON = function () {
                return this.data
            }, i.prototype.fromJSON = function (t) {
                return this.data = t, this
            }, i.prototype._all = function (t, e) {
                for (var n = []; t;) t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop();
                return e
            }, i.prototype._build = function (t, e, n, r) {
                var i, o = n - e + 1, a = this._maxEntries;
                if (o <= a) return s(i = y(t.slice(e, n + 1)), this.toBBox), i;
                r || (r = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, r - 1))), (i = y([])).leaf = !1, i.height = r;
                var u = Math.ceil(o / a), l = u * Math.ceil(Math.sqrt(a));
                m(t, e, n, l, this.compareMinX);
                for (var h = e; h <= n; h += l) {
                    var c = Math.min(h + l - 1, n);
                    m(t, h, c, u, this.compareMinY);
                    for (var f = h; f <= c; f += u) {
                        var g = Math.min(f + u - 1, c);
                        i.children.push(this._build(t, f, g, r - 1))
                    }
                }
                return s(i, this.toBBox), i
            }, i.prototype._chooseSubtree = function (t, e, n, r) {
                for (; r.push(e), !e.leaf && r.length - 1 !== n;) {
                    for (var i = 1 / 0, o = 1 / 0, s = void 0, a = 0; a < e.children.length; a++) {
                        var u = e.children[a], l = c(u), h = g(t, u) - l;
                        h < o ? (o = h, i = l < i ? l : i, s = u) : h === o && l < i && (i = l, s = u)
                    }
                    e = s || e.children[0]
                }
                return e
            }, i.prototype._insert = function (t, e, n) {
                var r = n ? t : this.toBBox(t), i = [], o = this._chooseSubtree(r, this.data, e, i);
                for (o.children.push(t), u(o, r); e >= 0 && i[e].children.length > this._maxEntries;) this._split(i, e), e--;
                this._adjustParentBBoxes(r, i, e)
            }, i.prototype._split = function (t, e) {
                var n = t[e], r = n.children.length, i = this._minEntries;
                this._chooseSplitAxis(n, i, r);
                var o = this._chooseSplitIndex(n, i, r), a = y(n.children.splice(o, n.children.length - o));
                a.height = n.height, a.leaf = n.leaf, s(n, this.toBBox), s(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a)
            }, i.prototype._splitRoot = function (t, e) {
                this.data = y([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, s(this.data, this.toBBox)
            }, i.prototype._chooseSplitIndex = function (t, e, n) {
                for (var r, i = 1 / 0, o = 1 / 0, s = e; s <= n - e; s++) {
                    var u = a(t, 0, s, this.toBBox), l = a(t, s, n, this.toBBox), h = p(u, l), f = c(u) + c(l);
                    h < i ? (i = h, r = s, o = f < o ? f : o) : h === i && f < o && (o = f, r = s)
                }
                return r || n - e
            }, i.prototype._chooseSplitAxis = function (t, e, n) {
                var r = t.leaf ? this.compareMinX : l, i = t.leaf ? this.compareMinY : h;
                this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r)
            }, i.prototype._allDistMargin = function (t, e, n, r) {
                t.children.sort(r);
                for (var i = this.toBBox, o = a(t, 0, e, i), s = a(t, n - e, n, i), l = f(o) + f(s), h = e; h < n - e; h++) {
                    var c = t.children[h];
                    u(o, t.leaf ? i(c) : c), l += f(o)
                }
                for (var g = n - e - 1; g >= e; g--) {
                    var p = t.children[g];
                    u(s, t.leaf ? i(p) : p), l += f(s)
                }
                return l
            }, i.prototype._adjustParentBBoxes = function (t, e, n) {
                for (var r = n; r >= 0; r--) u(e[r], t)
            }, i.prototype._condense = function (t) {
                for (var e = t.length - 1, n = void 0; e >= 0; e--) 0 === t[e].children.length ? e > 0 ? (n = t[e - 1].children).splice(n.indexOf(t[e]), 1) : this.clear() : s(t[e], this.toBBox)
            }, i
        }()
    })), pi = Wt((function (t, n) {
        function r(t, e, n) {
            void 0 === n && (n = {});
            var r = {type: "Feature"};
            return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r
        }

        function i(t, e, n) {
            if (void 0 === n && (n = {}), !t) throw new Error("coordinates is required");
            if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
            if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long");
            if (!p(t[0]) || !p(t[1])) throw new Error("coordinates must contain numbers");
            return r({type: "Point", coordinates: t}, e, n)
        }

        function o(t, e, n) {
            void 0 === n && (n = {});
            for (var i = 0, o = t; i < o.length; i++) {
                var s = o[i];
                if (s.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                for (var a = 0; a < s[s.length - 1].length; a++) if (s[s.length - 1][a] !== s[0][a]) throw new Error("First and last Position are not equivalent.")
            }
            return r({type: "Polygon", coordinates: t}, e, n)
        }

        function s(t, e, n) {
            if (void 0 === n && (n = {}), t.length < 2) throw new Error("coordinates must be an array of two or more positions");
            return r({type: "LineString", coordinates: t}, e, n)
        }

        function a(t, e) {
            void 0 === e && (e = {});
            var n = {type: "FeatureCollection"};
            return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
        }

        function u(t, e, n) {
            return void 0 === n && (n = {}), r({type: "MultiLineString", coordinates: t}, e, n)
        }

        function l(t, e, n) {
            return void 0 === n && (n = {}), r({type: "MultiPoint", coordinates: t}, e, n)
        }

        function h(t, e, n) {
            return void 0 === n && (n = {}), r({type: "MultiPolygon", coordinates: t}, e, n)
        }

        function c(t, e) {
            void 0 === e && (e = "kilometers");
            var r = n.factors[e];
            if (!r) throw new Error(e + " units is invalid");
            return t * r
        }

        function f(t, e) {
            void 0 === e && (e = "kilometers");
            var r = n.factors[e];
            if (!r) throw new Error(e + " units is invalid");
            return t / r
        }

        function g(t) {
            return 180 * (t % (2 * Math.PI)) / Math.PI
        }

        function p(t) {
            return !isNaN(t) && null !== t && !Array.isArray(t)
        }

        Object.defineProperty(n, "__esModule", {value: !0}), n.earthRadius = 6371008.8, n.factors = {
            centimeters: 100 * n.earthRadius,
            centimetres: 100 * n.earthRadius,
            degrees: n.earthRadius / 111325,
            feet: 3.28084 * n.earthRadius,
            inches: 39.37 * n.earthRadius,
            kilometers: n.earthRadius / 1e3,
            kilometres: n.earthRadius / 1e3,
            meters: n.earthRadius,
            metres: n.earthRadius,
            miles: n.earthRadius / 1609.344,
            millimeters: 1e3 * n.earthRadius,
            millimetres: 1e3 * n.earthRadius,
            nauticalmiles: n.earthRadius / 1852,
            radians: 1,
            yards: 1.0936 * n.earthRadius
        }, n.unitsFactors = {
            centimeters: 100,
            centimetres: 100,
            degrees: 1 / 111325,
            feet: 3.28084,
            inches: 39.37,
            kilometers: .001,
            kilometres: .001,
            meters: 1,
            metres: 1,
            miles: 1 / 1609.344,
            millimeters: 1e3,
            millimetres: 1e3,
            nauticalmiles: 1 / 1852,
            radians: 1 / n.earthRadius,
            yards: 1.0936133
        }, n.areaFactors = {
            acres: 247105e-9,
            centimeters: 1e4,
            centimetres: 1e4,
            feet: 10.763910417,
            hectares: 1e-4,
            inches: 1550.003100006,
            kilometers: 1e-6,
            kilometres: 1e-6,
            meters: 1,
            metres: 1,
            miles: 386e-9,
            millimeters: 1e6,
            millimetres: 1e6,
            yards: 1.195990046
        }, n.feature = r, n.geometry = function (t, e, n) {
            switch (t) {
                case"Point":
                    return i(e).geometry;
                case"LineString":
                    return s(e).geometry;
                case"Polygon":
                    return o(e).geometry;
                case"MultiPoint":
                    return l(e).geometry;
                case"MultiLineString":
                    return u(e).geometry;
                case"MultiPolygon":
                    return h(e).geometry;
                default:
                    throw new Error(t + " is invalid")
            }
        }, n.point = i, n.points = function (t, e, n) {
            return void 0 === n && (n = {}), a(t.map((function (t) {
                return i(t, e)
            })), n)
        }, n.polygon = o, n.polygons = function (t, e, n) {
            return void 0 === n && (n = {}), a(t.map((function (t) {
                return o(t, e)
            })), n)
        }, n.lineString = s, n.lineStrings = function (t, e, n) {
            return void 0 === n && (n = {}), a(t.map((function (t) {
                return s(t, e)
            })), n)
        }, n.featureCollection = a, n.multiLineString = u, n.multiPoint = l, n.multiPolygon = h, n.geometryCollection = function (t, e, n) {
            return void 0 === n && (n = {}), r({type: "GeometryCollection", geometries: t}, e, n)
        }, n.round = function (t, e) {
            if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error("precision must be a positive number");
            var n = Math.pow(10, e || 0);
            return Math.round(t * n) / n
        }, n.radiansToLength = c, n.lengthToRadians = f, n.lengthToDegrees = function (t, e) {
            return g(f(t, e))
        }, n.bearingToAzimuth = function (t) {
            var e = t % 360;
            return e < 0 && (e += 360), e
        }, n.radiansToDegrees = g, n.degreesToRadians = function (t) {
            return t % 360 * Math.PI / 180
        }, n.convertLength = function (t, e, n) {
            if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("length must be a positive number");
            return c(f(t, e), n)
        }, n.convertArea = function (t, e, r) {
            if (void 0 === e && (e = "meters"), void 0 === r && (r = "kilometers"), !(t >= 0)) throw new Error("area must be a positive number");
            var i = n.areaFactors[e];
            if (!i) throw new Error("invalid original units");
            var o = n.areaFactors[r];
            if (!o) throw new Error("invalid final units");
            return t / i * o
        }, n.isNumber = p, n.isObject = function (t) {
            return !!t && t.constructor === Object
        }, n.validateBBox = function (t) {
            if (!t) throw new Error("bbox is required");
            if (!Array.isArray(t)) throw new Error("bbox must be an Array");
            if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers");
            t.forEach((function (t) {
                if (!p(t)) throw new Error("bbox must only contain numbers")
            }))
        }, n.validateId = function (t) {
            if (!t) throw new Error("id is required");
            if (-1 === ["string", "number"].indexOf(e(t))) throw new Error("id must be a number or a string")
        }
    }));

    function vi(t, e, n) {
        if (null !== t) for (var r, i, o, s, a, u, l, h, c = 0, f = 0, g = t.type, p = "FeatureCollection" === g, v = "Feature" === g, d = p ? t.features.length : 1, y = 0; y < d; y++) {
            a = (h = !!(l = p ? t.features[y].geometry : v ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1;
            for (var m = 0; m < a; m++) {
                var _ = 0, x = 0;
                if (null !== (s = h ? l.geometries[m] : l)) {
                    u = s.coordinates;
                    var E = s.type;
                    switch (c = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) {
                        case null:
                            break;
                        case"Point":
                            if (!1 === e(u, f, y, _, x)) return !1;
                            f++, _++;
                            break;
                        case"LineString":
                        case"MultiPoint":
                            for (r = 0; r < u.length; r++) {
                                if (!1 === e(u[r], f, y, _, x)) return !1;
                                f++, "MultiPoint" === E && _++
                            }
                            "LineString" === E && _++;
                            break;
                        case"Polygon":
                        case"MultiLineString":
                            for (r = 0; r < u.length; r++) {
                                for (i = 0; i < u[r].length - c; i++) {
                                    if (!1 === e(u[r][i], f, y, _, x)) return !1;
                                    f++
                                }
                                "MultiLineString" === E && _++, "Polygon" === E && x++
                            }
                            "Polygon" === E && _++;
                            break;
                        case"MultiPolygon":
                            for (r = 0; r < u.length; r++) {
                                for (x = 0, i = 0; i < u[r].length; i++) {
                                    for (o = 0; o < u[r][i].length - c; o++) {
                                        if (!1 === e(u[r][i][o], f, y, _, x)) return !1;
                                        f++
                                    }
                                    x++
                                }
                                _++
                            }
                            break;
                        case"GeometryCollection":
                            for (r = 0; r < s.geometries.length; r++) if (!1 === vi(s.geometries[r], e, n)) return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                    }
                }
            }
        }
    }

    function di(t, e) {
        var n;
        switch (t.type) {
            case"FeatureCollection":
                for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++) ;
                break;
            case"Feature":
                e(t.properties, 0)
        }
    }

    function yi(t, e) {
        if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++) ;
    }

    function mi(t, e) {
        var n, r, i, o, s, a, u, l, h, c, f = 0, g = "FeatureCollection" === t.type, p = "Feature" === t.type,
            v = g ? t.features.length : 1;
        for (n = 0; n < v; n++) {
            for (a = g ? t.features[n].geometry : p ? t.geometry : t, l = g ? t.features[n].properties : p ? t.properties : {}, h = g ? t.features[n].bbox : p ? t.bbox : void 0, c = g ? t.features[n].id : p ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++) if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) {
                case"Point":
                case"LineString":
                case"MultiPoint":
                case"Polygon":
                case"MultiLineString":
                case"MultiPolygon":
                    if (!1 === e(o, f, l, h, c)) return !1;
                    break;
                case"GeometryCollection":
                    for (r = 0; r < o.geometries.length; r++) if (!1 === e(o.geometries[r], f, l, h, c)) return !1;
                    break;
                default:
                    throw new Error("Unknown Geometry Type")
            } else if (!1 === e(null, f, l, h, c)) return !1;
            f++
        }
    }

    function _i(t, e) {
        mi(t, (function (t, n, r, i, o) {
            var s, a = null === t ? null : t.type;
            switch (a) {
                case null:
                case"Point":
                case"LineString":
                case"Polygon":
                    return !1 !== e(pi.feature(t, r, {bbox: i, id: o}), n, 0) && void 0
            }
            switch (a) {
                case"MultiPoint":
                    s = "Point";
                    break;
                case"MultiLineString":
                    s = "LineString";
                    break;
                case"MultiPolygon":
                    s = "Polygon"
            }
            for (var u = 0; u < t.coordinates.length; u++) {
                var l = {type: s, coordinates: t.coordinates[u]};
                if (!1 === e(pi.feature(l, r), n, u)) return !1
            }
        }))
    }

    function xi(t, e) {
        _i(t, (function (t, n, r) {
            var i = 0;
            if (t.geometry) {
                var o = t.geometry.type;
                if ("Point" !== o && "MultiPoint" !== o) {
                    var s, a = 0, u = 0, l = 0;
                    return !1 !== vi(t, (function (o, h, c, f, g) {
                        if (void 0 === s || n > a || f > u || g > l) return s = o, a = n, u = f, l = g, void (i = 0);
                        var p = pi.lineString([s, o], t.properties);
                        if (!1 === e(p, n, r, g, i)) return !1;
                        i++, s = o
                    })) && void 0
                }
            }
        }))
    }

    function Ei(t, e) {
        if (!t) throw new Error("geojson is required");
        _i(t, (function (t, n, r) {
            if (null !== t.geometry) {
                var i = t.geometry.type, o = t.geometry.coordinates;
                switch (i) {
                    case"LineString":
                        if (!1 === e(t, n, r, 0, 0)) return !1;
                        break;
                    case"Polygon":
                        for (var s = 0; s < o.length; s++) if (!1 === e(pi.lineString(o[s], t.properties), n, r, s)) return !1
                }
            }
        }))
    }

    var ki = function (t) {
        var e = [];
        return vi(t, (function (t) {
            e.push(t)
        })), e
    }, wi = vi, bi = function (t, e, n, r) {
        var i = n;
        return vi(t, (function (t, r, o, s, a) {
            i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a)
        }), r), i
    }, Ii = yi, Si = function (t, e, n) {
        var r = n;
        return yi(t, (function (t, i) {
            r = 0 === i && void 0 === n ? t : e(r, t, i)
        })), r
    }, Ni = function (t, e) {
        if (e = e || {}, !pi.isObject(e)) throw new Error("options is invalid");
        var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.coordIndex || 0,
            a = e.properties;
        switch (t.type) {
            case"FeatureCollection":
                r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;
                break;
            case"Feature":
                a = a || t.properties, n = t.geometry;
                break;
            case"Point":
            case"MultiPoint":
                return null;
            case"LineString":
            case"Polygon":
            case"MultiLineString":
            case"MultiPolygon":
                n = t;
                break;
            default:
                throw new Error("geojson is invalid")
        }
        if (null === n) return null;
        var u = n.coordinates;
        switch (n.type) {
            case"Point":
                return pi.point(u, a, e);
            case"MultiPoint":
                return i < 0 && (i = u.length + i), pi.point(u[i], a, e);
            case"LineString":
                return s < 0 && (s = u.length + s), pi.point(u[s], a, e);
            case"Polygon":
                return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s), pi.point(u[o][s], a, e);
            case"MultiLineString":
                return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), pi.point(u[i][s], a, e);
            case"MultiPolygon":
                return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s), pi.point(u[i][o][s], a, e)
        }
        throw new Error("geojson is invalid")
    }, Mi = function (t, e) {
        if (e = e || {}, !pi.isObject(e)) throw new Error("options is invalid");
        var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.segmentIndex || 0,
            a = e.properties;
        switch (t.type) {
            case"FeatureCollection":
                r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry;
                break;
            case"Feature":
                a = a || t.properties, n = t.geometry;
                break;
            case"Point":
            case"MultiPoint":
                return null;
            case"LineString":
            case"Polygon":
            case"MultiLineString":
            case"MultiPolygon":
                n = t;
                break;
            default:
                throw new Error("geojson is invalid")
        }
        if (null === n) return null;
        var u = n.coordinates;
        switch (n.type) {
            case"Point":
            case"MultiPoint":
                return null;
            case"LineString":
                return s < 0 && (s = u.length + s - 1), pi.lineString([u[s], u[s + 1]], a, e);
            case"Polygon":
                return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), pi.lineString([u[o][s], u[o][s + 1]], a, e);
            case"MultiLineString":
                return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), pi.lineString([u[i][s], u[i][s + 1]], a, e);
            case"MultiPolygon":
                return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), pi.lineString([u[i][o][s], u[i][o][s + 1]], a, e)
        }
        throw new Error("geojson is invalid")
    }, Pi = _i, Li = function (t, e, n) {
        var r = n;
        return _i(t, (function (t, i, o) {
            r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o)
        })), r
    }, Ci = mi, Ri = function (t, e, n) {
        var r = n;
        return mi(t, (function (t, i, o, s, a) {
            r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a)
        })), r
    }, Ti = Ei, Oi = function (t, e, n) {
        var r = n;
        return Ei(t, (function (t, i, o, s) {
            r = 0 === i && void 0 === n ? t : e(r, t, i, o, s)
        })), r
    }, Ai = di, Di = function (t, e, n) {
        var r = n;
        return di(t, (function (t, i) {
            r = 0 === i && void 0 === n ? t : e(r, t, i)
        })), r
    }, Fi = xi, qi = function (t, e, n) {
        var r = n, i = !1;
        return xi(t, (function (t, o, s, a, u) {
            r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0
        })), r
    }, Gi = Object.defineProperty({
        coordAll: ki,
        coordEach: wi,
        coordReduce: bi,
        featureEach: Ii,
        featureReduce: Si,
        findPoint: Ni,
        findSegment: Mi,
        flattenEach: Pi,
        flattenReduce: Li,
        geomEach: Ci,
        geomReduce: Ri,
        lineEach: Ti,
        lineReduce: Oi,
        propEach: Ai,
        propReduce: Di,
        segmentEach: Fi,
        segmentReduce: qi
    }, "__esModule", {value: !0});

    function Yi(t) {
        var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return Gi.coordEach(t, (function (t) {
            e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1])
        })), e
    }

    Yi.default = Yi;
    var Bi = Yi, zi = Object.defineProperty({default: Bi}, "__esModule", {value: !0}).default, Xi = Gi.featureEach,
        ji = (Gi.coordEach, pi.polygon, pi.featureCollection);

    function Ui(t) {
        var e = new gi(t);
        return e.insert = function (t) {
            if ("Feature" !== t.type) throw new Error("invalid feature");
            return t.bbox = t.bbox ? t.bbox : zi(t), gi.prototype.insert.call(this, t)
        }, e.load = function (t) {
            var e = [];
            return Array.isArray(t) ? t.forEach((function (t) {
                if ("Feature" !== t.type) throw new Error("invalid features");
                t.bbox = t.bbox ? t.bbox : zi(t), e.push(t)
            })) : Xi(t, (function (t) {
                if ("Feature" !== t.type) throw new Error("invalid features");
                t.bbox = t.bbox ? t.bbox : zi(t), e.push(t)
            })), gi.prototype.load.call(this, e)
        }, e.remove = function (t, e) {
            if ("Feature" !== t.type) throw new Error("invalid feature");
            return t.bbox = t.bbox ? t.bbox : zi(t), gi.prototype.remove.call(this, t, e)
        }, e.clear = function () {
            return gi.prototype.clear.call(this)
        }, e.search = function (t) {
            var e = gi.prototype.search.call(this, this.toBBox(t));
            return ji(e)
        }, e.collides = function (t) {
            return gi.prototype.collides.call(this, this.toBBox(t))
        }, e.all = function () {
            var t = gi.prototype.all.call(this);
            return ji(t)
        }, e.toJSON = function () {
            return gi.prototype.toJSON.call(this)
        }, e.fromJSON = function (t) {
            return gi.prototype.fromJSON.call(this, t)
        }, e.toBBox = function (t) {
            var e;
            if (t.bbox) e = t.bbox; else if (Array.isArray(t) && 4 === t.length) e = t; else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]]; else if ("Feature" === t.type) e = zi(t); else {
                if ("FeatureCollection" !== t.type) throw new Error("invalid geojson");
                e = zi(t)
            }
            return {minX: e[0], minY: e[1], maxX: e[2], maxY: e[3]}
        }, e
    }

    var Vi = Ui, Zi = Ui;

    function Hi(t, e) {
        var n = [], r = Vi();
        return J(e, (function (e) {
            if (n.forEach((function (t, e) {
                t.id = e
            })), n.length) {
                var i = r.search(e);
                if (i.features.length) {
                    var o = Ji(e, i);
                    n = n.filter((function (t) {
                        return t.id !== o.id
                    })), r.remove(o), U(Wi(o, e), (function (t) {
                        n.push(t), r.insert(t)
                    }))
                }
            } else (n = Wi(t, e).features).forEach((function (t) {
                t.bbox || (t.bbox = xn(ot(t)))
            })), r.load(k(n))
        })), k(n)
    }

    function Wi(t, e) {
        var n = [], r = at(t)[0], i = at(t)[t.geometry.coordinates.length - 1];
        if (Qi(r, st(e)) || Qi(i, st(e))) return k([t]);
        var o = Vi(), s = fi(t);
        o.load(s);
        var a = o.search(e);
        if (!a.features.length) return k([t]);
        var u = Ji(e, a), l = V(s, (function (t, r, i) {
            var o = at(r)[1], s = st(e);
            return i === u.id ? (t.push(s), n.push(x(t)), Qi(s, o) ? [s] : [s, o]) : (t.push(o), t)
        }), [r]);
        return l.length > 1 && n.push(x(l)), k(n)
    }

    function Ji(t, e) {
        if (!e.features.length) throw new Error("lines must contain features");
        if (1 === e.features.length) return e.features[0];
        var n, r = 1 / 0;
        return U(e, (function (e) {
            var i = pr(e, t).properties.dist;
            i < r && (n = e, r = i)
        })), n
    }

    function Qi(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function Ki(t, e, n, r) {
        var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, o = i.steps || 64, s = $i(n),
            a = $i(r), u = Array.isArray(t) || "Feature" !== t.type ? {} : t.properties;
        if (s === a) return x(kn(t, e, i).geometry.coordinates[0], u);
        for (var l = s, h = s < a ? a : a + 360, c = l, f = [], g = 0; c < h;) f.push(En(t, e, c, i).geometry.coordinates), c = l + 360 * ++g / o;
        return c >= h && f.push(En(t, e, h, i).geometry.coordinates), x(f, u)
    }

    function $i(t) {
        var e = t % 360;
        return e < 0 && (e += 360), e
    }

    function to(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = ft(t);
        switch (e.properties || "Feature" !== t.type || (e.properties = t.properties), n.type) {
            case"Polygon":
                return eo(n, e);
            case"MultiPolygon":
                return no(n, e);
            default:
                throw new Error("invalid poly")
        }
    }

    function eo(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = ft(t), r = n.coordinates,
            i = e.properties ? e.properties : "Feature" === t.type ? t.properties : {};
        return ro(r, i)
    }

    function no(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = ft(t), r = n.coordinates,
            i = e.properties ? e.properties : "Feature" === t.type ? t.properties : {}, o = [];
        return r.forEach((function (t) {
            o.push(ro(t, i))
        })), k(o)
    }

    function ro(t, e) {
        return t.length > 1 ? w(t, e) : x(t[0], e)
    }

    function io(t, e, n, r) {
        e = e || ("Feature" === t.type ? t.properties : {});
        var i = ft(t), o = i.coordinates, s = i.type;
        if (!o.length) throw new Error("line must contain coordinates");
        switch (s) {
            case"LineString":
                return n && (o = oo(o)), m([o], e);
            case"MultiLineString":
                var a = [], u = 0;
                return o.forEach((function (t) {
                    if (n && (t = oo(t)), r) {
                        var e = function (t) {
                            var e = t[0], n = t[1], r = t[2], i = t[3];
                            return Math.abs(e - r) * Math.abs(n - i)
                        }(ot(x(t)));
                        e > u ? (a.unshift(t), u = e) : a.push(t)
                    } else a.push(t)
                })), m(a, e);
            default:
                throw new Error("geometry type " + s + " is not supported")
        }
    }

    function oo(t) {
        var e = t[0], n = e[0], r = e[1], i = t[t.length - 1], o = i[0], s = i[1];
        return n === o && r === s || t.push(e), t
    }

    function so(t, e) {
        var n, r, i, o, s, a, u;
        for (r = 1; r <= 8; r *= 2) {
            for (n = [], o = !(uo(i = t[t.length - 1], e) & r), s = 0; s < t.length; s++) (u = !(uo(a = t[s], e) & r)) !== o && n.push(ao(i, a, r, e)), u && n.push(a), i = a, o = u;
            if (!(t = n).length) break
        }
        return n
    }

    function ao(t, e, n, r) {
        return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null
    }

    function uo(t, e) {
        var n = 0;
        return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n
    }

    function lo(t, e) {
        var n, r = [], i = h(t);
        try {
            for (i.s(); !(n = i.n()).done;) {
                var o = so(n.value, e);
                o.length > 0 && (o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1] || o.push(o[0]), o.length >= 4 && r.push(o))
            }
        } catch (t) {
            i.e(t)
        } finally {
            i.f()
        }
        return r
    }

    Vi.default = Zi;
    var ho = Wt((function (t, e) {
        function n(t) {
            var e = [];
            for (var n in t) e.push(n);
            return e
        }

        (t.exports = "function" == typeof Object.keys ? Object.keys : n).shim = n
    })), co = Wt((function (t, n) {
        var r = "[object Arguments]" == function () {
            return Object.prototype.toString.call(arguments)
        }();

        function i(t) {
            return "[object Arguments]" == Object.prototype.toString.call(t)
        }

        function o(t) {
            return t && "object" == e(t) && "number" == typeof t.length && Object.prototype.hasOwnProperty.call(t, "callee") && !Object.prototype.propertyIsEnumerable.call(t, "callee") || !1
        }

        (n = t.exports = r ? i : o).supported = i, n.unsupported = o
    })), fo = Wt((function (t) {
        var n = Array.prototype.slice, r = t.exports = function (t, s, a) {
            return a || (a = {}), t === s || (t instanceof Date && s instanceof Date ? t.getTime() === s.getTime() : !t || !s || "object" != e(t) && "object" != e(s) ? a.strict ? t === s : t == s : function (t, s, a) {
                var u, l;
                if (i(t) || i(s)) return !1;
                if (t.prototype !== s.prototype) return !1;
                if (co(t)) return !!co(s) && (t = n.call(t), s = n.call(s), r(t, s, a));
                if (o(t)) {
                    if (!o(s)) return !1;
                    if (t.length !== s.length) return !1;
                    for (u = 0; u < t.length; u++) if (t[u] !== s[u]) return !1;
                    return !0
                }
                try {
                    var h = ho(t), c = ho(s)
                } catch (t) {
                    return !1
                }
                if (h.length != c.length) return !1;
                for (h.sort(), c.sort(), u = h.length - 1; u >= 0; u--) if (h[u] != c[u]) return !1;
                for (u = h.length - 1; u >= 0; u--) if (l = h[u], !r(t[l], s[l], a)) return !1;
                return e(t) === e(s)
            }(t, s, a))
        };

        function i(t) {
            return null == t
        }

        function o(t) {
            return !(!t || "object" !== e(t) || "number" != typeof t.length) && ("function" == typeof t.copy && "function" == typeof t.slice && !(t.length > 0 && "number" != typeof t[0]))
        }
    }));

    function go(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r, i = n.tolerance || 0, o = [], s = Vi(), a = fi(t);
        s.load(a);
        var u = [];
        return K(e, (function (t) {
            var e = !1;
            t && (U(s.search(t), (function (n) {
                if (!1 === e) {
                    var o = at(t).sort(), s = at(n).sort();
                    if (fo(o, s)) e = !0, r = r ? po(r, t) || r : t; else if (0 === i ? Br(o[0], n) && Br(o[1], n) : pr(n, o[0]).properties.dist <= i && pr(n, o[1]).properties.dist <= i) e = !0, r = r ? po(r, t) || r : t; else if (0 === i ? Br(s[0], t) && Br(s[1], t) : pr(t, s[0]).properties.dist <= i && pr(t, s[1]).properties.dist <= i) if (r) {
                        var a = po(r, n);
                        a ? r = a : u.push(n)
                    } else r = n
                }
            })), !1 === e && r && (o.push(r), u.length && (o = o.concat(u), u = []), r = void 0))
        })), r && o.push(r), k(o)
    }

    function po(t, e) {
        var n = at(e), r = at(t), i = r[0], o = r[r.length - 1], s = t.geometry.coordinates;
        if (fo(n[0], i)) s.unshift(n[1]); else if (fo(n[0], o)) s.push(n[1]); else if (fo(n[1], i)) s.unshift(n[0]); else {
            if (!fo(n[1], o)) return;
            s.push(n[0])
        }
        return t
    }

    function vo(t) {
        var e = t % 360;
        return e < 0 && (e += 360), e
    }

    function yo(t, e) {
        var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            i = (n = r.final ? mo(st(e), st(t)) : mo(st(t), st(e))) > 180 ? -(360 - n) : n;
        return i
    }

    function mo(t, e) {
        var n = T(t[1]), r = T(e[1]), i = T(e[0] - t[0]);
        i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI);
        var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4));
        return (R(Math.atan2(i, o)) + 360) % 360
    }

    function _o(t, e, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = e < 0,
            o = O(Math.abs(e), r.units, "meters");
        i && (o = -Math.abs(o));
        var s = st(t), a = xo(s, o, n);
        return a[0] += a[0] - s[0] > 180 ? -360 : s[0] - a[0] > 180 ? 360 : 0, d(a, r.properties)
    }

    function xo(t, e, n, r) {
        var i = e / (r = void 0 === r ? c : Number(r)), o = t[0] * Math.PI / 180, s = T(t[1]), a = T(n),
            u = i * Math.cos(a), l = s + u;
        Math.abs(l) > Math.PI / 2 && (l = l > 0 ? Math.PI - l : -Math.PI - l);
        var h = Math.log(Math.tan(l / 2 + Math.PI / 4) / Math.tan(s / 2 + Math.PI / 4)),
            f = Math.abs(h) > 1e-11 ? u / h : Math.cos(s);
        return [(180 * (o + i * Math.sin(a) / f) / Math.PI + 540) % 360 - 180, 180 * l / Math.PI]
    }

    function Eo(t, e, n, r, i, o) {
        for (var s = 0; s < t.length; s++) {
            var a = t[s], u = t[s + 1];
            s === t.length - 1 && (u = t[0]), r = wo(a, u, e), n <= 0 && r > 0 ? wo(e, a, i) < 0 || (i = a) : n > 0 && r <= 0 && (ko(e, a, o) || (o = a)), n = r
        }
        return [i, o]
    }

    function ko(t, e, n) {
        return wo(t, e, n) > 0
    }

    function wo(t, e, n) {
        return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1])
    }

    function bo(t) {
        for (var e, n, r = at(t), i = 0, o = 1; o < r.length;) e = n || r[0], i += ((n = r[o])[0] - e[0]) * (n[1] + e[1]), o++;
        return i > 0
    }

    function Io(t, e) {
        switch ("Feature" === t.type ? t.geometry.type : t.type) {
            case"GeometryCollection":
                return H(t, (function (t) {
                    Io(t, e)
                })), t;
            case"LineString":
                return So(at(t), e), t;
            case"Polygon":
                return No(at(t), e), t;
            case"MultiLineString":
                return at(t).forEach((function (t) {
                    So(t, e)
                })), t;
            case"MultiPolygon":
                return at(t).forEach((function (t) {
                    No(t, e)
                })), t;
            case"Point":
            case"MultiPoint":
                return t
        }
    }

    function So(t, e) {
        bo(t) === e && t.reverse()
    }

    function No(t, e) {
        bo(t[0]) !== e && t[0].reverse();
        for (var n = 1; n < t.length; n++) bo(t[n]) === e && t[n].reverse()
    }

    function Mo(t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.zProperty || "elevation", r = e.flip, i = e.flags;
        ct(t, "Point", "input must contain Points");
        for (var o = function (t, e) {
            var n = {};
            U(t, (function (t) {
                var e = at(t)[1];
                n[e] || (n[e] = []), n[e].push(t)
            }));
            var r = Object.keys(n).map((function (t) {
                return n[t].sort((function (t, e) {
                    return at(t)[0] - at(e)[0]
                }))
            }));
            return r.sort((function (t, n) {
                return e ? at(t[0])[1] - at(n[0])[1] : at(n[0])[1] - at(t[0])[1]
            }))
        }
            /*!
           * @license GNU Affero General Public License.
           * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
           * v. 1.2.0
           * https://github.com/RaumZeit/MarchingSquares.js
           *
           * MarchingSquaresJS is free software: you can redistribute it and/or modify
           * it under the terms of the GNU Affero General Public License as published by
           * the Free Software Foundation, either version 3 of the License, or
           * (at your option) any later version.
           *
           * MarchingSquaresJS is distributed in the hope that it will be useful,
           * but WITHOUT ANY WARRANTY; without even the implied warranty of
           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
           * GNU Affero General Public License for more details.
           *
           * As additional permission under GNU Affero General Public License version 3
           * section 7, third-party projects (personal or commercial) may distribute,
           * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
           * requirement that said third-party project for that reason alone becomes
           * subject to any requirement of the GNU Affero General Public License version 3.
           * Any modifications to MarchingSquaresJS, however, must be shared with the public
           * and made available.
           *
           * In summary this:
           * - allows you to use MarchingSquaresJS at no cost
           * - allows you to use MarchingSquaresJS for both personal and commercial purposes
           * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
           *   license as long as this license notice is included
           * - enables you to keep the source code of your program that uses MarchingSquaresJS
           *   undisclosed
           * - forces you to share any modifications you have made to MarchingSquaresJS,
           *   e.g. bug-fixes
           *
           * You should have received a copy of the GNU Affero General Public License
           * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
           */(t, r), s = [], a = 0; a < o.length; a++) {
            for (var u = o[a], l = [], h = 0; h < u.length; h++) {
                var c = u[h];
                c.properties[n] ? l.push(c.properties[n]) : l.push(0), !0 === i && (c.properties.matrixPosition = [a, h])
            }
            s.push(l)
        }
        return s
    }

    var Po = {successCallback: null, verbose: !1, polygons: !1}, Lo = {};

    function Co(t, n, r, i) {
        i = i || {};
        for (var o = Object.keys(Po), s = 0; s < o.length; s++) {
            var a = o[s], u = i[a];
            u = null != u ? u : Po[a], Lo[a] = u
        }
        Lo.verbose && console.log("MarchingSquaresJS-isoBands: computing isobands for [" + n + ":" + (n + r) + "]");
        var l, h = function (t, e, n) {
            for (var r = t.length - 1, i = t[0].length - 1, o = {
                rows: r,
                cols: i,
                cells: []
            }, s = e + Math.abs(n), a = 0; a < r; ++a) {
                o.cells[a] = [];
                for (var u = 0; u < i; ++u) {
                    var l = 0, h = t[a + 1][u], c = t[a + 1][u + 1], f = t[a][u + 1], g = t[a][u];
                    if (!(isNaN(h) || isNaN(c) || isNaN(f) || isNaN(g))) {
                        l |= h < e ? 0 : h > s ? 128 : 64, l |= c < e ? 0 : c > s ? 32 : 16, l |= f < e ? 0 : f > s ? 8 : 4;
                        var p = +(l |= g < e ? 0 : g > s ? 2 : 1), v = 0;
                        if (17 === l || 18 === l || 33 === l || 34 === l || 38 === l || 68 === l || 72 === l || 98 === l || 102 === l || 132 === l || 136 === l || 137 === l || 152 === l || 153 === l) {
                            var d = (h + c + f + g) / 4;
                            v = d > s ? 2 : d < e ? 0 : 1, 34 === l ? 1 === v ? l = 35 : 0 === v && (l = 136) : 136 === l ? 1 === v ? (l = 35, v = 4) : 0 === v && (l = 34) : 17 === l ? 1 === v ? (l = 155, v = 4) : 0 === v && (l = 153) : 68 === l ? 1 === v ? (l = 103, v = 4) : 0 === v && (l = 102) : 153 === l ? 1 === v && (l = 155) : 102 === l ? 1 === v && (l = 103) : 152 === l ? v < 2 && (l = 156, v = 1) : 137 === l ? v < 2 && (l = 139, v = 1) : 98 === l ? v < 2 && (l = 99, v = 1) : 38 === l ? v < 2 && (l = 39, v = 1) : 18 === l ? v > 0 ? (l = 156, v = 4) : l = 152 : 33 === l ? v > 0 ? (l = 139, v = 4) : l = 137 : 72 === l ? v > 0 ? (l = 99, v = 4) : l = 98 : 132 === l && (v > 0 ? (l = 39, v = 4) : l = 38)
                        }
                        if (0 != l && 170 != l) {
                            var y, m, _, x, E, k, w, b;
                            y = m = _ = x = E = k = w = b = .5;
                            var I = [];
                            1 === l ? (_ = 1 - Es(e, f, g), b = 1 - Es(e, h, g), I.push(vs[l])) : 169 === l ? (_ = Es(s, g, f), b = Es(s, g, h), I.push(vs[l])) : 4 === l ? (k = 1 - Es(e, c, f), x = Es(e, g, f), I.push(gs[l])) : 166 === l ? (k = Es(s, f, c), x = 1 - Es(s, f, g), I.push(gs[l])) : 16 === l ? (E = Es(e, f, c), m = Es(e, h, c), I.push(fs[l])) : 154 === l ? (E = 1 - Es(s, c, f), m = 1 - Es(s, c, h), I.push(fs[l])) : 64 === l ? (w = Es(e, g, h), y = 1 - Es(e, c, h), I.push(ys[l])) : 106 === l ? (w = 1 - Es(s, h, g), y = Es(s, h, c), I.push(ys[l])) : 168 === l ? (x = Es(s, g, f), _ = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), I.push(ps[l]), I.push(vs[l])) : 2 === l ? (x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), I.push(ps[l]), I.push(vs[l])) : 162 === l ? (E = Es(s, f, c), k = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), I.push(ps[l]), I.push(vs[l])) : 8 === l ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), I.push(fs[l]), I.push(gs[l])) : 138 === l ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h), I.push(fs[l]), I.push(gs[l])) : 32 === l ? (E = Es(s, f, c), k = Es(e, f, c), y = Es(e, h, c), m = Es(s, h, c), I.push(fs[l]), I.push(gs[l])) : 42 === l ? (b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c), I.push(ds[l]), I.push(ys[l])) : 128 === l && (b = Es(e, g, h), w = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h), I.push(ds[l]), I.push(ys[l])), 5 === l ? (k = 1 - Es(e, c, f), b = 1 - Es(e, h, g), I.push(gs[l])) : 165 === l ? (k = Es(s, f, c), b = Es(s, g, h), I.push(gs[l])) : 20 === l ? (x = Es(e, g, f), m = Es(e, h, c), I.push(ps[l])) : 150 === l ? (x = 1 - Es(s, f, g), m = 1 - Es(s, c, h), I.push(ps[l])) : 80 === l ? (E = Es(e, f, c), w = Es(e, g, h), I.push(fs[l])) : 90 === l ? (E = 1 - Es(s, c, f), w = 1 - Es(s, h, g), I.push(fs[l])) : 65 === l ? (_ = 1 - Es(e, f, g), y = 1 - Es(e, c, h), I.push(vs[l])) : 105 === l ? (_ = Es(s, g, f), y = Es(s, h, c), I.push(vs[l])) : 160 === l ? (E = Es(s, f, c), k = Es(e, f, c), b = Es(e, g, h), w = Es(s, g, h), I.push(fs[l]), I.push(gs[l])) : 10 === l ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), I.push(fs[l]), I.push(gs[l])) : 130 === l ? (x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h), I.push(ps[l]), I.push(vs[l])) : 40 === l ? (x = Es(s, g, f), _ = Es(e, g, f), y = Es(e, h, c), m = Es(s, h, c), I.push(ps[l]), I.push(vs[l])) : 101 === l ? (k = Es(s, f, c), y = Es(s, h, c), I.push(gs[l])) : 69 === l ? (k = 1 - Es(e, c, f), y = 1 - Es(e, c, h), I.push(gs[l])) : 149 === l ? (b = Es(s, g, h), m = 1 - Es(s, c, h), I.push(ds[l])) : 21 === l ? (b = 1 - Es(e, h, g), m = Es(e, h, c), I.push(ds[l])) : 86 === l ? (x = 1 - Es(s, f, g), w = 1 - Es(s, h, g), I.push(ps[l])) : 84 === l ? (x = Es(e, g, f), w = Es(e, g, h), I.push(ps[l])) : 89 === l ? (E = 1 - Es(s, c, f), _ = Es(s, g, f), I.push(vs[l])) : 81 === l ? (E = Es(e, f, c), _ = 1 - Es(e, f, g), I.push(vs[l])) : 96 === l ? (E = Es(s, f, c), k = Es(e, f, c), w = Es(e, g, h), y = Es(s, h, c), I.push(fs[l]), I.push(gs[l])) : 74 === l ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), w = 1 - Es(s, h, g), y = 1 - Es(e, c, h), I.push(fs[l]), I.push(gs[l])) : 24 === l ? (E = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), m = Es(e, h, c), I.push(fs[l]), I.push(vs[l])) : 146 === l ? (E = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), m = 1 - Es(s, c, h), I.push(fs[l]), I.push(vs[l])) : 6 === l ? (k = 1 - Es(e, c, f), x = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), I.push(gs[l]), I.push(ps[l])) : 164 === l ? (k = Es(s, f, c), x = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), I.push(gs[l]), I.push(ps[l])) : 129 === l ? (_ = 1 - Es(e, f, g), b = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h), I.push(vs[l]), I.push(ds[l])) : 41 === l ? (_ = Es(s, g, f), b = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c), I.push(vs[l]), I.push(ds[l])) : 66 === l ? (x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), w = 1 - Es(s, h, g), y = 1 - Es(e, c, h), I.push(ps[l]), I.push(vs[l])) : 104 === l ? (x = Es(s, g, f), _ = Es(e, g, f), w = Es(e, g, h), y = Es(s, h, c), I.push(vs[l]), I.push(ms[l])) : 144 === l ? (E = Es(e, f, c), b = Es(e, g, h), w = Es(s, g, h), m = 1 - Es(s, c, h), I.push(fs[l]), I.push(ys[l])) : 26 === l ? (E = 1 - Es(s, c, f), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), m = Es(e, h, c), I.push(fs[l]), I.push(ys[l])) : 36 === l ? (k = Es(s, f, c), x = Es(e, g, f), y = Es(e, h, c), m = Es(s, h, c), I.push(gs[l]), I.push(ps[l])) : 134 === l ? (k = 1 - Es(e, c, f), x = 1 - Es(s, f, g), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h), I.push(gs[l]), I.push(ps[l])) : 9 === l ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), _ = Es(s, g, f), b = 1 - Es(e, h, g), I.push(fs[l]), I.push(gs[l])) : 161 === l ? (E = Es(s, f, c), k = Es(e, f, c), _ = 1 - Es(e, f, g), b = Es(s, g, h), I.push(fs[l]), I.push(gs[l])) : 37 === l ? (k = Es(s, f, c), b = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c), I.push(gs[l]), I.push(ds[l])) : 133 === l ? (k = 1 - Es(e, c, f), b = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h), I.push(gs[l]), I.push(ds[l])) : 148 === l ? (x = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), m = 1 - Es(s, c, h), I.push(ps[l]), I.push(ys[l])) : 22 === l ? (x = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), m = Es(e, h, c), I.push(ps[l]), I.push(ys[l])) : 82 === l ? (E = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), w = 1 - Es(s, h, g), I.push(fs[l]), I.push(vs[l])) : 88 === l ? (E = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), w = Es(e, g, h), I.push(fs[l]), I.push(vs[l])) : 73 === l ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), _ = Es(s, g, f), y = 1 - Es(e, c, h), I.push(fs[l]), I.push(gs[l])) : 97 === l ? (E = Es(s, f, c), k = Es(e, f, c), _ = 1 - Es(e, f, g), y = Es(s, h, c), I.push(fs[l]), I.push(gs[l])) : 145 === l ? (E = Es(e, f, c), _ = 1 - Es(e, f, g), b = Es(s, g, h), m = 1 - Es(s, c, h), I.push(fs[l]), I.push(ds[l])) : 25 === l ? (E = 1 - Es(s, c, f), _ = Es(s, g, f), b = 1 - Es(e, h, g), m = Es(e, h, c), I.push(fs[l]), I.push(ds[l])) : 70 === l ? (k = 1 - Es(e, c, f), x = 1 - Es(s, f, g), w = 1 - Es(s, h, g), y = 1 - Es(e, c, h), I.push(gs[l]), I.push(ps[l])) : 100 === l ? (k = Es(s, f, c), x = Es(e, g, f), w = Es(e, g, h), y = Es(s, h, c), I.push(gs[l]), I.push(ps[l])) : 34 === l ? (0 === v ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)) : (E = Es(s, f, c), k = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)), I.push(fs[l]), I.push(gs[l]), I.push(ds[l]), I.push(ys[l])) : 35 === l ? (4 === v ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)) : (E = Es(s, f, c), k = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)), I.push(fs[l]), I.push(gs[l]), I.push(vs[l]), I.push(ys[l])) : 136 === l ? (0 === v ? (E = Es(s, f, c), k = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)) : (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)), I.push(fs[l]), I.push(gs[l]), I.push(ds[l]), I.push(ys[l])) : 153 === l ? (0 === v ? (E = Es(e, f, c), _ = 1 - Es(e, f, g), b = 1 - Es(e, h, g), m = Es(e, h, c)) : (E = 1 - Es(s, c, f), _ = Es(s, g, f), b = Es(s, g, h), m = 1 - Es(s, c, h)), I.push(fs[l]), I.push(vs[l])) : 102 === l ? (0 === v ? (k = 1 - Es(e, c, f), x = Es(e, g, f), w = Es(e, g, h), y = 1 - Es(e, c, h)) : (k = Es(s, f, c), x = 1 - Es(s, f, g), w = 1 - Es(s, h, g), y = Es(s, h, c)), I.push(gs[l]), I.push(ys[l])) : 155 === l ? (4 === v ? (E = Es(e, f, c), _ = 1 - Es(e, f, g), b = 1 - Es(e, h, g), m = Es(e, h, c)) : (E = 1 - Es(s, c, f), _ = Es(s, g, f), b = Es(s, g, h), m = 1 - Es(s, c, h)), I.push(fs[l]), I.push(ds[l])) : 103 === l ? (4 === v ? (k = 1 - Es(e, c, f), x = Es(e, g, f), w = Es(e, g, h), y = 1 - Es(e, c, h)) : (k = Es(s, f, c), x = 1 - Es(s, f, g), w = 1 - Es(s, h, g), y = Es(s, h, c)), I.push(gs[l]), I.push(ps[l])) : 152 === l ? (0 === v ? (E = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), m = Es(e, h, c)) : (E = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), m = 1 - Es(s, c, h)), I.push(fs[l]), I.push(ps[l]), I.push(vs[l])) : 156 === l ? (4 === v ? (E = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), m = Es(e, h, c)) : (E = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), m = 1 - Es(s, c, h)), I.push(fs[l]), I.push(vs[l]), I.push(ys[l])) : 137 === l ? (0 === v ? (E = Es(s, f, c), k = Es(e, f, c), _ = 1 - Es(e, f, g), b = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)) : (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), _ = Es(s, g, f), b = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)), I.push(fs[l]), I.push(gs[l]), I.push(vs[l])) : 139 === l ? (4 === v ? (E = Es(s, f, c), k = Es(e, f, c), _ = 1 - Es(e, f, g), b = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)) : (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), _ = Es(s, g, f), b = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)), I.push(fs[l]), I.push(gs[l]), I.push(ds[l])) : 98 === l ? (0 === v ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), w = Es(e, g, h), y = 1 - Es(e, c, h)) : (E = Es(s, f, c), k = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), w = 1 - Es(s, h, g), y = Es(s, h, c)), I.push(fs[l]), I.push(gs[l]), I.push(ys[l])) : 99 === l ? (4 === v ? (E = 1 - Es(e, c, f), k = 1 - Es(s, c, f), x = Es(s, g, f), _ = Es(e, g, f), w = Es(e, g, h), y = 1 - Es(e, c, h)) : (E = Es(s, f, c), k = Es(e, f, c), x = 1 - Es(e, f, g), _ = 1 - Es(s, f, g), w = 1 - Es(s, h, g), y = Es(s, h, c)), I.push(fs[l]), I.push(gs[l]), I.push(vs[l])) : 38 === l ? (0 === v ? (k = 1 - Es(e, c, f), x = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)) : (k = Es(s, f, c), x = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)), I.push(gs[l]), I.push(ds[l]), I.push(ys[l])) : 39 === l ? (4 === v ? (k = 1 - Es(e, c, f), x = Es(e, g, f), b = Es(e, g, h), w = Es(s, g, h), y = 1 - Es(s, c, h), m = 1 - Es(e, c, h)) : (k = Es(s, f, c), x = 1 - Es(s, f, g), b = 1 - Es(s, h, g), w = 1 - Es(e, h, g), y = Es(e, h, c), m = Es(s, h, c)), I.push(gs[l]), I.push(ps[l]), I.push(ys[l])) : 85 === l && (E = 1, k = 0, x = 1, _ = 0, b = 0, w = 1, y = 0, m = 1), (y < 0 || y > 1 || m < 0 || m > 1 || E < 0 || E > 1 || x < 0 || x > 1 || b < 0 || b > 1 || w < 0 || w > 1) && console.log("MarchingSquaresJS-isoBands: " + l + " " + p + " " + h + "," + c + "," + f + "," + g + " " + v + " " + y + " " + m + " " + E + " " + k + " " + x + " " + _ + " " + b + " " + w), o.cells[a][u] = {
                                cval: l,
                                cval_real: p,
                                flipped: v,
                                topleft: y,
                                topright: m,
                                righttop: E,
                                rightbottom: k,
                                bottomright: x,
                                bottomleft: _,
                                leftbottom: b,
                                lefttop: w,
                                edges: I
                            }
                        }
                    }
                }
            }
            return o
        }(t, n, r);
        return Lo.polygons ? (Lo.verbose && console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell"), l = function (t) {
            var n = [], r = 0;
            return t.cells.forEach((function (t, i) {
                t.forEach((function (t, o) {
                    if (void 0 !== t) {
                        var s = xs[t.cval](t);
                        "object" === e(s) && ks(s) ? "object" === e(s[0]) && ks(s[0]) ? "object" === e(s[0][0]) && ks(s[0][0]) ? s.forEach((function (t) {
                            t.forEach((function (t) {
                                t[0] += o, t[1] += i
                            })), n[r++] = t
                        })) : (s.forEach((function (t) {
                            t[0] += o, t[1] += i
                        })), n[r++] = s) : console.log("MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates") : console.log("MarchingSquaresJS-isoBands: bandcell polygon with null coordinates")
                    }
                }))
            })), n
        }(h)) : (Lo.verbose && console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"), l = function (t) {
            for (var e = [], n = t.rows, r = t.cols, i = [], o = 0; o < n; o++) for (var s = 0; s < r; s++) if (void 0 !== t.cells[o][s] && t.cells[o][s].edges.length > 0) {
                var a = bs(t.cells[o][s]), u = null, l = s, h = o;
                null !== a && i.push([a.p[0] + l, a.p[1] + h]);
                do {
                    if (null === (u = Is(t.cells[h][l], a.x, a.y, a.o))) break;
                    if (i.push([u.p[0] + l, u.p[1] + h]), l += u.x, a = u, (h += u.y) < 0 || h >= n || l < 0 || l >= r || void 0 === t.cells[h][l]) {
                        var c = ws(t, l -= u.x, h -= u.y, u.x, u.y, u.o);
                        if (null === c) break;
                        c.path.forEach((function (t) {
                            i.push(t)
                        })), l = c.i, h = c.j, a = c
                    }
                } while (void 0 !== t.cells[h][l] && t.cells[h][l].edges.length > 0);
                e.push(i), i = [], t.cells[o][s].edges.length > 0 && s--
            }
            return e
        }(h)), "function" == typeof Lo.successCallback && Lo.successCallback(l), l
    }

    var Ro = 64, To = 16, Oo = [], Ao = [], Do = [], Fo = [], qo = [], Go = [], Yo = [], Bo = [], zo = [], Xo = [],
        jo = [], Uo = [], Vo = [], Zo = [], Ho = [], Wo = [], Jo = [], Qo = [], Ko = [], $o = [], ts = [], es = [],
        ns = [], rs = [];
    Yo[85] = Xo[85] = -1, Bo[85] = jo[85] = 0, zo[85] = Uo[85] = 1, Ko[85] = es[85] = 1, $o[85] = ns[85] = 0, ts[85] = rs[85] = 1, Oo[85] = Fo[85] = 0, Ao[85] = qo[85] = -1, Do[85] = Ho[85] = 0, Wo[85] = Vo[85] = 0, Jo[85] = Zo[85] = 1, Go[85] = Qo[85] = 1, es[1] = es[169] = 0, ns[1] = ns[169] = -1, rs[1] = rs[169] = 0, Vo[1] = Vo[169] = -1, Zo[1] = Zo[169] = 0, Ho[1] = Ho[169] = 0, Xo[4] = Xo[166] = 0, jo[4] = jo[166] = -1, Uo[4] = Uo[166] = 1, Wo[4] = Wo[166] = 1, Jo[4] = Jo[166] = 0, Qo[4] = Qo[166] = 0, Yo[16] = Yo[154] = 0, Bo[16] = Bo[154] = 1, zo[16] = zo[154] = 1, Fo[16] = Fo[154] = 1, qo[16] = qo[154] = 0, Go[16] = Go[154] = 1, Ko[64] = Ko[106] = 0, $o[64] = $o[106] = 1, ts[64] = ts[106] = 0, Oo[64] = Oo[106] = -1, Ao[64] = Ao[106] = 0, Do[64] = Do[106] = 1, Ko[2] = Ko[168] = 0, $o[2] = $o[168] = -1, ts[2] = ts[168] = 1, es[2] = es[168] = 0, ns[2] = ns[168] = -1, rs[2] = rs[168] = 0, Vo[2] = Vo[168] = -1, Zo[2] = Zo[168] = 0, Ho[2] = Ho[168] = 0, Wo[2] = Wo[168] = -1, Jo[2] = Jo[168] = 0, Qo[2] = Qo[168] = 1, Yo[8] = Yo[162] = 0, Bo[8] = Bo[162] = -1, zo[8] = zo[162] = 0, Xo[8] = Xo[162] = 0, jo[8] = jo[162] = -1, Uo[8] = Uo[162] = 1, Vo[8] = Vo[162] = 1, Zo[8] = Zo[162] = 0, Ho[8] = Ho[162] = 1, Wo[8] = Wo[162] = 1, Jo[8] = Jo[162] = 0, Qo[8] = Qo[162] = 0, Yo[32] = Yo[138] = 0, Bo[32] = Bo[138] = 1, zo[32] = zo[138] = 1, Xo[32] = Xo[138] = 0, jo[32] = jo[138] = 1, Uo[32] = Uo[138] = 0, Oo[32] = Oo[138] = 1, Ao[32] = Ao[138] = 0, Do[32] = Do[138] = 0, Fo[32] = Fo[138] = 1, qo[32] = qo[138] = 0, Go[32] = Go[138] = 1, es[128] = es[42] = 0, ns[128] = ns[42] = 1, rs[128] = rs[42] = 1, Ko[128] = Ko[42] = 0, $o[128] = $o[42] = 1, ts[128] = ts[42] = 0, Oo[128] = Oo[42] = -1, Ao[128] = Ao[42] = 0, Do[128] = Do[42] = 1, Fo[128] = Fo[42] = -1, qo[128] = qo[42] = 0, Go[128] = Go[42] = 0, Xo[5] = Xo[165] = -1, jo[5] = jo[165] = 0, Uo[5] = Uo[165] = 0, es[5] = es[165] = 1, ns[5] = ns[165] = 0, rs[5] = rs[165] = 0, Wo[20] = Wo[150] = 0, Jo[20] = Jo[150] = 1, Qo[20] = Qo[150] = 1, Fo[20] = Fo[150] = 0, qo[20] = qo[150] = -1, Go[20] = Go[150] = 1, Yo[80] = Yo[90] = -1, Bo[80] = Bo[90] = 0, zo[80] = zo[90] = 1, Ko[80] = Ko[90] = 1, $o[80] = $o[90] = 0,ts[80] = ts[90] = 1,Vo[65] = Vo[105] = 0,Zo[65] = Zo[105] = 1,Ho[65] = Ho[105] = 0,Oo[65] = Oo[105] = 0,Ao[65] = Ao[105] = -1,Do[65] = Do[105] = 0,Yo[160] = Yo[10] = -1,Bo[160] = Bo[10] = 0,zo[160] = zo[10] = 1,Xo[160] = Xo[10] = -1,jo[160] = jo[10] = 0,Uo[160] = Uo[10] = 0,es[160] = es[10] = 1,ns[160] = ns[10] = 0,rs[160] = rs[10] = 0,Ko[160] = Ko[10] = 1,$o[160] = $o[10] = 0,ts[160] = ts[10] = 1,Wo[130] = Wo[40] = 0,Jo[130] = Jo[40] = 1,Qo[130] = Qo[40] = 1,Vo[130] = Vo[40] = 0,Zo[130] = Zo[40] = 1,Ho[130] = Ho[40] = 0,Oo[130] = Oo[40] = 0,Ao[130] = Ao[40] = -1,Do[130] = Do[40] = 0,Fo[130] = Fo[40] = 0,qo[130] = qo[40] = -1,Go[130] = Go[40] = 1,Xo[37] = Xo[133] = 0,jo[37] = jo[133] = 1,Uo[37] = Uo[133] = 1,es[37] = es[133] = 0,ns[37] = ns[133] = 1,rs[37] = rs[133] = 0,Oo[37] = Oo[133] = -1,Ao[37] = Ao[133] = 0,Do[37] = Do[133] = 0,Fo[37] = Fo[133] = 1,qo[37] = qo[133] = 0,Go[37] = Go[133] = 0,Wo[148] = Wo[22] = -1,Jo[148] = Jo[22] = 0,Qo[148] = Qo[22] = 0,es[148] = es[22] = 0,ns[148] = ns[22] = -1,rs[148] = rs[22] = 1,Ko[148] = Ko[22] = 0,$o[148] = $o[22] = 1,ts[148] = ts[22] = 1,Fo[148] = Fo[22] = -1,qo[148] = qo[22] = 0,Go[148] = Go[22] = 1,Yo[82] = Yo[88] = 0,Bo[82] = Bo[88] = -1,zo[82] = zo[88] = 1,Wo[82] = Wo[88] = 1,Jo[82] = Jo[88] = 0,Qo[82] = Qo[88] = 1,Vo[82] = Vo[88] = -1,Zo[82] = Zo[88] = 0,Ho[82] = Ho[88] = 1,Ko[82] = Ko[88] = 0,$o[82] = $o[88] = -1,ts[82] = ts[88] = 0,Yo[73] = Yo[97] = 0,Bo[73] = Bo[97] = 1,zo[73] = zo[97] = 0,Xo[73] = Xo[97] = 0,jo[73] = jo[97] = -1,Uo[73] = Uo[97] = 0,Vo[73] = Vo[97] = 1,Zo[73] = Zo[97] = 0,Ho[73] = Ho[97] = 0,Oo[73] = Oo[97] = 1,Ao[73] = Ao[97] = 0,Do[73] = Do[97] = 1,Yo[145] = Yo[25] = 0,Bo[145] = Bo[25] = -1,zo[145] = zo[25] = 0,Vo[145] = Vo[25] = 1,Zo[145] = Zo[25] = 0,Ho[145] = Ho[25] = 1,es[145] = es[25] = 0,ns[145] = ns[25] = 1,rs[145] = rs[25] = 1,Fo[145] = Fo[25] = -1,qo[145] = qo[25] = 0,Go[145] = Go[25] = 0,Xo[70] = Xo[100] = 0,jo[70] = jo[100] = 1,Uo[70] = Uo[100] = 0,Wo[70] = Wo[100] = -1,Jo[70] = Jo[100] = 0,Qo[70] = Qo[100] = 1,Ko[70] = Ko[100] = 0,$o[70] = $o[100] = -1,ts[70] = ts[100] = 1,Oo[70] = Oo[100] = 1,Ao[70] = Ao[100] = 0,Do[70] = Do[100] = 0,Xo[101] = Xo[69] = 0,jo[101] = jo[69] = 1,Uo[101] = Uo[69] = 0,Oo[101] = Oo[69] = 1,Ao[101] = Ao[69] = 0,Do[101] = Do[69] = 0,es[149] = es[21] = 0,ns[149] = ns[21] = 1,rs[149] = rs[21] = 1,Fo[149] = Fo[21] = -1,qo[149] = qo[21] = 0,Go[149] = Go[21] = 0,Wo[86] = Wo[84] = -1,Jo[86] = Jo[84] = 0,Qo[86] = Qo[84] = 1,Ko[86] = Ko[84] = 0,$o[86] = $o[84] = -1,ts[86] = ts[84] = 1,Yo[89] = Yo[81] = 0,Bo[89] = Bo[81] = -1,zo[89] = zo[81] = 0,Vo[89] = Vo[81] = 1,Zo[89] = Zo[81] = 0,Ho[89] = Ho[81] = 1,Yo[96] = Yo[74] = 0,Bo[96] = Bo[74] = 1,zo[96] = zo[74] = 0,Xo[96] = Xo[74] = -1,jo[96] = jo[74] = 0,Uo[96] = Uo[74] = 1,Ko[96] = Ko[74] = 1,$o[96] = $o[74] = 0,ts[96] = ts[74] = 0,Oo[96] = Oo[74] = 1,Ao[96] = Ao[74] = 0,Do[96] = Do[74] = 1,Yo[24] = Yo[146] = 0,Bo[24] = Bo[146] = -1,zo[24] = zo[146] = 1,Wo[24] = Wo[146] = 1,Jo[24] = Jo[146] = 0,Qo[24] = Qo[146] = 1,Vo[24] = Vo[146] = 0,Zo[24] = Zo[146] = 1,Ho[24] = Ho[146] = 1,Fo[24] = Fo[146] = 0,qo[24] = qo[146] = -1,Go[24] = Go[146] = 0,Xo[6] = Xo[164] = -1,jo[6] = jo[164] = 0,Uo[6] = Uo[164] = 1,Wo[6] = Wo[164] = -1,Jo[6] = Jo[164] = 0,Qo[6] = Qo[164] = 0,es[6] = es[164] = 0,ns[6] = ns[164] = -1,rs[6] = rs[164] = 1,Ko[6] = Ko[164] = 1,$o[6] = $o[164] = 0,ts[6] = ts[164] = 0,Vo[129] = Vo[41] = 0,Zo[129] = Zo[41] = 1,Ho[129] = Ho[41] = 1,es[129] = es[41] = 0,ns[129] = ns[41] = 1,rs[129] = rs[41] = 0,Oo[129] = Oo[41] = -1,Ao[129] = Ao[41] = 0,Do[129] = Do[41] = 0,Fo[129] = Fo[41] = 0,qo[129] = qo[41] = -1,Go[129] = Go[41] = 0,Wo[66] = Wo[104] = 0,Jo[66] = Jo[104] = 1,Qo[66] = Qo[104] = 0,Vo[66] = Vo[104] = -1,Zo[66] = Zo[104] = 0,Ho[66] = Ho[104] = 1,Ko[66] = Ko[104] = 0,$o[66] = $o[104] = -1,ts[66] = ts[104] = 0,Oo[66] = Oo[104] = 0,Ao[66] = Ao[104] = -1,Do[66] = Do[104] = 1,Yo[144] = Yo[26] = -1,Bo[144] = Bo[26] = 0,zo[144] = zo[26] = 0,es[144] = es[26] = 1,ns[144] = ns[26] = 0,rs[144] = rs[26] = 1,Ko[144] = Ko[26] = 0,$o[144] = $o[26] = 1,ts[144] = ts[26] = 1,Fo[144] = Fo[26] = -1,qo[144] = qo[26] = 0,Go[144] = Go[26] = 1,Xo[36] = Xo[134] = 0,jo[36] = jo[134] = 1,Uo[36] = Uo[134] = 1,Wo[36] = Wo[134] = 0,Jo[36] = Jo[134] = 1,Qo[36] = Qo[134] = 0,Oo[36] = Oo[134] = 0,Ao[36] = Ao[134] = -1,Do[36] = Do[134] = 1,Fo[36] = Fo[134] = 1,qo[36] = qo[134] = 0,Go[36] = Go[134] = 0,Yo[9] = Yo[161] = -1,Bo[9] = Bo[161] = 0,zo[9] = zo[161] = 0,Xo[9] = Xo[161] = 0,jo[9] = jo[161] = -1,Uo[9] = Uo[161] = 0,Vo[9] = Vo[161] = 1,Zo[9] = Zo[161] = 0,Ho[9] = Ho[161] = 0,es[9] = es[161] = 1,ns[9] = ns[161] = 0,rs[9] = rs[161] = 1,Yo[136] = 0,Bo[136] = 1,zo[136] = 1,Xo[136] = 0,jo[136] = 1,Uo[136] = 0,Wo[136] = -1,Jo[136] = 0,Qo[136] = 1,Vo[136] = -1,Zo[136] = 0,Ho[136] = 0,es[136] = 0,ns[136] = -1,rs[136] = 0,Ko[136] = 0,$o[136] = -1,ts[136] = 1,Oo[136] = 1,Ao[136] = 0,Do[136] = 0,Fo[136] = 1,qo[136] = 0,Go[136] = 1,Yo[34] = 0,Bo[34] = -1,zo[34] = 0,Xo[34] = 0,jo[34] = -1,Uo[34] = 1,Wo[34] = 1,Jo[34] = 0,Qo[34] = 0,Vo[34] = 1,Zo[34] = 0,Ho[34] = 1,es[34] = 0,ns[34] = 1,rs[34] = 1,Ko[34] = 0,$o[34] = 1,ts[34] = 0,Oo[34] = -1,Ao[34] = 0,Do[34] = 1,Fo[34] = -1,qo[34] = 0,Go[34] = 0,Yo[35] = 0,Bo[35] = 1,zo[35] = 1,Xo[35] = 0,jo[35] = -1,Uo[35] = 1,Wo[35] = 1,Jo[35] = 0,Qo[35] = 0,Vo[35] = -1,Zo[35] = 0,Ho[35] = 0,es[35] = 0,ns[35] = -1,rs[35] = 0,Ko[35] = 0,$o[35] = 1,ts[35] = 0,Oo[35] = -1,Ao[35] = 0,Do[35] = 1,Fo[35] = 1,qo[35] = 0,Go[35] = 1,Yo[153] = 0,Bo[153] = 1,zo[153] = 1,Vo[153] = -1,Zo[153] = 0,Ho[153] = 0,es[153] = 0,ns[153] = -1,rs[153] = 0,Fo[153] = 1,qo[153] = 0,Go[153] = 1,Xo[102] = 0,jo[102] = -1,Uo[102] = 1,Wo[102] = 1,Jo[102] = 0,Qo[102] = 0,Ko[102] = 0,$o[102] = 1,ts[102] = 0,Oo[102] = -1,Ao[102] = 0,Do[102] = 1,Yo[155] = 0,Bo[155] = -1,zo[155] = 0,Vo[155] = 1,Zo[155] = 0,Ho[155] = 1,es[155] = 0,ns[155] = 1,rs[155] = 1,Fo[155] = -1,qo[155] = 0,Go[155] = 0,Xo[103] = 0,jo[103] = 1,Uo[103] = 0,Wo[103] = -1,Jo[103] = 0,Qo[103] = 1,Ko[103] = 0,$o[103] = -1,ts[103] = 1,Oo[103] = 1,Ao[103] = 0,Do[103] = 0,Yo[152] = 0,Bo[152] = 1,zo[152] = 1,Wo[152] = -1,Jo[152] = 0,Qo[152] = 1,Vo[152] = -1,Zo[152] = 0,Ho[152] = 0,es[152] = 0,ns[152] = -1,rs[152] = 0,Ko[152] = 0,$o[152] = -1,ts[152] = 1,Fo[152] = 1,qo[152] = 0,Go[152] = 1,Yo[156] = 0,Bo[156] = -1,zo[156] = 1,Wo[156] = 1,Jo[156] = 0,Qo[156] = 1,Vo[156] = -1,Zo[156] = 0,Ho[156] = 0,es[156] = 0,ns[156] = -1,rs[156] = 0,Ko[156] = 0,$o[156] = 1,ts[156] = 1,Fo[156] = -1,qo[156] = 0,Go[156] = 1,Yo[137] = 0,Bo[137] = 1,zo[137] = 1,Xo[137] = 0,jo[137] = 1,Uo[137] = 0,Vo[137] = -1,Zo[137] = 0,Ho[137] = 0,es[137] = 0,ns[137] = -1,rs[137] = 0,Oo[137] = 1,Ao[137] = 0,Do[137] = 0,Fo[137] = 1,qo[137] = 0,Go[137] = 1,Yo[139] = 0,Bo[139] = 1,zo[139] = 1,Xo[139] = 0,jo[139] = -1,Uo[139] = 0,Vo[139] = 1,Zo[139] = 0,Ho[139] = 0,es[139] = 0,ns[139] = 1,rs[139] = 0,Oo[139] = -1,Ao[139] = 0,Do[139] = 0,Fo[139] = 1,qo[139] = 0,Go[139] = 1,Yo[98] = 0,Bo[98] = -1,zo[98] = 0,Xo[98] = 0,jo[98] = -1,Uo[98] = 1,Wo[98] = 1,Jo[98] = 0,Qo[98] = 0,Vo[98] = 1,Zo[98] = 0,Ho[98] = 1,Ko[98] = 0,$o[98] = 1,ts[98] = 0,Oo[98] = -1,Ao[98] = 0,Do[98] = 1,Yo[99] = 0,Bo[99] = 1,zo[99] = 0,Xo[99] = 0,jo[99] = -1,Uo[99] = 1,Wo[99] = 1,Jo[99] = 0,Qo[99] = 0,Vo[99] = -1,Zo[99] = 0,Ho[99] = 1,Ko[99] = 0,$o[99] = -1,ts[99] = 0,Oo[99] = 1,Ao[99] = 0,Do[99] = 1,Xo[38] = 0,jo[38] = -1,Uo[38] = 1,Wo[38] = 1,Jo[38] = 0,Qo[38] = 0,es[38] = 0,ns[38] = 1,rs[38] = 1,Ko[38] = 0,$o[38] = 1,ts[38] = 0,Oo[38] = -1,Ao[38] = 0,Do[38] = 1,Fo[38] = -1,qo[38] = 0,Go[38] = 0,Xo[39] = 0,jo[39] = 1,Uo[39] = 1,Wo[39] = -1,Jo[39] = 0,Qo[39] = 0,es[39] = 0,ns[39] = -1,rs[39] = 1,Ko[39] = 0,$o[39] = 1,ts[39] = 0,Oo[39] = -1,Ao[39] = 0,Do[39] = 1,Fo[39] = 1,qo[39] = 0,Go[39] = 0;
    var is = function (t) {
        return [[t.bottomleft, 0], [0, 0], [0, t.leftbottom]]
    }, os = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0]]
    }, ss = function (t) {
        return [[t.topright, 1], [1, 1], [1, t.righttop]]
    }, as = function (t) {
        return [[0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, us = function (t) {
        return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop]]
    }, ls = function (t) {
        return [[t.bottomright, 0], [t.bottomleft, 0], [1, t.righttop], [1, t.rightbottom]]
    }, hs = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.topleft, 1], [t.topright, 1]]
    }, cs = function (t) {
        return [[0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
    }, fs = [], gs = [], ps = [], vs = [], ds = [], ys = [], ms = [], _s = [];
    vs[1] = ds[1] = 18, vs[169] = ds[169] = 18, ps[4] = gs[4] = 12, ps[166] = gs[166] = 12, fs[16] = _s[16] = 4, fs[154] = _s[154] = 4, ys[64] = ms[64] = 22, ys[106] = ms[106] = 22, ps[2] = ys[2] = 17, vs[2] = ds[2] = 18, ps[168] = ys[168] = 17, vs[168] = ds[168] = 18, fs[8] = vs[8] = 9, gs[8] = ps[8] = 12, fs[162] = vs[162] = 9, gs[162] = ps[162] = 12, fs[32] = _s[32] = 4, gs[32] = ms[32] = 1, fs[138] = _s[138] = 4, gs[138] = ms[138] = 1, ds[128] = _s[128] = 21, ys[128] = ms[128] = 22, ds[42] = _s[42] = 21, ys[42] = ms[42] = 22, gs[5] = ds[5] = 14, gs[165] = ds[165] = 14, ps[20] = _s[20] = 6, ps[150] = _s[150] = 6, fs[80] = ys[80] = 11, fs[90] = ys[90] = 11, vs[65] = ms[65] = 3, vs[105] = ms[105] = 3, fs[160] = ys[160] = 11, gs[160] = ds[160] = 14, fs[10] = ys[10] = 11, gs[10] = ds[10] = 14, ps[130] = _s[130] = 6, vs[130] = ms[130] = 3, ps[40] = _s[40] = 6, vs[40] = ms[40] = 3, gs[101] = ms[101] = 1, gs[69] = ms[69] = 1, ds[149] = _s[149] = 21, ds[21] = _s[21] = 21, ps[86] = ys[86] = 17, ps[84] = ys[84] = 17, fs[89] = vs[89] = 9, fs[81] = vs[81] = 9, fs[96] = ms[96] = 0, gs[96] = ys[96] = 15, fs[74] = ms[74] = 0, gs[74] = ys[74] = 15, fs[24] = ps[24] = 8, vs[24] = _s[24] = 7, fs[146] = ps[146] = 8, vs[146] = _s[146] = 7, gs[6] = ys[6] = 15, ps[6] = ds[6] = 16, gs[164] = ys[164] = 15, ps[164] = ds[164] = 16, vs[129] = _s[129] = 7, ds[129] = ms[129] = 20, vs[41] = _s[41] = 7, ds[41] = ms[41] = 20, ps[66] = ms[66] = 2, vs[66] = ys[66] = 19, ps[104] = ms[104] = 2, vs[104] = ys[104] = 19, fs[144] = ds[144] = 10, ys[144] = _s[144] = 23, fs[26] = ds[26] = 10, ys[26] = _s[26] = 23, gs[36] = _s[36] = 5, ps[36] = ms[36] = 2, gs[134] = _s[134] = 5, ps[134] = ms[134] = 2, fs[9] = ds[9] = 10, gs[9] = vs[9] = 13, fs[161] = ds[161] = 10, gs[161] = vs[161] = 13, gs[37] = _s[37] = 5, ds[37] = ms[37] = 20, gs[133] = _s[133] = 5, ds[133] = ms[133] = 20, ps[148] = ds[148] = 16, ys[148] = _s[148] = 23, ps[22] = ds[22] = 16, ys[22] = _s[22] = 23, fs[82] = ps[82] = 8, vs[82] = ys[82] = 19, fs[88] = ps[88] = 8, vs[88] = ys[88] = 19, fs[73] = ms[73] = 0, gs[73] = vs[73] = 13, fs[97] = ms[97] = 0, gs[97] = vs[97] = 13, fs[145] = vs[145] = 9, ds[145] = _s[145] = 21, fs[25] = vs[25] = 9, ds[25] = _s[25] = 21, gs[70] = ms[70] = 1,ps[70] = ys[70] = 17,gs[100] = ms[100] = 1,ps[100] = ys[100] = 17,fs[34] = vs[34] = 9,gs[34] = ps[34] = 12,ds[34] = _s[34] = 21,ys[34] = ms[34] = 22,fs[136] = _s[136] = 4,gs[136] = ms[136] = 1,ps[136] = ys[136] = 17,vs[136] = ds[136] = 18,fs[35] = _s[35] = 4,gs[35] = ps[35] = 12,vs[35] = ds[35] = 18,ys[35] = ms[35] = 22,fs[153] = _s[153] = 4,vs[153] = ds[153] = 18,gs[102] = ps[102] = 12,ys[102] = ms[102] = 22,fs[155] = vs[155] = 9,ds[155] = _s[155] = 23,gs[103] = ms[103] = 1,ps[103] = ys[103] = 17,fs[152] = _s[152] = 4,ps[152] = ys[152] = 17,vs[152] = ds[152] = 18,fs[156] = ps[156] = 8,vs[156] = ds[156] = 18,ys[156] = _s[156] = 23,fs[137] = _s[137] = 4,gs[137] = ms[137] = 1,vs[137] = ds[137] = 18,fs[139] = _s[139] = 4,gs[139] = vs[139] = 13,ds[139] = ms[139] = 20,fs[98] = vs[98] = 9,gs[98] = ps[98] = 12,ys[98] = ms[98] = 22,fs[99] = ms[99] = 0,gs[99] = ps[99] = 12,vs[99] = ys[99] = 19,gs[38] = ps[38] = 12,ds[38] = _s[38] = 21,ys[38] = ms[38] = 22,gs[39] = _s[39] = 5,ps[39] = ds[39] = 16,ys[39] = ms[39] = 22;
    var xs = [];

    function Es(t, e, n) {
        return (t - e) / (n - e)
    }

    function ks(t) {
        return t.constructor.toString().indexOf("Array") > -1
    }

    function ws(t, e, n, r, i, o) {
        for (var s = t.cells[n][e], a = s.cval_real, u = e + r, l = n + i, h = [], c = !1; !c;) {
            if (void 0 === t.cells[l] || void 0 === t.cells[l][u]) if (l -= i, u -= r, a = (s = t.cells[l][u]).cval_real, -1 === i) if (0 === o) if (1 & a) h.push([u, l]), r = -1, i = 0, o = 0; else {
                if (!(4 & a)) {
                    h.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, c = !0;
                    break
                }
                h.push([u + 1, l]), r = 1, i = 0, o = 0
            } else {
                if (!(1 & a)) {
                    if (4 & a) {
                        h.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, c = !0;
                        break
                    }
                    h.push([u + s.bottomleft, l]), r = 0, i = 1, o = 0, c = !0;
                    break
                }
                h.push([u, l]), r = -1, i = 0, o = 0
            } else if (1 === i) if (0 === o) {
                if (!(a & To)) {
                    if (a & Ro) {
                        h.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, c = !0;
                        break
                    }
                    h.push([u + s.topright, l + 1]), r = 0, i = -1, o = 1, c = !0;
                    break
                }
                h.push([u + 1, l + 1]), r = 1, i = 0, o = 1
            } else h.push([u + 1, l + 1]), r = 1, i = 0, o = 1; else if (-1 === r) if (0 === o) {
                if (!(a & Ro)) {
                    if (1 & a) {
                        h.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, c = !0;
                        break
                    }
                    h.push([u, l + s.lefttop]), r = 1, i = 0, o = 1, c = !0;
                    break
                }
                h.push([u, l + 1]), r = 0, i = 1, o = 0
            } else {
                if (!(a & Ro)) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                h.push([u, l + 1]), r = 0, i = 1, o = 0
            } else {
                if (1 !== r) {
                    console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
                    break
                }
                if (0 === o) {
                    if (!(4 & a)) {
                        h.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, c = !0;
                        break
                    }
                    h.push([u + 1, l]), r = 0, i = -1, o = 1
                } else {
                    if (!(4 & a)) {
                        if (a & To) {
                            h.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1;
                            break
                        }
                        h.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, c = !0;
                        break
                    }
                    h.push([u + 1, l]), r = 0, i = -1, o = 1
                }
            } else if (a = (s = t.cells[l][u]).cval_real, -1 === r) if (0 === o) if (void 0 !== t.cells[l - 1] && void 0 !== t.cells[l - 1][u]) r = 0, i = -1, o = 1; else {
                if (!(1 & a)) {
                    h.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, c = !0;
                    break
                }
                h.push([u, l])
            } else {
                if (!(a & Ro)) {
                    console.log("MarchingSquaresJS-isoBands: found entry from top at " + u + "," + l);
                    break
                }
                console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!")
            } else if (1 === r) {
                if (0 === o) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                if (void 0 !== t.cells[l + 1] && void 0 !== t.cells[l + 1][u]) r = 0, i = 1, o = 0; else {
                    if (!(a & To)) {
                        h.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, c = !0;
                        break
                    }
                    h.push([u + 1, l + 1]), r = 1, i = 0, o = 1
                }
            } else if (-1 === i) {
                if (1 !== o) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                if (void 0 !== t.cells[l][u + 1]) r = 1, i = 0, o = 1; else {
                    if (!(4 & a)) {
                        h.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1, c = !0;
                        break
                    }
                    h.push([u + 1, l]), r = 0, i = -1, o = 1
                }
            } else {
                if (1 !== i) {
                    console.log("MarchingSquaresJS-isoBands: where did we came from???");
                    break
                }
                if (0 !== o) {
                    console.log("MarchingSquaresJS-isoBands: wtf");
                    break
                }
                if (void 0 !== t.cells[l][u - 1]) r = -1, i = 0, o = 0; else {
                    if (!(a & Ro)) {
                        h.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, c = !0;
                        break
                    }
                    h.push([u, l + 1]), r = 0, i = 1, o = 0
                }
            }
            if (l += i, (u += r) === e && l === n) break
        }
        return {path: h, i: u, j: l, x: r, y: i, o: o}
    }

    function bs(t) {
        if (t.edges.length > 0) {
            var e = t.edges[t.edges.length - 1], n = t.cval_real;
            switch (e) {
                case 0:
                    return n & To ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [t.topleft, 1], x: 0, y: -1, o: 0};
                case 1:
                    return 4 & n ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [1, t.rightbottom], x: -1, y: 0, o: 0};
                case 2:
                    return 4 & n ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [t.topleft, 1], x: 0, y: -1, o: 0};
                case 3:
                    return 1 & n ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 4:
                    return n & To ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                case 5:
                    return 4 & n ? {p: [t.topright, 1], x: 0, y: -1, o: 1} : {p: [1, t.rightbottom], x: -1, y: 0, o: 0};
                case 6:
                    return 4 & n ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                case 7:
                    return 1 & n ? {p: [t.topright, 1], x: 0, y: -1, o: 1} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 8:
                    return 4 & n ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [1, t.righttop], x: -1, y: 0, o: 1};
                case 9:
                    return 1 & n ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 10:
                    return 1 & n ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {p: [1, t.righttop], x: -1, y: 0, o: 1};
                case 11:
                    return n & Ro ? {p: [1, t.righttop], x: -1, y: 0, o: 1} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 12:
                    return 4 & n ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 13:
                    return 1 & n ? {p: [1, t.rightbottom], x: -1, y: 0, o: 0} : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 14:
                    return 1 & n ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 15:
                    return n & Ro ? {p: [1, t.rightbottom], x: -1, y: 0, o: 0} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 16:
                    return 4 & n ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [0, t.leftbottom], x: 1, y: 0, o: 0};
                case 17:
                    return n & Ro ? {p: [t.bottomright, 0], x: 0, y: 1, o: 1} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 18:
                    return 1 & n ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {p: [t.bottomleft, 0], x: 0, y: 1, o: 0};
                case 19:
                    return n & Ro ? {p: [t.bottomleft, 0], x: 0, y: 1, o: 0} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 20:
                    return n & Ro ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [0, t.leftbottom], x: 1, y: 0, o: 0};
                case 21:
                    return n & To ? {p: [0, t.leftbottom], x: 1, y: 0, o: 0} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                case 22:
                    return n & Ro ? {p: [t.topleft, 1], x: 0, y: -1, o: 0} : {p: [0, t.lefttop], x: 1, y: 0, o: 1};
                case 23:
                    return n & To ? {p: [0, t.lefttop], x: 1, y: 0, o: 1} : {p: [t.topright, 1], x: 0, y: -1, o: 1};
                default:
                    console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t)
            }
        }
        return null
    }

    function Is(t, e, n, r) {
        var i, o, s, a, u, l = t.cval;
        switch (e) {
            case-1:
                if (0 === r) i = gs[l], s = Xo[l], a = jo[l], u = Uo[l]; else i = fs[l], s = Yo[l], a = Bo[l], u = zo[l];
                break;
            case 1:
                if (0 === r) i = ds[l], s = es[l], a = ns[l], u = rs[l]; else i = ys[l], s = Ko[l], a = $o[l], u = ts[l];
                break;
            default:
                switch (n) {
                    case-1:
                        if (0 === r) i = ms[l], s = Oo[l], a = Ao[l], u = Do[l]; else i = _s[l], s = Fo[l], a = qo[l], u = Go[l];
                        break;
                    case 1:
                        if (0 === r) i = vs[l], s = Vo[l], a = Zo[l], u = Ho[l]; else i = ps[l], s = Wo[l], a = Jo[l], u = Qo[l]
                }
        }
        if (o = t.edges.indexOf(i), void 0 === t.edges[o]) return null;
        switch (function (t, e) {
            delete t.edges[e];
            for (var n = e + 1; n < t.edges.length; n++) t.edges[n - 1] = t.edges[n];
            t.edges.pop()
        }(t, o), l = t.cval_real, i) {
            case 0:
                l & To ? (e = t.topleft, n = 1) : (e = 1, n = t.righttop);
                break;
            case 1:
                4 & l ? (e = 1, n = t.rightbottom) : (e = t.topleft, n = 1);
                break;
            case 2:
                4 & l ? (e = t.topleft, n = 1) : (e = t.bottomright, n = 0);
                break;
            case 3:
                1 & l ? (e = t.bottomleft, n = 0) : (e = t.topleft, n = 1);
                break;
            case 4:
                l & To ? (e = t.topright, n = 1) : (e = 1, n = t.righttop);
                break;
            case 5:
                4 & l ? (e = 1, n = t.rightbottom) : (e = t.topright, n = 1);
                break;
            case 6:
                4 & l ? (e = t.topright, n = 1) : (e = t.bottomright, n = 0);
                break;
            case 7:
                1 & l ? (e = t.bottomleft, n = 0) : (e = t.topright, n = 1);
                break;
            case 8:
                4 & l ? (e = 1, n = t.righttop) : (e = t.bottomright, n = 0);
                break;
            case 9:
                1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.righttop);
                break;
            case 10:
                1 & l ? (e = 1, n = t.righttop) : (e = 0, n = t.leftbottom);
                break;
            case 11:
                l & Ro ? (e = 0, n = t.lefttop) : (e = 1, n = t.righttop);
                break;
            case 12:
                4 & l ? (e = 1, n = t.rightbottom) : (e = t.bottomright, n = 0);
                break;
            case 13:
                1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.rightbottom);
                break;
            case 14:
                1 & l ? (e = 1, n = t.rightbottom) : (e = 0, n = t.leftbottom);
                break;
            case 15:
                l & Ro ? (e = 0, n = t.lefttop) : (e = 1, n = t.rightbottom);
                break;
            case 16:
                4 & l ? (e = 0, n = t.leftbottom) : (e = t.bottomright, n = 0);
                break;
            case 17:
                l & Ro ? (e = 0, n = t.lefttop) : (e = t.bottomright, n = 0);
                break;
            case 18:
                1 & l ? (e = t.bottomleft, n = 0) : (e = 0, n = t.leftbottom);
                break;
            case 19:
                l & Ro ? (e = 0, n = t.lefttop) : (e = t.bottomleft, n = 0);
                break;
            case 20:
                l & Ro ? (e = 0, n = t.leftbottom) : (e = t.topleft, n = 1);
                break;
            case 21:
                l & To ? (e = t.topright, n = 1) : (e = 0, n = t.leftbottom);
                break;
            case 22:
                l & Ro ? (e = 0, n = t.lefttop) : (e = t.topleft, n = 1);
                break;
            case 23:
                l & To ? (e = t.topright, n = 1) : (e = 0, n = t.lefttop);
                break;
            default:
                return console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t), null
        }
        return void 0 !== e && void 0 !== n && void 0 !== s && void 0 !== a && void 0 !== u || (console.log("MarchingSquaresJS-isoBands: undefined value!"), console.log(t), console.log(e + " " + n + " " + s + " " + a + " " + u)), {
            p: [e, n],
            x: s,
            y: a,
            o: u
        }
    }

    function Ss(t) {
        var e = [], n = [];
        t.forEach((function (t) {
            var r = Ar(m([t]));
            n.push(r), e.push({ring: t, area: r})
        })), n.sort((function (t, e) {
            return e - t
        }));
        var r = [];
        return n.forEach((function (t) {
            for (var n = 0; n < e.length; n++) if (e[n].area === t) {
                r.push(e[n].ring), e.splice(n, 1);
                break
            }
        })), r
    }

    function Ns(t) {
        for (var e = t.map((function (t) {
            return {lrCoordinates: t, grouped: !1}
        })), n = []; !Ps(e);) for (var r = 0; r < e.length; r++) if (!e[r].grouped) {
            var i = [];
            i.push(e[r].lrCoordinates), e[r].grouped = !0;
            for (var o = m([e[r].lrCoordinates]), s = r + 1; s < e.length; s++) {
                if (!e[s].grouped) Ms(m([e[s].lrCoordinates]), o) && (i.push(e[s].lrCoordinates), e[s].grouped = !0)
            }
            n.push(i)
        }
        return n
    }

    function Ms(t, e) {
        for (var n = Nn(t), r = 0; r < n.features.length; r++) if (!ye(n.features[r], e)) return !1;
        return !0
    }

    function Ps(t) {
        for (var e = 0; e < t.length; e++) if (!1 === t[e].grouped) return !1;
        return !0
    }

    function Ls(t, e, n) {
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r = n.pivot, i = n.mutate;
        if (!t) throw new Error("geojson is required");
        if (null == e || isNaN(e)) throw new Error("angle is required");
        return 0 === e || (r || (r = Sn(t)), !1 !== i && void 0 !== i || (t = Ie(t)), B(t, (function (t) {
            var n = yo(r, t) + e, i = vr(r, t), o = at(_o(r, i, n));
            t[0] = o[0], t[1] = o[1]
        }))), t
    }

    function Cs(t, n, r) {
        if (!F(r = r || {})) throw new Error("options is invalid");
        var i = r.origin, o = r.mutate;
        if (!t) throw new Error("geojson required");
        if ("number" != typeof n || n <= 0) throw new Error("invalid factor");
        var s = Array.isArray(i) || "object" === e(i);
        return !0 !== o && (t = Ie(t)), "FeatureCollection" !== t.type || s ? Rs(t, n, i) : (U(t, (function (e, r) {
            t.features[r] = Rs(e, n, i)
        })), t)
    }

    function Rs(t, n, r) {
        var i = "Point" === gt(t);
        return r = function (t, n) {
            null == n && (n = "centroid");
            if (Array.isArray(n) || "object" === e(n)) return st(n);
            var r = t.bbox ? t.bbox : ot(t, {recalculate: !0}), i = r[0], o = r[1], s = r[2], a = r[3];
            switch (n) {
                case"sw":
                case"southwest":
                case"westsouth":
                case"bottomleft":
                    return d([i, o]);
                case"se":
                case"southeast":
                case"eastsouth":
                case"bottomright":
                    return d([s, o]);
                case"nw":
                case"northwest":
                case"westnorth":
                case"topleft":
                    return d([i, a]);
                case"ne":
                case"northeast":
                case"eastnorth":
                case"topright":
                    return d([s, a]);
                case"center":
                    return In(t);
                case void 0:
                case null:
                case"centroid":
                    return Sn(t);
                default:
                    throw new Error("invalid origin")
            }
        }(t, r), 1 === n || i || (B(t, (function (t) {
            var e = vr(r, t), i = yo(r, t), o = at(_o(r, e * n, i));
            t[0] = o[0], t[1] = o[1], 3 === t.length && (t[2] *= n)
        })), delete t.bbox), t
    }

    function Ts(t) {
        var e = t[0], n = t[1];
        return [n[0] - e[0], n[1] - e[1]]
    }

    function Os(t, e) {
        return t[0] * e[1] - e[0] * t[1]
    }

    function As(t, e) {
        return !function (t, e) {
            return 0 === Os(Ts(t), Ts(e))
        }(t, e) && function (t, e) {
            var n, r, i = t[0], o = Ts(t), s = e[0], a = Ts(e), u = Os(o, a), l = function (t, e) {
                return [t[0] + e[0], t[1] + e[1]]
            }(i, function (t, e) {
                return [t * e[0], t * e[1]]
            }(Os((r = i, [(n = s)[0] - r[0], n[1] - r[1]]), a) / u, o));
            return l
        }(t, e)
    }

    function Ds(t, e, n) {
        var r = [], i = L(e, n), o = at(t), s = [];
        return o.forEach((function (t, e) {
            if (e !== o.length - 1) {
                var n = (l = t, h = o[e + 1], c = i, f = Math.sqrt((l[0] - h[0]) * (l[0] - h[0]) + (l[1] - h[1]) * (l[1] - h[1])), g = l[0] + c * (h[1] - l[1]) / f, p = h[0] + c * (h[1] - l[1]) / f, v = l[1] + c * (l[0] - h[0]) / f, d = h[1] + c * (l[0] - h[0]) / f, [[g, v], [p, d]]);
                if (r.push(n), e > 0) {
                    var a = r[e - 1], u = As(n, a);
                    !1 !== u && (a[1] = u, n[0] = u), s.push(a[0]), e === o.length - 2 && (s.push(n[0]), s.push(n[1]))
                }
                2 === o.length && (s.push(n[0]), s.push(n[1]))
            }
            var l, h, c, f, g, p, v, d
        })), x(s, t.properties)
    }

    function Fs(t, e, n) {
        var r = e[0] - t[0], i = e[1] - t[1], o = n[0] - e[0];
        return function (t) {
            return (t > 0) - (t < 0) || +t
        }(r * (n[1] - e[1]) - o * i)
    }

    function qs(t, e) {
        return e.geometry.coordinates[0].every((function (e) {
            return ye(d(e), t)
        }))
    }

    xs[1] = xs[169] = is, xs[4] = xs[166] = os, xs[16] = xs[154] = ss, xs[64] = xs[106] = as, xs[168] = xs[2] = us, xs[162] = xs[8] = ls, xs[138] = xs[32] = hs, xs[42] = xs[128] = cs, xs[5] = xs[165] = function (t) {
        return [[0, 0], [0, t.leftbottom], [1, t.rightbottom], [1, 0]]
    }, xs[20] = xs[150] = function (t) {
        return [[1, 0], [t.bottomright, 0], [t.topright, 1], [1, 1]]
    }, xs[80] = xs[90] = function (t) {
        return [[1, 1], [1, t.righttop], [0, t.lefttop], [0, 1]]
    }, xs[65] = xs[105] = function (t) {
        return [[t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]]
    }, xs[160] = xs[10] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [0, t.leftbottom], [0, t.lefttop]]
    }, xs[130] = xs[40] = function (t) {
        return [[t.topleft, 1], [t.topright, 1], [t.bottomright, 0], [t.bottomleft, 0]]
    }, xs[85] = function () {
        return [[0, 0], [0, 1], [1, 1], [1, 0]]
    }, xs[101] = xs[69] = function (t) {
        return [[1, t.rightbottom], [1, 0], [0, 0], [0, 1], [t.topleft, 1]]
    }, xs[149] = xs[21] = function (t) {
        return [[t.topright, 1], [1, 1], [1, 0], [0, 0], [0, t.leftbottom]]
    }, xs[86] = xs[84] = function (t) {
        return [[1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [1, 1]]
    }, xs[89] = xs[81] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, 1]]
    }, xs[96] = xs[74] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, xs[24] = xs[146] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [t.topright, 1]]
    }, xs[6] = xs[164] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop]]
    }, xs[129] = xs[41] = function (t) {
        return [[t.topright, 1], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1]]
    }, xs[66] = xs[104] = function (t) {
        return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, xs[144] = xs[26] = function (t) {
        return [[1, 1], [1, t.righttop], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
    }, xs[36] = xs[134] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [t.topleft, 1], [t.topright, 1]]
    }, xs[9] = xs[161] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom]]
    }, xs[37] = xs[133] = function (t) {
        return [[1, t.rightbottom], [1, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]]
    }, xs[148] = xs[22] = function (t) {
        return [[1, 1], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
    }, xs[82] = xs[88] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1]]
    }, xs[73] = xs[97] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]]
    }, xs[145] = xs[25] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]]
    }, xs[70] = xs[100] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, xs[34] = function (t) {
        return [cs(t), ls(t)]
    }, xs[35] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
    }, xs[136] = function (t) {
        return [hs(t), us(t)]
    }, xs[153] = function (t) {
        return [ss(t), is(t)]
    }, xs[102] = function (t) {
        return [os(t), as(t)]
    }, xs[155] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]]
    }, xs[103] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, xs[152] = function (t) {
        return [ss(t), us(t)]
    }, xs[156] = function (t) {
        return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
    }, xs[137] = function (t) {
        return [hs(t), is(t)]
    }, xs[139] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]]
    }, xs[98] = function (t) {
        return [ls(t), as(t)]
    }, xs[99] = function (t) {
        return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
    }, xs[38] = function (t) {
        return [os(t), cs(t)]
    }, xs[39] = function (t) {
        return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
    };
    var Gs = function () {
        function t(e) {
            n(this, t), this.id = t.buildId(e), this.coordinates = e, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1
        }

        return i(t, [{
            key: "removeInnerEdge", value: function (t) {
                this.innerEdges = this.innerEdges.filter((function (e) {
                    return e.from.id !== t.from.id
                }))
            }
        }, {
            key: "removeOuterEdge", value: function (t) {
                this.outerEdges = this.outerEdges.filter((function (e) {
                    return e.to.id !== t.to.id
                }))
            }
        }, {
            key: "addOuterEdge", value: function (t) {
                this.outerEdges.push(t), this.outerEdgesSorted = !1
            }
        }, {
            key: "sortOuterEdges", value: function () {
                var t = this;
                this.outerEdgesSorted || (this.outerEdges.sort((function (e, n) {
                    var r = e.to, i = n.to;
                    if (r.coordinates[0] - t.coordinates[0] >= 0 && i.coordinates[0] - t.coordinates[0] < 0) return 1;
                    if (r.coordinates[0] - t.coordinates[0] < 0 && i.coordinates[0] - t.coordinates[0] >= 0) return -1;
                    if (r.coordinates[0] - t.coordinates[0] == 0 && i.coordinates[0] - t.coordinates[0] == 0) return r.coordinates[1] - t.coordinates[1] >= 0 || i.coordinates[1] - t.coordinates[1] >= 0 ? r.coordinates[1] - i.coordinates[1] : i.coordinates[1] - r.coordinates[1];
                    var o = Fs(t.coordinates, r.coordinates, i.coordinates);
                    return o < 0 ? 1 : o > 0 ? -1 : Math.pow(r.coordinates[0] - t.coordinates[0], 2) + Math.pow(r.coordinates[1] - t.coordinates[1], 2) - (Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2))
                })), this.outerEdgesSorted = !0)
            }
        }, {
            key: "getOuterEdges", value: function () {
                return this.sortOuterEdges(), this.outerEdges
            }
        }, {
            key: "getOuterEdge", value: function (t) {
                return this.sortOuterEdges(), this.outerEdges[t]
            }
        }, {
            key: "addInnerEdge", value: function (t) {
                this.innerEdges.push(t)
            }
        }], [{
            key: "buildId", value: function (t) {
                return t.join(",")
            }
        }]), t
    }(), Ys = function () {
        function t(e, r) {
            n(this, t), this.from = e, this.to = r, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this)
        }

        return i(t, [{
            key: "getSymetric", value: function () {
                return this.symetric || (this.symetric = new t(this.to, this.from), this.symetric.symetric = this), this.symetric
            }
        }, {
            key: "deleteEdge", value: function () {
                this.from.removeOuterEdge(this), this.to.removeInnerEdge(this)
            }
        }, {
            key: "isEqual", value: function (t) {
                return this.from.id === t.from.id && this.to.id === t.to.id
            }
        }, {
            key: "toString", value: function () {
                return "Edge { ".concat(this.from.id, " -> ").concat(this.to.id, " }")
            }
        }, {
            key: "toLineString", value: function () {
                return x([this.from.coordinates, this.to.coordinates])
            }
        }, {
            key: "compareTo", value: function (t) {
                return Fs(t.from.coordinates, t.to.coordinates, this.to.coordinates)
            }
        }]), t
    }(), Bs = function () {
        function t() {
            n(this, t), this.edges = [], this.polygon = void 0, this.envelope = void 0
        }

        return i(t, [{
            key: "push", value: function (t) {
                this.edges.push(t), this.polygon = this.envelope = void 0
            }
        }, {
            key: "get", value: function (t) {
                return this.edges[t]
            }
        }, {
            key: "length", get: function () {
                return this.edges.length
            }
        }, {
            key: "forEach", value: function (t) {
                this.edges.forEach(t)
            }
        }, {
            key: "map", value: function (t) {
                return this.edges.map(t)
            }
        }, {
            key: "some", value: function (t) {
                return this.edges.some(t)
            }
        }, {
            key: "isValid", value: function () {
                return !0
            }
        }, {
            key: "isHole", value: function () {
                var t = this, e = this.edges.reduce((function (e, n, r) {
                        return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e
                    }), 0), n = (0 === e ? this.length : e) - 1, r = (e + 1) % this.length,
                    i = Fs(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[r].from.coordinates);
                return 0 === i ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : i > 0
            }
        }, {
            key: "toMultiPoint", value: function () {
                return b(this.edges.map((function (t) {
                    return t.from.coordinates
                })))
            }
        }, {
            key: "toPolygon", value: function () {
                if (this.polygon) return this.polygon;
                var t = this.edges.map((function (t) {
                    return t.from.coordinates
                }));
                return t.push(this.edges[0].from.coordinates), this.polygon = m([t])
            }
        }, {
            key: "getEnvelope", value: function () {
                return this.envelope ? this.envelope : this.envelope = _n(this.toPolygon())
            }
        }, {
            key: "inside", value: function (t) {
                return ye(t, this.toPolygon())
            }
        }], [{
            key: "findEdgeRingContaining", value: function (t, e) {
                var n, r, i = t.getEnvelope();
                return e.forEach((function (e) {
                    var o, s, a, u, l, c, f = e.getEnvelope();
                    if ((r && (n = r.getEnvelope()), s = i, a = (o = f).geometry.coordinates[0].map((function (t) {
                        return t[0]
                    })), u = o.geometry.coordinates[0].map((function (t) {
                        return t[1]
                    })), l = s.geometry.coordinates[0].map((function (t) {
                        return t[0]
                    })), c = s.geometry.coordinates[0].map((function (t) {
                        return t[1]
                    })), Math.max.apply(null, a) !== Math.max.apply(null, l) || Math.max.apply(null, u) !== Math.max.apply(null, c) || Math.min.apply(null, a) !== Math.min.apply(null, l) || Math.min.apply(null, u) !== Math.min.apply(null, c)) && qs(f, i)) {
                        var g, p, v = h(t.map((function (t) {
                            return t.from.coordinates
                        })));
                        try {
                            var y = function () {
                                var t = p.value;
                                e.some((function (e) {
                                    return n = t, r = e.from.coordinates, n[0] === r[0] && n[1] === r[1];
                                    var n, r
                                })) || (g = t)
                            };
                            for (v.s(); !(p = v.n()).done;) y()
                        } catch (t) {
                            v.e(t)
                        } finally {
                            v.f()
                        }
                        g && e.inside(d(g)) && (r && !qs(n, f) || (r = e))
                    }
                })), r
            }
        }]), t
    }();
    var zs = function () {
        function t() {
            n(this, t), this.edges = [], this.nodes = {}
        }

        return i(t, [{
            key: "getNode", value: function (t) {
                var e = Gs.buildId(t), n = this.nodes[e];
                return n || (n = this.nodes[e] = new Gs(t)), n
            }
        }, {
            key: "addEdge", value: function (t, e) {
                var n = new Ys(t, e), r = n.getSymetric();
                this.edges.push(n), this.edges.push(r)
            }
        }, {
            key: "deleteDangles", value: function () {
                var t = this;
                Object.keys(this.nodes).map((function (e) {
                    return t.nodes[e]
                })).forEach((function (e) {
                    return t._removeIfDangle(e)
                }))
            }
        }, {
            key: "_removeIfDangle", value: function (t) {
                var e = this;
                if (t.innerEdges.length <= 1) {
                    var n = t.getOuterEdges().map((function (t) {
                        return t.to
                    }));
                    this.removeNode(t), n.forEach((function (t) {
                        return e._removeIfDangle(t)
                    }))
                }
            }
        }, {
            key: "deleteCutEdges", value: function () {
                var t = this;
                this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach((function (e) {
                    e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e))
                }))
            }
        }, {
            key: "_computeNextCWEdges", value: function (t) {
                var e = this;
                void 0 === t ? Object.keys(this.nodes).forEach((function (t) {
                    return e._computeNextCWEdges(e.nodes[t])
                })) : t.getOuterEdges().forEach((function (e, n) {
                    t.getOuterEdge((0 === n ? t.getOuterEdges().length : n) - 1).symetric.next = e
                }))
            }
        }, {
            key: "_computeNextCCWEdges", value: function (t, e) {
                for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) {
                    var s = i[o], a = s.symetric, u = void 0, l = void 0;
                    s.label === e && (u = s), a.label === e && (l = a), u && l && (l && (r = l), u && (r && (r.next = u, r = void 0), n || (n = u)))
                }
                r && (r.next = n)
            }
        }, {
            key: "_findLabeledEdgeRings", value: function () {
                var t = [], e = 0;
                return this.edges.forEach((function (n) {
                    if (!(n.label >= 0)) {
                        t.push(n);
                        var r = n;
                        do {
                            r.label = e, r = r.next
                        } while (!n.isEqual(r));
                        e++
                    }
                })), t
            }
        }, {
            key: "getEdgeRings", value: function () {
                var t = this;
                this._computeNextCWEdges(), this.edges.forEach((function (t) {
                    t.label = void 0
                })), this._findLabeledEdgeRings().forEach((function (e) {
                    t._findIntersectionNodes(e).forEach((function (n) {
                        t._computeNextCCWEdges(n, e.label)
                    }))
                }));
                var e = [];
                return this.edges.forEach((function (n) {
                    n.ring || e.push(t._findEdgeRing(n))
                })), e
            }
        }, {
            key: "_findIntersectionNodes", value: function (t) {
                var e = [], n = t, r = function () {
                    var r = 0;
                    n.from.getOuterEdges().forEach((function (e) {
                        e.label === t.label && ++r
                    })), r > 1 && e.push(n.from), n = n.next
                };
                do {
                    r()
                } while (!t.isEqual(n));
                return e
            }
        }, {
            key: "_findEdgeRing", value: function (t) {
                var e = t, n = new Bs;
                do {
                    n.push(e), e.ring = n, e = e.next
                } while (!t.isEqual(e));
                return n
            }
        }, {
            key: "removeNode", value: function (t) {
                var e = this;
                t.getOuterEdges().forEach((function (t) {
                    return e.removeEdge(t)
                })), t.innerEdges.forEach((function (t) {
                    return e.removeEdge(t)
                })), delete this.nodes[t.id]
            }
        }, {
            key: "removeEdge", value: function (t) {
                this.edges = this.edges.filter((function (e) {
                    return !e.isEqual(t)
                })), t.deleteEdge()
            }
        }], [{
            key: "fromGeoJson", value: function (e) {
                !function (t) {
                    if (!t) throw new Error("No geojson passed");
                    if ("FeatureCollection" !== t.type && "GeometryCollection" !== t.type && "MultiLineString" !== t.type && "LineString" !== t.type && "Feature" !== t.type) throw new Error("Invalid input type '".concat(t.type, "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature"))
                }(e);
                var n = new t;
                return J(e, (function (t) {
                    ht(t, "LineString", "Graph::fromGeoJson"), z(t, (function (t, e) {
                        if (t) {
                            var r = n.getNode(t), i = n.getNode(e);
                            n.addEdge(r, i)
                        }
                        return e
                    }))
                })), n
            }
        }]), t
    }();

    function Xs(t, e) {
        var n = !0;
        return J(t, (function (t) {
            J(e, (function (e) {
                if (!1 === n) return !1;
                n = function (t, e) {
                    switch (t.type) {
                        case"Point":
                            switch (e.type) {
                                case"Point":
                                    return n = t.coordinates, r = e.coordinates, !(n[0] === r[0] && n[1] === r[1]);
                                case"LineString":
                                    return !js(e, t);
                                case"Polygon":
                                    return !ye(t, e)
                            }
                            break;
                        case"LineString":
                            switch (e.type) {
                                case"Point":
                                    return !js(t, e);
                                case"LineString":
                                    return !function (t, e) {
                                        if (gr(t, e).features.length > 0) return !0;
                                        return !1
                                    }(t, e);
                                case"Polygon":
                                    return !Us(e, t)
                            }
                            break;
                        case"Polygon":
                            switch (e.type) {
                                case"Point":
                                    return !ye(e, t);
                                case"LineString":
                                    return !Us(t, e);
                                case"Polygon":
                                    return !function (t, e) {
                                        var n, r = h(t.coordinates[0]);
                                        try {
                                            for (r.s(); !(n = r.n()).done;) {
                                                if (ye(n.value, e)) return !0
                                            }
                                        } catch (t) {
                                            r.e(t)
                                        } finally {
                                            r.f()
                                        }
                                        var i, o = h(e.coordinates[0]);
                                        try {
                                            for (o.s(); !(i = o.n()).done;) {
                                                if (ye(i.value, t)) return !0
                                            }
                                        } catch (t) {
                                            o.e(t)
                                        } finally {
                                            o.f()
                                        }
                                        if (gr(to(t), to(e)).features.length > 0) return !0;
                                        return !1
                                    }(e, t)
                            }
                    }
                    var n, r;
                    return !1
                }(t.geometry, e.geometry)
            }))
        })), n
    }

    function js(t, e) {
        for (var n = 0; n < t.coordinates.length - 1; n++) if (Vs(t.coordinates[n], t.coordinates[n + 1], e.coordinates)) return !0;
        return !1
    }

    function Us(t, e) {
        var n, r = h(e.coordinates);
        try {
            for (r.s(); !(n = r.n()).done;) {
                if (ye(n.value, t)) return !0
            }
        } catch (t) {
            r.e(t)
        } finally {
            r.f()
        }
        return gr(e, to(t)).features.length > 0
    }

    function Vs(t, e, n) {
        var r = n[0] - t[0], i = n[1] - t[1], o = e[0] - t[0], s = e[1] - t[1];
        return 0 == r * s - i * o && (Math.abs(o) >= Math.abs(s) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1])
    }

    function Zs(t, e) {
        if ("Feature" === t.type && null === t.geometry) return !1;
        if ("Feature" === e.type && null === e.geometry) return !1;
        if (!Hs(ot(t), ot(e))) return !1;
        var n, r = h(ft(e).coordinates);
        try {
            for (r.s(); !(n = r.n()).done;) {
                var i, o = h(n.value);
                try {
                    for (o.s(); !(i = o.n()).done;) {
                        if (!ye(i.value, t)) return !1
                    }
                } catch (t) {
                    o.e(t)
                } finally {
                    o.f()
                }
            }
        } catch (t) {
            r.e(t)
        } finally {
            r.f()
        }
        return !0
    }

    function Hs(t, e) {
        return !(t[0] > e[0]) && (!(t[2] < e[2]) && (!(t[1] > e[1]) && !(t[3] < e[3])))
    }

    function Ws(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function Js(t, e) {
        return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2]
    }

    function Qs(t, e) {
        for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) {
            for (var s = 0; s < e.coordinates.length - 1; s++) {
                var a = !0;
                0 !== s && s !== e.coordinates.length - 2 || (a = !1), ta(e.coordinates[s], e.coordinates[s + 1], t.coordinates[o], a) ? n = !0 : r = !0
            }
            o++
        }
        return n && r
    }

    function Ks(t, e) {
        return gr(t, eo(e)).features.length > 0
    }

    function $s(t, e) {
        for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && (!n || !r); o++) ye(d(t.coordinates[o]), e) ? n = !0 : r = !0;
        return r && n
    }

    function ta(t, e, n, r) {
        var i = n[0] - t[0], o = n[1] - t[1], s = e[0] - t[0], a = e[1] - t[1];
        return 0 == i * a - o * s && (r ? Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : a > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : a > 0 ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1])
    }

    var ea = function (t) {
        this.precision = t && t.precision ? t.precision : 17, this.direction = !(!t || !t.direction) && t.direction, this.pseudoNode = !(!t || !t.pseudoNode) && t.pseudoNode, this.objectComparator = t && t.objectComparator ? t.objectComparator : ia
    };

    function na(t) {
        return t.coordinates.map((function (e) {
            return {type: t.type.replace("Multi", ""), coordinates: e}
        }))
    }

    function ra(t, e) {
        return t.hasOwnProperty("coordinates") ? t.coordinates.length === e.coordinates.length : t.length === e.length
    }

    function ia(t, e) {
        return fo(t, e, {strict: !0})
    }

    ea.prototype.compare = function (t, e) {
        if (t.type !== e.type || !ra(t, e)) return !1;
        switch (t.type) {
            case"Point":
                return this.compareCoord(t.coordinates, e.coordinates);
            case"LineString":
                return this.compareLine(t.coordinates, e.coordinates, 0, !1);
            case"Polygon":
                return this.comparePolygon(t, e);
            case"Feature":
                return this.compareFeature(t, e);
            default:
                if (0 === t.type.indexOf("Multi")) {
                    var n = this, r = na(t), i = na(e);
                    return r.every((function (t) {
                        return this.some((function (e) {
                            return n.compare(t, e)
                        }))
                    }), i)
                }
        }
        return !1
    }, ea.prototype.compareCoord = function (t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0; n < t.length; n++) if (t[n].toFixed(this.precision) !== e[n].toFixed(this.precision)) return !1;
        return !0
    }, ea.prototype.compareLine = function (t, e, n, r) {
        if (!ra(t, e)) return !1;
        var i = this.pseudoNode ? t : this.removePseudo(t), o = this.pseudoNode ? e : this.removePseudo(e);
        if (!r || this.compareCoord(i[0], o[0]) || (o = this.fixStartIndex(o, i))) {
            var s = this.compareCoord(i[n], o[n]);
            return this.direction || s ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o)
        }
    }, ea.prototype.fixStartIndex = function (t, e) {
        for (var n, r = -1, i = 0; i < t.length; i++) if (this.compareCoord(t[i], e[0])) {
            r = i;
            break
        }
        return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n
    }, ea.prototype.comparePath = function (t, e) {
        var n = this;
        return t.every((function (t, e) {
            return n.compareCoord(t, this[e])
        }), e)
    }, ea.prototype.comparePolygon = function (t, e) {
        if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {
            var n = t.coordinates.slice(1, t.coordinates.length), r = e.coordinates.slice(1, e.coordinates.length),
                i = this;
            return n.every((function (t) {
                return this.some((function (e) {
                    return i.compareLine(t, e, 1, !0)
                }))
            }), r)
        }
        return !1
    }, ea.prototype.compareFeature = function (t, e) {
        return !(t.id !== e.id || !this.objectComparator(t.properties, e.properties) || !this.compareBBox(t, e)) && this.compare(t.geometry, e.geometry)
    }, ea.prototype.compareBBox = function (t, e) {
        return !!(!t.bbox && !e.bbox || t.bbox && e.bbox && this.compareCoord(t.bbox, e.bbox))
    }, ea.prototype.removePseudo = function (t) {
        return t
    };
    var oa = ea;

    function sa(t, e) {
        var n = !1;
        return J(t, (function (t) {
            J(e, (function (e) {
                if (!0 === n) return !0;
                n = !Xs(t.geometry, e.geometry)
            }))
        })), n
    }

    function aa(t, e) {
        return !!ua(e.coordinates[0], t.coordinates) || !!ua(e.coordinates[e.coordinates.length - 1], t.coordinates)
    }

    function ua(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    var la = Wt((function (t) {
        function n(t, e, n, r) {
            this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(t, e, n, r)
        }

        n.prototype.run = function (t, e, n, r) {
            this._init(t, e, n, r);
            for (var i = 0; i < this._datasetLength; i++) if (1 !== this._visited[i]) {
                this._visited[i] = 1;
                var o = this._regionQuery(i);
                if (o.length < this.minPts) this.noise.push(i); else {
                    var s = this.clusters.length;
                    this.clusters.push([]), this._addToCluster(i, s), this._expandCluster(s, o)
                }
            }
            return this.clusters
        }, n.prototype._init = function (t, n, r, i) {
            if (t) {
                if (!(t instanceof Array)) throw Error("Dataset must be of type array, " + e(t) + " given");
                this.dataset = t, this.clusters = [], this.noise = [], this._datasetLength = t.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength)
            }
            n && (this.epsilon = n), r && (this.minPts = r), i && (this.distance = i)
        }, n.prototype._expandCluster = function (t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                if (1 !== this._visited[r]) {
                    this._visited[r] = 1;
                    var i = this._regionQuery(r);
                    i.length >= this.minPts && (e = this._mergeArrays(e, i))
                }
                1 !== this._assigned[r] && this._addToCluster(r, t)
            }
        }, n.prototype._addToCluster = function (t, e) {
            this.clusters[e].push(t), this._assigned[t] = 1
        }, n.prototype._regionQuery = function (t) {
            for (var e = [], n = 0; n < this._datasetLength; n++) {
                this.distance(this.dataset[t], this.dataset[n]) < this.epsilon && e.push(n)
            }
            return e
        }, n.prototype._mergeArrays = function (t, e) {
            for (var n = e.length, r = 0; r < n; r++) {
                var i = e[r];
                t.indexOf(i) < 0 && t.push(i)
            }
            return t
        }, n.prototype._euclideanDistance = function (t, e) {
            for (var n = 0, r = Math.min(t.length, e.length); r--;) n += (t[r] - e[r]) * (t[r] - e[r]);
            return Math.sqrt(n)
        }, t.exports && (t.exports = n)
    })), ha = Wt((function (t) {
        /**
         * KMEANS clustering
         *
         * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
         * @copyright MIT
         */
        function e(t, e, n) {
            this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(t, e, n)
        }

        e.prototype.init = function (t, e, n) {
            this.assignments = [], this.centroids = [], void 0 !== t && (this.dataset = t), void 0 !== e && (this.k = e), void 0 !== n && (this.distance = n)
        }, e.prototype.run = function (t, e) {
            this.init(t, e);
            for (var n = this.dataset.length, r = 0; r < this.k; r++) this.centroids[r] = this.randomCentroid();
            for (var i = !0; i;) {
                i = this.assign();
                for (var o = 0; o < this.k; o++) {
                    for (var s = new Array(h), a = 0, u = 0; u < h; u++) s[u] = 0;
                    for (var l = 0; l < n; l++) {
                        var h = this.dataset[l].length;
                        if (o === this.assignments[l]) {
                            for (u = 0; u < h; u++) s[u] += this.dataset[l][u];
                            a++
                        }
                    }
                    if (a > 0) {
                        for (u = 0; u < h; u++) s[u] /= a;
                        this.centroids[o] = s
                    } else this.centroids[o] = this.randomCentroid(), i = !0
                }
            }
            return this.getClusters()
        }, e.prototype.randomCentroid = function () {
            var t, e, n = this.dataset.length - 1;
            do {
                e = Math.round(Math.random() * n), t = this.dataset[e]
            } while (this.centroids.indexOf(t) >= 0);
            return t
        }, e.prototype.assign = function () {
            for (var t, e = !1, n = this.dataset.length, r = 0; r < n; r++) (t = this.argmin(this.dataset[r], this.centroids, this.distance)) != this.assignments[r] && (this.assignments[r] = t, e = !0);
            return e
        }, e.prototype.getClusters = function () {
            for (var t, e = new Array(this.k), n = 0; n < this.assignments.length; n++) void 0 === e[t = this.assignments[n]] && (e[t] = []), e[t].push(n);
            return e
        }, e.prototype.argmin = function (t, e, n) {
            for (var r, i = Number.MAX_VALUE, o = 0, s = e.length, a = 0; a < s; a++) (r = n(t, e[a])) < i && (i = r, o = a);
            return o
        }, e.prototype.distance = function (t, e) {
            for (var n = 0, r = Math.min(t.length, e.length); r--;) {
                var i = t[r] - e[r];
                n += i * i
            }
            return Math.sqrt(n)
        }, t.exports && (t.exports = e)
    })), ca = Wt((function (t) {
        function e(t, e, n) {
            this._queue = [], this._priorities = [], this._sorting = "desc", this._init(t, e, n)
        }

        e.prototype.insert = function (t, e) {
            for (var n = this._queue.length, r = n; r--;) {
                var i = this._priorities[r];
                "desc" === this._sorting ? e > i && (n = r) : e < i && (n = r)
            }
            this._insertAt(t, e, n)
        }, e.prototype.remove = function (t) {
            for (var e = this._queue.length; e--;) {
                if (t === this._queue[e]) {
                    this._queue.splice(e, 1), this._priorities.splice(e, 1);
                    break
                }
            }
        }, e.prototype.forEach = function (t) {
            this._queue.forEach(t)
        }, e.prototype.getElements = function () {
            return this._queue
        }, e.prototype.getElementPriority = function (t) {
            return this._priorities[t]
        }, e.prototype.getPriorities = function () {
            return this._priorities
        }, e.prototype.getElementsWithPriorities = function () {
            for (var t = [], e = 0, n = this._queue.length; e < n; e++) t.push([this._queue[e], this._priorities[e]]);
            return t
        }, e.prototype._init = function (t, e, n) {
            if (t && e) {
                if (this._queue = [], this._priorities = [], t.length !== e.length) throw new Error("Arrays must have the same length");
                for (var r = 0; r < t.length; r++) this.insert(t[r], e[r])
            }
            n && (this._sorting = n)
        }, e.prototype._insertAt = function (t, e, n) {
            this._queue.length === n ? (this._queue.push(t), this._priorities.push(e)) : (this._queue.splice(n, 0, t), this._priorities.splice(n, 0, e))
        }, t.exports && (t.exports = e)
    })), fa = Wt((function (t) {
        if (t.exports) var n = ca;

        /**
         * OPTICS - Ordering points to identify the clustering structure
         *
         * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
         * @copyright MIT
         */function r(t, e, n, r) {
            this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(t, e, n, r)
        }

        r.prototype.run = function (t, e, r, i) {
            this._init(t, e, r, i);
            for (var o = 0, s = this.dataset.length; o < s; o++) if (1 !== this._processed[o]) {
                this._processed[o] = 1, this.clusters.push([o]);
                var a = this.clusters.length - 1;
                this._orderedList.push(o);
                var u = new n(null, null, "asc"), l = this._regionQuery(o);
                void 0 !== this._distanceToCore(o) && (this._updateQueue(o, l, u), this._expandCluster(a, u))
            }
            return this.clusters
        }, r.prototype.getReachabilityPlot = function () {
            for (var t = [], e = 0, n = this._orderedList.length; e < n; e++) {
                var r = this._orderedList[e], i = this._reachability[r];
                t.push([r, i])
            }
            return t
        }, r.prototype._init = function (t, n, r, i) {
            if (t) {
                if (!(t instanceof Array)) throw Error("Dataset must be of type array, " + e(t) + " given");
                this.dataset = t, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = []
            }
            n && (this.epsilon = n), r && (this.minPts = r), i && (this.distance = i)
        }, r.prototype._updateQueue = function (t, e, n) {
            var r = this;
            this._coreDistance = this._distanceToCore(t), e.forEach((function (e) {
                if (void 0 === r._processed[e]) {
                    var i = r.distance(r.dataset[t], r.dataset[e]), o = Math.max(r._coreDistance, i);
                    void 0 === r._reachability[e] ? (r._reachability[e] = o, n.insert(e, o)) : o < r._reachability[e] && (r._reachability[e] = o, n.remove(e), n.insert(e, o))
                }
            }))
        }, r.prototype._expandCluster = function (t, e) {
            for (var n = e.getElements(), r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                if (void 0 === this._processed[o]) {
                    var s = this._regionQuery(o);
                    this._processed[o] = 1, this.clusters[t].push(o), this._orderedList.push(o), void 0 !== this._distanceToCore(o) && (this._updateQueue(o, s, e), this._expandCluster(t, e))
                }
            }
        }, r.prototype._distanceToCore = function (t) {
            for (var e = this.epsilon, n = 0; n < e; n++) {
                if (this._regionQuery(t, n).length >= this.minPts) return n
            }
        }, r.prototype._regionQuery = function (t, e) {
            e = e || this.epsilon;
            for (var n = [], r = 0, i = this.dataset.length; r < i; r++) this.distance(this.dataset[t], this.dataset[r]) < e && n.push(r);
            return n
        }, r.prototype._euclideanDistance = function (t, e) {
            for (var n = 0, r = Math.min(t.length, e.length); r--;) n += (t[r] - e[r]) * (t[r] - e[r]);
            return Math.sqrt(n)
        }, t.exports && (t.exports = r)
    })), ga = Wt((function (t) {
        t.exports && (t.exports = {DBSCAN: la, KMEANS: ha, OPTICS: fa, PriorityQueue: ca})
    }));
    var pa = function (t, e, n) {
        for (var r = t.length, i = 0, o = 0; o < r; o++) {
            var s = (t[o] || 0) - (e[o] || 0);
            i += s * s
        }
        return n ? Math.sqrt(i) : i
    }, va = function (t, e, n) {
        var r = Math.abs(t - e);
        return n ? r : r * r
    }, da = pa, ya = va, ma = function (t, e) {
        var n = t[0].length ? da : ya, r = [], i = t.length, o = t[0].length > 0, s = t[Math.floor(Math.random() * i)];
        o && s.join("_");
        for (r.push(s); r.length < e;) {
            for (var a = [], u = r.length, l = 0, h = [], c = 0; c < i; c++) {
                for (var f = 1 / 0, g = 0; g < u; g++) {
                    var p = n(t[c], r[g]);
                    p <= f && (f = p)
                }
                a[c] = f
            }
            for (var v = 0; v < i; v++) l += a[v];
            for (var d = 0; d < i; d++) h[d] = {i: d, v: t[d], pr: a[d] / l, cs: 0};
            h.sort((function (t, e) {
                return t.pr - e.pr
            })), h[0].cs = h[0].pr;
            for (var y = 1; y < i; y++) h[y].cs = h[y - 1].cs + h[y].pr;
            for (var m = Math.random(), _ = 0; _ < i - 1 && h[_++].cs < m;) ;
            r.push(h[_ - 1].v)
        }
        return r
    }, _a = pa, xa = function (t, e) {
        for (var n = {}, r = [], i = e << 2, o = t.length, s = t[0].length > 0; r.length < e && i-- > 0;) {
            var a = t[Math.floor(Math.random() * o)], u = s ? a.join("_") : "" + a;
            n[u] || (n[u] = !0, r.push(a))
        }
        if (r.length < e) throw new Error("Error initializating clusters");
        return r
    }, Ea = ma;

    function ka(t, e, n) {
        n = n || [];
        for (var r = 0; r < t; r++) n[r] = e;
        return n
    }

    var wa = function (t, e, n, r) {
        var i = [], o = [], s = [], a = [], u = !1, l = r || 1e4, h = t.length, c = t[0].length, f = c > 0, g = [];
        if (n) i = "kmrand" == n ? xa(t, e) : "kmpp" == n ? Ea(t, e) : n; else for (var p = {}; i.length < e;) {
            var v = Math.floor(Math.random() * h);
            p[v] || (p[v] = !0, i.push(t[v]))
        }
        do {
            ka(e, 0, g);
            for (var d = 0; d < h; d++) {
                for (var y = 1 / 0, m = 0, _ = 0; _ < e; _++) {
                    (a = f ? _a(t[d], i[_]) : Math.abs(t[d] - i[_])) <= y && (y = a, m = _)
                }
                s[d] = m, g[m]++
            }
            for (var x = [], E = (o = [], 0); E < e; E++) x[E] = f ? ka(c, 0, x[E]) : 0, o[E] = i[E];
            if (f) {
                for (var k = 0; k < e; k++) i[k] = [];
                for (var w = 0; w < h; w++) for (var b = x[s[w]], I = t[w], S = 0; S < c; S++) b[S] += I[S];
                u = !0;
                for (var N = 0; N < e; N++) {
                    for (var M = i[N], P = x[N], L = o[N], C = g[N], R = 0; R < c; R++) M[R] = P[R] / C || 0;
                    if (u) for (var T = 0; T < c; T++) if (L[T] != M[T]) {
                        u = !1;
                        break
                    }
                }
            } else {
                for (var O = 0; O < h; O++) {
                    x[s[O]] += t[O]
                }
                for (var A = 0; A < e; A++) i[A] = x[A] / g[A] || 0;
                u = !0;
                for (var D = 0; D < e; D++) if (o[D] != i[D]) {
                    u = !1;
                    break
                }
            }
            u = u || --l <= 0
        } while (!u);
        return {it: 1e4 - l, k: e, idxs: s, centroids: i}
    };

    function ba(t, e) {
        return C(yo(t[0], t[1])) === C(yo(e[0], e[1]))
    }

    function Ia(t, e) {
        if (t.geometry && t.geometry.type) return t.geometry.type;
        if (t.type) return t.type;
        throw new Error("Invalid GeoJSON object for " + e)
    }

    function Sa(t) {
        for (var e = t, n = []; e.parent;) n.unshift(e), e = e.parent;
        return n
    }

    var Na = {
        search: function (t, e, n, r) {
            t.cleanDirty();
            var i = (r = r || {}).heuristic || Na.heuristics.manhattan, o = r.closest || !1, s = new La((function (t) {
                return t.f
            })), a = e;
            for (e.h = i(e, n), s.push(e); s.size() > 0;) {
                var u = s.pop();
                if (u === n) return Sa(u);
                u.closed = !0;
                for (var l = t.neighbors(u), h = 0, c = l.length; h < c; ++h) {
                    var f = l[h];
                    if (!f.closed && !f.isWall()) {
                        var g = u.g + f.getCost(u), p = f.visited;
                        (!p || g < f.g) && (f.visited = !0, f.parent = u, f.h = f.h || i(f, n), f.g = g, f.f = f.g + f.h, t.markDirty(f), o && (f.h < a.h || f.h === a.h && f.g < a.g) && (a = f), p ? s.rescoreElement(f) : s.push(f))
                    }
                }
            }
            return o ? Sa(a) : []
        }, heuristics: {
            manhattan: function (t, e) {
                return Math.abs(e.x - t.x) + Math.abs(e.y - t.y)
            }, diagonal: function (t, e) {
                var n = Math.sqrt(2), r = Math.abs(e.x - t.x), i = Math.abs(e.y - t.y);
                return 1 * (r + i) + (n - 2) * Math.min(r, i)
            }
        }, cleanNode: function (t) {
            t.f = 0, t.g = 0, t.h = 0, t.visited = !1, t.closed = !1, t.parent = null
        }
    };

    function Ma(t, e) {
        e = e || {}, this.nodes = [], this.diagonal = !!e.diagonal, this.grid = [];
        for (var n = 0; n < t.length; n++) {
            this.grid[n] = [];
            for (var r = 0, i = t[n]; r < i.length; r++) {
                var o = new Pa(n, r, i[r]);
                this.grid[n][r] = o, this.nodes.push(o)
            }
        }
        this.init()
    }

    function Pa(t, e, n) {
        this.x = t, this.y = e, this.weight = n
    }

    function La(t) {
        this.content = [], this.scoreFunction = t
    }

    function Ca(t, e) {
        for (var n = 0; n < e.features.length; n++) if (ye(t, e.features[n])) return !0;
        return !1
    }

    function Ra(t) {
        return function () {
            return t
        }
    }

    function Ta(t) {
        return t[0]
    }

    function Oa(t) {
        return t[1]
    }

    function Aa() {
        this._ = null
    }

    function Da(t) {
        t.U = t.C = t.L = t.R = t.P = t.N = null
    }

    function Fa(t, e) {
        var n = e, r = e.R, i = n.U;
        i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n
    }

    function qa(t, e) {
        var n = e, r = e.L, i = n.U;
        i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n
    }

    function Ga(t) {
        for (; t.L;) t = t.L;
        return t
    }

    function Ya(t, e, n, r) {
        var i = [null, null], o = hu.push(i) - 1;
        return i.left = t, i.right = e, n && za(i, t, e, n), r && za(i, e, t, r), uu[t.index].halfedges.push(o), uu[e.index].halfedges.push(o), i
    }

    function Ba(t, e, n) {
        var r = [e, n];
        return r.left = t, r
    }

    function za(t, e, n, r) {
        t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n)
    }

    function Xa(t, e, n, r, i) {
        var o, s = t[0], a = t[1], u = s[0], l = s[1], h = 0, c = 1, f = a[0] - u, g = a[1] - l;
        if (o = e - u, f || !(o > 0)) {
            if (o /= f, f < 0) {
                if (o < h) return;
                o < c && (c = o)
            } else if (f > 0) {
                if (o > c) return;
                o > h && (h = o)
            }
            if (o = r - u, f || !(o < 0)) {
                if (o /= f, f < 0) {
                    if (o > c) return;
                    o > h && (h = o)
                } else if (f > 0) {
                    if (o < h) return;
                    o < c && (c = o)
                }
                if (o = n - l, g || !(o > 0)) {
                    if (o /= g, g < 0) {
                        if (o < h) return;
                        o < c && (c = o)
                    } else if (g > 0) {
                        if (o > c) return;
                        o > h && (h = o)
                    }
                    if (o = i - l, g || !(o < 0)) {
                        if (o /= g, g < 0) {
                            if (o > c) return;
                            o > h && (h = o)
                        } else if (g > 0) {
                            if (o < h) return;
                            o < c && (c = o)
                        }
                        return !(h > 0 || c < 1) || (h > 0 && (t[0] = [u + h * f, l + h * g]), c < 1 && (t[1] = [u + c * f, l + c * g]), !0)
                    }
                }
            }
        }
    }

    function ja(t, e, n, r, i) {
        var o = t[1];
        if (o) return !0;
        var s, a, u = t[0], l = t.left, h = t.right, c = l[0], f = l[1], g = h[0], p = h[1], v = (c + g) / 2,
            d = (f + p) / 2;
        if (p === f) {
            if (v < e || v >= r) return;
            if (c > g) {
                if (u) {
                    if (u[1] >= i) return
                } else u = [v, n];
                o = [v, i]
            } else {
                if (u) {
                    if (u[1] < n) return
                } else u = [v, i];
                o = [v, n]
            }
        } else if (a = d - (s = (c - g) / (p - f)) * v, s < -1 || s > 1) if (c > g) {
            if (u) {
                if (u[1] >= i) return
            } else u = [(n - a) / s, n];
            o = [(i - a) / s, i]
        } else {
            if (u) {
                if (u[1] < n) return
            } else u = [(i - a) / s, i];
            o = [(n - a) / s, n]
        } else if (f < p) {
            if (u) {
                if (u[0] >= r) return
            } else u = [e, s * e + a];
            o = [r, s * r + a]
        } else {
            if (u) {
                if (u[0] < e) return
            } else u = [r, s * r + a];
            o = [e, s * e + a]
        }
        return t[0] = u, t[1] = o, !0
    }

    function Ua(t, e) {
        var n = t.site, r = e.left, i = e.right;
        return n === i && (i = r, r = n), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (n === r ? (r = e[1], i = e[0]) : (r = e[0], i = e[1]), Math.atan2(r[0] - i[0], i[1] - r[1]))
    }

    function Va(t, e) {
        return e[+(e.left !== t.site)]
    }

    function Za(t, e) {
        return e[+(e.left === t.site)]
    }

    Ma.prototype.init = function () {
        this.dirtyNodes = [];
        for (var t = 0; t < this.nodes.length; t++) Na.cleanNode(this.nodes[t])
    }, Ma.prototype.cleanDirty = function () {
        for (var t = 0; t < this.dirtyNodes.length; t++) Na.cleanNode(this.dirtyNodes[t]);
        this.dirtyNodes = []
    }, Ma.prototype.markDirty = function (t) {
        this.dirtyNodes.push(t)
    }, Ma.prototype.neighbors = function (t) {
        var e = [], n = t.x, r = t.y, i = this.grid;
        return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e
    }, Ma.prototype.toString = function () {
        for (var t, e, n, r, i = [], o = this.grid, s = 0, a = o.length; s < a; s++) {
            for (t = [], n = 0, r = (e = o[s]).length; n < r; n++) t.push(e[n].weight);
            i.push(t.join(" "))
        }
        return i.join("\n")
    }, Pa.prototype.toString = function () {
        return "[" + this.x + " " + this.y + "]"
    }, Pa.prototype.getCost = function (t) {
        return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight
    }, Pa.prototype.isWall = function () {
        return 0 === this.weight
    }, La.prototype = {
        push: function (t) {
            this.content.push(t), this.sinkDown(this.content.length - 1)
        }, pop: function () {
            var t = this.content[0], e = this.content.pop();
            return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t
        }, remove: function (t) {
            var e = this.content.indexOf(t), n = this.content.pop();
            e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e))
        }, size: function () {
            return this.content.length
        }, rescoreElement: function (t) {
            this.sinkDown(this.content.indexOf(t))
        }, sinkDown: function (t) {
            for (var e = this.content[t]; t > 0;) {
                var n = (t + 1 >> 1) - 1, r = this.content[n];
                if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;
                this.content[n] = e, this.content[t] = r, t = n
            }
        }, bubbleUp: function (t) {
            for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n); ;) {
                var i, o = t + 1 << 1, s = o - 1, a = null;
                if (s < e) {
                    var u = this.content[s];
                    (i = this.scoreFunction(u)) < r && (a = s)
                }
                if (o < e) {
                    var l = this.content[o];
                    this.scoreFunction(l) < (null === a ? r : i) && (a = o)
                }
                if (null === a) break;
                this.content[t] = this.content[a], this.content[a] = n, t = a
            }
        }
    }, Aa.prototype = {
        constructor: Aa, insert: function (t, e) {
            var n, r, i;
            if (t) {
                if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) {
                    for (t = t.R; t.L;) t = t.L;
                    t.L = e
                } else t.R = e;
                n = t
            } else this._ ? (t = Ga(this._), e.P = null, e.N = t, t.P = t.L = e, n = t) : (e.P = e.N = null, this._ = e, n = null);
            for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;) n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && (Fa(this, n), n = (t = n).U), n.C = !1, r.C = !0, qa(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (qa(this, n), n = (t = n).U), n.C = !1, r.C = !0, Fa(this, r)), n = t.U;
            this._.C = !1
        }, remove: function (t) {
            t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null;
            var e, n, r, i = t.U, o = t.L, s = t.R;
            if (n = o ? s ? Ga(s) : o : s, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && s ? (r = n.C, n.C = t.C, n.L = o, o.U = n, n !== s ? (i = n.U, n.U = t.U, t = n.R, i.L = t, n.R = s, s.U = n) : (n.U = i, i = n, t = n.R)) : (r = t.C, t = n), t && (t.U = i), !r) if (t && t.C) t.C = !1; else {
                do {
                    if (t === this._) break;
                    if (t === i.L) {
                        if ((e = i.R).C && (e.C = !1, i.C = !0, Fa(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) {
                            e.R && e.R.C || (e.L.C = !1, e.C = !0, qa(this, e), e = i.R), e.C = i.C, i.C = e.R.C = !1, Fa(this, i), t = this._;
                            break
                        }
                    } else if ((e = i.L).C && (e.C = !1, i.C = !0, qa(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) {
                        e.L && e.L.C || (e.R.C = !1, e.C = !0, Fa(this, e), e = i.L), e.C = i.C, i.C = e.L.C = !1, qa(this, i), t = this._;
                        break
                    }
                    e.C = !0, t = i, i = i.U
                } while (!t.C);
                t && (t.C = !1)
            }
        }
    };
    var Ha, Wa = [];

    function Ja() {
        Da(this), this.x = this.y = this.arc = this.site = this.cy = null
    }

    function Qa(t) {
        var e = t.P, n = t.N;
        if (e && n) {
            var r = e.site, i = t.site, o = n.site;
            if (r !== o) {
                var s = i[0], a = i[1], u = r[0] - s, l = r[1] - a, h = o[0] - s, c = o[1] - a, f = 2 * (u * c - l * h);
                if (!(f >= -fu)) {
                    var g = u * u + l * l, p = h * h + c * c, v = (c * g - l * p) / f, d = (u * p - h * g) / f,
                        y = Wa.pop() || new Ja;
                    y.arc = t, y.site = i, y.x = v + s, y.y = (y.cy = d + a) + Math.sqrt(v * v + d * d), t.circle = y;
                    for (var m = null, _ = lu._; _;) if (y.y < _.y || y.y === _.y && y.x <= _.x) {
                        if (!_.L) {
                            m = _.P;
                            break
                        }
                        _ = _.L
                    } else {
                        if (!_.R) {
                            m = _;
                            break
                        }
                        _ = _.R
                    }
                    lu.insert(m, y), m || (Ha = y)
                }
            }
        }
    }

    function Ka(t) {
        var e = t.circle;
        e && (e.P || (Ha = e.N), lu.remove(e), Wa.push(e), Da(e), t.circle = null)
    }

    var $a = [];

    function tu() {
        Da(this), this.edge = this.site = this.circle = null
    }

    function eu(t) {
        var e = $a.pop() || new tu;
        return e.site = t, e
    }

    function nu(t) {
        Ka(t), au.remove(t), $a.push(t), Da(t)
    }

    function ru(t) {
        var e = t.circle, n = e.x, r = e.cy, i = [n, r], o = t.P, s = t.N, a = [t];
        nu(t);
        for (var u = o; u.circle && Math.abs(n - u.circle.x) < cu && Math.abs(r - u.circle.cy) < cu;) o = u.P, a.unshift(u), nu(u), u = o;
        a.unshift(u), Ka(u);
        for (var l = s; l.circle && Math.abs(n - l.circle.x) < cu && Math.abs(r - l.circle.cy) < cu;) s = l.N, a.push(l), nu(l), l = s;
        a.push(l), Ka(l);
        var h, c = a.length;
        for (h = 1; h < c; ++h) l = a[h], u = a[h - 1], za(l.edge, u.site, l.site, i);
        u = a[0], (l = a[c - 1]).edge = Ya(u.site, l.site, null, i), Qa(u), Qa(l)
    }

    function iu(t) {
        for (var e, n, r, i, o = t[0], s = t[1], a = au._; a;) if ((r = ou(a, s) - o) > cu) a = a.L; else {
            if (!((i = o - su(a, s)) > cu)) {
                r > -cu ? (e = a.P, n = a) : i > -cu ? (e = a, n = a.N) : e = n = a;
                break
            }
            if (!a.R) {
                e = a;
                break
            }
            a = a.R
        }
        !function (t) {
            uu[t.index] = {site: t, halfedges: []}
        }(t);
        var u = eu(t);
        if (au.insert(e, u), e || n) {
            if (e === n) return Ka(e), n = eu(e.site), au.insert(u, n), u.edge = n.edge = Ya(e.site, u.site), Qa(e), void Qa(n);
            if (n) {
                Ka(e), Ka(n);
                var l = e.site, h = l[0], c = l[1], f = t[0] - h, g = t[1] - c, p = n.site, v = p[0] - h, d = p[1] - c,
                    y = 2 * (f * d - g * v), m = f * f + g * g, _ = v * v + d * d,
                    x = [(d * m - g * _) / y + h, (f * _ - v * m) / y + c];
                za(n.edge, l, p, x), u.edge = Ya(l, t, null, x), n.edge = Ya(t, p, null, x), Qa(e), Qa(n)
            } else u.edge = Ya(e.site, u.site)
        }
    }

    function ou(t, e) {
        var n = t.site, r = n[0], i = n[1], o = i - e;
        if (!o) return r;
        var s = t.P;
        if (!s) return -1 / 0;
        var a = (n = s.site)[0], u = n[1], l = u - e;
        if (!l) return a;
        var h = a - r, c = 1 / o - 1 / l, f = h / l;
        return c ? (-f + Math.sqrt(f * f - 2 * c * (h * h / (-2 * l) - u + l / 2 + i - o / 2))) / c + r : (r + a) / 2
    }

    function su(t, e) {
        var n = t.N;
        if (n) return ou(n, e);
        var r = t.site;
        return r[1] === e ? r[0] : 1 / 0
    }

    var au, uu, lu, hu, cu = 1e-6, fu = 1e-12;

    function gu(t, e) {
        return e[1] - t[1] || e[0] - t[0]
    }

    function pu(t, e) {
        var n, r, i, o = t.sort(gu).pop();
        for (hu = [], uu = new Array(t.length), au = new Aa, lu = new Aa; ;) if (i = Ha, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x)) o[0] === n && o[1] === r || (iu(o), n = o[0], r = o[1]), o = t.pop(); else {
            if (!i) break;
            ru(i.arc)
        }
        if (function () {
            for (var t, e, n, r, i = 0, o = uu.length; i < o; ++i) if ((t = uu[i]) && (r = (e = t.halfedges).length)) {
                var s = new Array(r), a = new Array(r);
                for (n = 0; n < r; ++n) s[n] = n, a[n] = Ua(t, hu[e[n]]);
                for (s.sort((function (t, e) {
                    return a[e] - a[t]
                })), n = 0; n < r; ++n) a[n] = e[s[n]];
                for (n = 0; n < r; ++n) e[n] = a[n]
            }
        }(), e) {
            var s = +e[0][0], a = +e[0][1], u = +e[1][0], l = +e[1][1];
            !function (t, e, n, r) {
                for (var i, o = hu.length; o--;) ja(i = hu[o], t, e, n, r) && Xa(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > cu || Math.abs(i[0][1] - i[1][1]) > cu) || delete hu[o]
            }(s, a, u, l), function (t, e, n, r) {
                var i, o, s, a, u, l, h, c, f, g, p, v, d = uu.length, y = !0;
                for (i = 0; i < d; ++i) if (o = uu[i]) {
                    for (s = o.site, a = (u = o.halfedges).length; a--;) hu[u[a]] || u.splice(a, 1);
                    for (a = 0, l = u.length; a < l;) p = (g = Za(o, hu[u[a]]))[0], v = g[1], c = (h = Va(o, hu[u[++a % l]]))[0], f = h[1], (Math.abs(p - c) > cu || Math.abs(v - f) > cu) && (u.splice(a, 0, hu.push(Ba(s, g, Math.abs(p - t) < cu && r - v > cu ? [t, Math.abs(c - t) < cu ? f : r] : Math.abs(v - r) < cu && n - p > cu ? [Math.abs(f - r) < cu ? c : n, r] : Math.abs(p - n) < cu && v - e > cu ? [n, Math.abs(c - n) < cu ? f : e] : Math.abs(v - e) < cu && p - t > cu ? [Math.abs(f - e) < cu ? c : t, e] : null)) - 1), ++l);
                    l && (y = !1)
                }
                if (y) {
                    var m, _, x, E = 1 / 0;
                    for (i = 0, y = null; i < d; ++i) (o = uu[i]) && (x = (m = (s = o.site)[0] - t) * m + (_ = s[1] - e) * _) < E && (E = x, y = o);
                    if (y) {
                        var k = [t, e], w = [t, r], b = [n, r], I = [n, e];
                        y.halfedges.push(hu.push(Ba(s = y.site, k, w)) - 1, hu.push(Ba(s, w, b)) - 1, hu.push(Ba(s, b, I)) - 1, hu.push(Ba(s, I, k)) - 1)
                    }
                }
                for (i = 0; i < d; ++i) (o = uu[i]) && (o.halfedges.length || delete uu[i])
            }(s, a, u, l)
        }
        this.edges = hu, this.cells = uu, au = lu = hu = uu = null
    }

    function vu(t) {
        return (t = t.slice()).push(t[0]), m([t])
    }

    function du(t, e, n, r) {
        var i = (r = r || {}).steps || 64, o = r.units || "kilometers", s = r.angle || 0, a = r.pivot || t,
            u = r.properties || t.properties || {};
        if (!t) throw new Error("center is required");
        if (!e) throw new Error("xSemiAxis is required");
        if (!n) throw new Error("ySemiAxis is required");
        if (!F(r)) throw new Error("options must be an object");
        if (!D(i)) throw new Error("steps must be a number");
        if (!D(s)) throw new Error("angle must be a number");
        var l = st(t);
        if ("degrees" === o) var h = T(s); else e = _o(t, e, 90, {units: o}), n = _o(t, n, 0, {units: o}), e = st(e)[0] - l[0], n = st(n)[1] - l[1];
        for (var c = [], f = 0; f < i; f += 1) {
            var g = -360 * f / i, p = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(yu(g), 2)),
                v = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(yu(g), 2));
            if (g < -90 && g >= -270 && (p = -p), g < -180 && g >= -360 && (v = -v), "degrees" === o) {
                var d = p * Math.cos(h) + v * Math.sin(h), y = v * Math.cos(h) - p * Math.sin(h);
                p = d, v = y
            }
            c.push([p + l[0], v + l[1]])
        }
        return c.push(c[0]), "degrees" === o ? m([c], u) : Ls(m([c], u), s, {pivot: a})
    }

    function yu(t) {
        var e = t * Math.PI / 180;
        return Math.tan(e)
    }

    function mu(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = 0, r = 0, i = 0;
        return H(t, (function (t, o, s) {
            var a = e.weight ? null == s ? void 0 : s[e.weight] : void 0;
            if (!D(a = null == a ? 1 : a)) throw new Error("weight value must be a number for feature index " + o);
            (a = Number(a)) > 0 && B(t, (function (t) {
                n += t[0] * a, r += t[1] * a, i += a
            }))
        })), d([n / i, r / i], e.properties, e)
    }

    function _u(t, e, n, r, i) {
        var o = r.tolerance || .001, s = 0, a = 0, u = 0, l = 0;
        if (U(n, (function (e) {
            var n, r = null === (n = e.properties) || void 0 === n ? void 0 : n.weight, i = null == r ? 1 : r;
            if (!D(i = Number(i))) throw new Error("weight value must be a number");
            if (i > 0) {
                l += 1;
                var o = i * xe(e, t);
                0 === o && (o = 1);
                var h = i / o;
                s += e.geometry.coordinates[0] * h, a += e.geometry.coordinates[1] * h, u += h
            }
        })), l < 1) throw new Error("no features to measure");
        var h = s / u, c = a / u;
        return 1 === l || 0 === i || Math.abs(h - e[0]) < o && Math.abs(c - e[1]) < o ? d([h, c], {medianCandidates: r.medianCandidates}) : (r.medianCandidates.push([h, c]), _u([h, c], t, n, r, i - 1))
    }

    function xu(t, e) {
        return {x: t[0] - e[0], y: t[1] - e[1]}
    }

    function Eu(t, e) {
        var n = null, r = null;
        B(t, (function (t, i, o, s, a) {
            if (r !== a) e.push([]); else {
                var u = n[0], l = n[1], h = t[0], c = t[1];
                e[a].push([.75 * u + .25 * h, .75 * l + .25 * c]), e[a].push([.25 * u + .75 * h, .25 * l + .75 * c])
            }
            n = t, r = a
        }), !1), e.forEach((function (t) {
            t.push(t[0])
        }))
    }

    function ku(t, e) {
        var n = null, r = null, i = null;
        B(t, (function (t, o, s, a, u) {
            if (r !== a) e.push([[]]); else if (i !== u) e[a].push([]); else {
                var l = n[0], h = n[1], c = t[0], f = t[1];
                e[a][u].push([.75 * l + .25 * c, .75 * h + .25 * f]), e[a][u].push([.25 * l + .75 * c, .25 * h + .75 * f])
            }
            n = t, r = a, i = u
        }), !1), e.forEach((function (t) {
            t.forEach((function (t) {
                t.push(t[0])
            }))
        }))
    }

    function wu(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, r = st(t), i = st(e),
            o = r[0] - i[0], s = r[1] - i[1];
        return 1 === n ? Math.abs(o) + Math.abs(s) : Math.pow(Math.pow(o, n) + Math.pow(s, n), 1 / n)
    }

    function bu(t, e) {
        var n = (e = e || {}).threshold || 1e4, r = e.p || 2, i = e.binary || !1, o = e.alpha || -1,
            s = e.standardization || !1, a = [];
        U(t, (function (t) {
            a.push(Sn(t))
        }));
        for (var u = [], l = 0; l < a.length; l++) u[l] = [];
        for (var h = 0; h < a.length; h++) for (var c = h; c < a.length; c++) {
            h === c && (u[h][c] = 0);
            var f = wu(a[h], a[c], r);
            u[h][c] = f, u[c][h] = f
        }
        for (var g = 0; g < a.length; g++) for (var p = 0; p < a.length; p++) {
            var v = u[g][p];
            0 !== v && (u[g][p] = i ? v <= n ? 1 : 0 : v <= n ? Math.pow(v, o) : 0)
        }
        if (s) for (var d = 0; d < a.length; d++) for (var y = u[d].reduce((function (t, e) {
            return t + e
        }), 0), m = 0; m < a.length; m++) u[d][m] = u[d][m] / y;
        return u
    }

    function Iu(t) {
        var e, n = 0, r = h(t);
        try {
            for (r.s(); !(e = r.n()).done;) {
                n += e.value
            }
        } catch (t) {
            r.e(t)
        } finally {
            r.f()
        }
        return n / t.length
    }

    function Su(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Mu(t, "mercator", e)
    }

    function Nu(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Mu(t, "wgs84", e)
    }

    function Mu(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = (n = n || {}).mutate;
        if (!t) throw new Error("geojson is required");
        return Array.isArray(t) && D(t[0]) ? t = "mercator" === e ? Pu(t) : Lu(t) : (!0 !== r && (t = Ie(t)), B(t, (function (t) {
            var n = "mercator" === e ? Pu(t) : Lu(t);
            t[0] = n[0], t[1] = n[1]
        }))), t
    }

    function Pu(t) {
        var e = Math.PI / 180, n = 6378137, r = 20037508.342789244,
            i = Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * function (t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            }(t[0]), o = [n * i * e, n * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * e))];
        return o[0] > r && (o[0] = r), o[0] < -r && (o[0] = -r), o[1] > r && (o[1] = r), o[1] < -r && (o[1] = -r), o
    }

    function Lu(t) {
        var e = 180 / Math.PI, n = 6378137;
        return [t[0] * e / n, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e]
    }

    pu.prototype = {
        constructor: pu, polygons: function () {
            var t = this.edges;
            return this.cells.map((function (e) {
                var n = e.halfedges.map((function (n) {
                    return Va(e, t[n])
                }));
                return n.data = e.site.data, n
            }))
        }, triangles: function () {
            var t = [], e = this.edges;
            return this.cells.forEach((function (n, r) {
                if (o = (i = n.halfedges).length) for (var i, o, s, a, u, l, h = n.site, c = -1, f = e[i[o - 1]], g = f.left === h ? f.right : f.left; ++c < o;) s = g, g = (f = e[i[c]]).left === h ? f.right : f.left, s && g && r < s.index && r < g.index && (u = s, l = g, ((a = h)[0] - l[0]) * (u[1] - a[1]) - (a[0] - u[0]) * (l[1] - a[1]) < 0) && t.push([h.data, s.data, g.data])
            })), t
        }, links: function () {
            return this.edges.filter((function (t) {
                return t.right
            })).map((function (t) {
                return {source: t.left.data, target: t.right.data}
            }))
        }, find: function (t, e, n) {
            for (var r, i, o = this, s = o._found || 0, a = o.cells.length; !(i = o.cells[s]);) if (++s >= a) return null;
            var u = t - i.site[0], l = e - i.site[1], h = u * u + l * l;
            do {
                i = o.cells[r = s], s = null, i.halfedges.forEach((function (n) {
                    var r = o.edges[n], a = r.left;
                    if (a !== i.site && a || (a = r.right)) {
                        var u = t - a[0], l = e - a[1], c = u * u + l * l;
                        c < h && (h = c, s = a.index)
                    }
                }))
            } while (null !== s);
            return o._found = r, null == n || h <= n * n ? i.site : null
        }
    };
    var Cu = Object.freeze({__proto__: null, toMercator: Su, toWgs84: Nu});

    function Ru(t) {
        return Ou(t), Tu(t)
    }

    function Tu(t) {
        return Array.isArray(t) ? Yu(t) : t && t.bbox ? Yu(t.bbox) : [360 * Gu(), 180 * Gu()]
    }

    function Ou(t) {
        null != t && (Array.isArray(t) ? q(t) : null != t.bbox && q(t.bbox))
    }

    function Au(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        Ou(e.bbox), null == t && (t = 1);
        for (var n = [], r = 0; r < t; r++) n.push(d(Tu(e.bbox)));
        return k(n)
    }

    function Du(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        Ou(e.bbox), null == t && (t = 1), D(e.num_vertices) && void 0 !== e.num_vertices || (e.num_vertices = 10), D(e.max_radial_length) && void 0 !== e.max_radial_length || (e.max_radial_length = 10);
        for (var n = [], r = function (t) {
            var r = [], i = a(Array(e.num_vertices + 1)).map(Math.random);
            i.forEach((function (t, e, n) {
                n[e] = e > 0 ? t + n[e - 1] : t
            })), i.forEach((function (t) {
                t = 2 * t * Math.PI / i[i.length - 1];
                var n = Math.random();
                r.push([n * (e.max_radial_length || 10) * Math.sin(t), n * (e.max_radial_length || 10) * Math.cos(t)])
            })), r[r.length - 1] = r[0], r = r.map(qu(Tu(e.bbox))), n.push(m([r]))
        }, i = 0; i < t; i++) r();
        return k(n)
    }

    function Fu(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox;
        Ou(n);
        var r = e.num_vertices, i = e.max_length, o = e.max_rotation;
        null == t && (t = 1), (!D(r) || void 0 === r || r < 2) && (r = 10), D(i) && void 0 !== i || (i = 1e-4), D(o) && void 0 !== o || (o = Math.PI / 8);
        for (var s = [], a = 0; a < t; a++) {
            for (var u = Tu(n), l = [u], h = 0; h < r - 1; h++) {
                var c = 0 === h ? 2 * Math.random() * Math.PI : Math.tan((l[h][1] - l[h - 1][1]) / (l[h][0] - l[h - 1][0])),
                    f = c + (Math.random() - .5) * o * 2, g = Math.random() * i;
                l.push([l[h][0] + g * Math.cos(f), l[h][1] + g * Math.sin(f)])
            }
            s.push(x(l))
        }
        return k(s)
    }

    function qu(t) {
        return function (e) {
            return [e[0] + t[0], e[1] + t[1]]
        }
    }

    function Gu() {
        return Math.random() - .5
    }

    function Yu(t) {
        return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]]
    }

    var Bu = Object.freeze({
        __proto__: null,
        randomPosition: Ru,
        randomPoint: Au,
        randomPolygon: Du,
        randomLineString: Fu
    });

    function zu(t, e) {
        if (!t) throw new Error("geojson is required");
        if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection");
        if (null == e) throw new Error("filter is required");
        var n = [];
        return U(t, (function (t) {
            Vu(t.properties, e) && n.push(t)
        })), k(n)
    }

    function Xu(t, e, n) {
        if (!t) throw new Error("geojson is required");
        if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection");
        if (null == e) throw new Error("property is required");
        for (var r = Uu(t, e), i = Object.keys(r), o = 0; o < i.length; o++) {
            for (var s = i[o], a = r[s], u = [], l = 0; l < a.length; l++) u.push(t.features[a[l]]);
            n(k(u), s, o)
        }
    }

    function ju(t, e, n, r) {
        var i = r;
        return Xu(t, e, (function (t, e, o) {
            i = 0 === o && void 0 === r ? t : n(i, t, e, o)
        })), i
    }

    function Uu(t, e) {
        var n = {};
        return U(t, (function (t, r) {
            var i = t.properties || {};
            if (Object.prototype.hasOwnProperty.call(i, String(e))) {
                var o = i[e];
                Object.prototype.hasOwnProperty.call(n, o) ? n[o].push(r) : n[o] = [r]
            }
        })), n
    }

    function Vu(t, n) {
        if (void 0 === t) return !1;
        var r = e(n);
        if ("number" === r || "string" === r) return Object.prototype.hasOwnProperty.call(t, n);
        if (Array.isArray(n)) {
            for (var i = 0; i < n.length; i++) if (!Vu(t, n[i])) return !1;
            return !0
        }
        return Zu(t, n)
    }

    function Zu(t, e) {
        for (var n = Object.keys(e), r = 0; r < n.length; r++) {
            var i = n[r];
            if (t[i] !== e[i]) return !1
        }
        return !0
    }

    function Hu(t, e) {
        if (!e) return {};
        if (!e.length) return {};
        for (var n = {}, r = 0; r < e.length; r++) {
            var i = e[r];
            Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }

    var Wu = Object.freeze({
        __proto__: null,
        getCluster: zu,
        clusterEach: Xu,
        clusterReduce: ju,
        createBins: Uu,
        applyFilter: Vu,
        propertiesContainsFilter: Zu,
        filterProperties: Hu
    }), Ju = function (t, e) {
        this.next = null, this.key = t, this.data = e, this.left = null, this.right = null
    };

    /**
     * splaytree v3.1.0
     * Fast Splay tree for Node and browser
     *
     * @author Alexander Milevski <info@w8r.name>
     * @license MIT
     * @preserve
     */function Qu(t, e) {
        return t > e ? 1 : t < e ? -1 : 0
    }

    function Ku(t, e, n) {
        for (var r = new Ju(null, null), i = r, o = r; ;) {
            var s = n(t, e.key);
            if (s < 0) {
                if (null === e.left) break;
                if (n(t, e.left.key) < 0) {
                    var a = e.left;
                    if (e.left = a.right, a.right = e, null === (e = a).left) break
                }
                o.left = e, o = e, e = e.left
            } else {
                if (!(s > 0)) break;
                if (null === e.right) break;
                if (n(t, e.right.key) > 0) {
                    a = e.right;
                    if (e.right = a.left, a.left = e, null === (e = a).right) break
                }
                i.right = e, i = e, e = e.right
            }
        }
        return i.right = e.left, o.left = e.right, e.left = r.right, e.right = r.left, e
    }

    function $u(t, e, n, r) {
        var i = new Ju(t, e);
        if (null === n) return i.left = i.right = null, i;
        var o = r(t, (n = Ku(t, n, r)).key);
        return o < 0 ? (i.left = n.left, i.right = n, n.left = null) : o >= 0 && (i.right = n.right, i.left = n, n.right = null), i
    }

    function tl(t, e, n) {
        var r = null, i = null;
        if (e) {
            var o = n((e = Ku(t, e, n)).key, t);
            0 === o ? (r = e.left, i = e.right) : o < 0 ? (i = e.right, e.right = null, r = e) : (r = e.left, e.left = null, i = e)
        }
        return {left: r, right: i}
    }

    function el(t, e, n, r, i) {
        if (t) {
            r(e + (n ? " " : " ") + i(t) + "\n");
            var o = e + (n ? "    " : "   ");
            t.left && el(t.left, o, !1, r, i), t.right && el(t.right, o, !0, r, i)
        }
    }

    var nl = function () {
        function t(t) {
            void 0 === t && (t = Qu), this._root = null, this._size = 0, this._comparator = t
        }

        return t.prototype.insert = function (t, e) {
            return this._size++, this._root = $u(t, e, this._root, this._comparator)
        }, t.prototype.add = function (t, e) {
            var n = new Ju(t, e);
            null === this._root && (n.left = n.right = null, this._size++, this._root = n);
            var r = this._comparator, i = Ku(t, this._root, r), o = r(t, i.key);
            return 0 === o ? this._root = i : (o < 0 ? (n.left = i.left, n.right = i, i.left = null) : o > 0 && (n.right = i.right, n.left = i, i.right = null), this._size++, this._root = n), this._root
        }, t.prototype.remove = function (t) {
            this._root = this._remove(t, this._root, this._comparator)
        }, t.prototype._remove = function (t, e, n) {
            var r;
            return null === e ? null : 0 === n(t, (e = Ku(t, e, n)).key) ? (null === e.left ? r = e.right : (r = Ku(t, e.left, n)).right = e.right, this._size--, r) : e
        }, t.prototype.pop = function () {
            var t = this._root;
            if (t) {
                for (; t.left;) t = t.left;
                return this._root = Ku(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), {
                    key: t.key,
                    data: t.data
                }
            }
            return null
        }, t.prototype.findStatic = function (t) {
            for (var e = this._root, n = this._comparator; e;) {
                var r = n(t, e.key);
                if (0 === r) return e;
                e = r < 0 ? e.left : e.right
            }
            return null
        }, t.prototype.find = function (t) {
            return this._root && (this._root = Ku(t, this._root, this._comparator), 0 !== this._comparator(t, this._root.key)) ? null : this._root
        }, t.prototype.contains = function (t) {
            for (var e = this._root, n = this._comparator; e;) {
                var r = n(t, e.key);
                if (0 === r) return !0;
                e = r < 0 ? e.left : e.right
            }
            return !1
        }, t.prototype.forEach = function (t, e) {
            for (var n = this._root, r = [], i = !1; !i;) null !== n ? (r.push(n), n = n.left) : 0 !== r.length ? (n = r.pop(), t.call(e, n), n = n.right) : i = !0;
            return this
        }, t.prototype.range = function (t, e, n, r) {
            for (var i = [], o = this._comparator, s = this._root; 0 !== i.length || s;) if (s) i.push(s), s = s.left; else {
                if (o((s = i.pop()).key, e) > 0) break;
                if (o(s.key, t) >= 0 && n.call(r, s)) return this;
                s = s.right
            }
            return this
        }, t.prototype.keys = function () {
            var t = [];
            return this.forEach((function (e) {
                var n = e.key;
                return t.push(n)
            })), t
        }, t.prototype.values = function () {
            var t = [];
            return this.forEach((function (e) {
                var n = e.data;
                return t.push(n)
            })), t
        }, t.prototype.min = function () {
            return this._root ? this.minNode(this._root).key : null
        }, t.prototype.max = function () {
            return this._root ? this.maxNode(this._root).key : null
        }, t.prototype.minNode = function (t) {
            if (void 0 === t && (t = this._root), t) for (; t.left;) t = t.left;
            return t
        }, t.prototype.maxNode = function (t) {
            if (void 0 === t && (t = this._root), t) for (; t.right;) t = t.right;
            return t
        }, t.prototype.at = function (t) {
            for (var e = this._root, n = !1, r = 0, i = []; !n;) if (e) i.push(e), e = e.left; else if (i.length > 0) {
                if (e = i.pop(), r === t) return e;
                r++, e = e.right
            } else n = !0;
            return null
        }, t.prototype.next = function (t) {
            var e = this._root, n = null;
            if (t.right) {
                for (n = t.right; n.left;) n = n.left;
                return n
            }
            for (var r = this._comparator; e;) {
                var i = r(t.key, e.key);
                if (0 === i) break;
                i < 0 ? (n = e, e = e.left) : e = e.right
            }
            return n
        }, t.prototype.prev = function (t) {
            var e = this._root, n = null;
            if (null !== t.left) {
                for (n = t.left; n.right;) n = n.right;
                return n
            }
            for (var r = this._comparator; e;) {
                var i = r(t.key, e.key);
                if (0 === i) break;
                i < 0 ? e = e.left : (n = e, e = e.right)
            }
            return n
        }, t.prototype.clear = function () {
            return this._root = null, this._size = 0, this
        }, t.prototype.toList = function () {
            return function (t) {
                var e = t, n = [], r = !1, i = new Ju(null, null), o = i;
                for (; !r;) e ? (n.push(e), e = e.left) : n.length > 0 ? e = (e = o = o.next = n.pop()).right : r = !0;
                return o.next = null, i.next
            }(this._root)
        }, t.prototype.load = function (t, e, n) {
            void 0 === e && (e = []), void 0 === n && (n = !1);
            var r = t.length, i = this._comparator;
            if (n && ol(t, e, 0, r - 1, i), null === this._root) this._root = rl(t, e, 0, r), this._size = r; else {
                var o = function (t, e, n) {
                    var r = new Ju(null, null), i = r, o = t, s = e;
                    for (; null !== o && null !== s;) n(o.key, s.key) < 0 ? (i.next = o, o = o.next) : (i.next = s, s = s.next), i = i.next;
                    null !== o ? i.next = o : null !== s && (i.next = s);
                    return r.next
                }(this.toList(), function (t, e) {
                    for (var n = new Ju(null, null), r = n, i = 0; i < t.length; i++) r = r.next = new Ju(t[i], e[i]);
                    return r.next = null, n.next
                }(t, e), i);
                r = this._size + r, this._root = il({head: o}, 0, r)
            }
            return this
        }, t.prototype.isEmpty = function () {
            return null === this._root
        }, Object.defineProperty(t.prototype, "size", {
            get: function () {
                return this._size
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "root", {
            get: function () {
                return this._root
            }, enumerable: !0, configurable: !0
        }), t.prototype.toString = function (t) {
            void 0 === t && (t = function (t) {
                return String(t.key)
            });
            var e = [];
            return el(this._root, "", !0, (function (t) {
                return e.push(t)
            }), t), e.join("")
        }, t.prototype.update = function (t, e, n) {
            var r = this._comparator, i = tl(t, this._root, r), o = i.left, s = i.right;
            r(t, e) < 0 ? s = $u(e, n, s, r) : o = $u(e, n, o, r), this._root = function (t, e, n) {
                return null === e ? t : (null === t || ((e = Ku(t.key, e, n)).left = t), e)
            }(o, s, r)
        }, t.prototype.split = function (t) {
            return tl(t, this._root, this._comparator)
        }, t
    }();

    function rl(t, e, n, r) {
        var i = r - n;
        if (i > 0) {
            var o = n + Math.floor(i / 2), s = t[o], a = e[o], u = new Ju(s, a);
            return u.left = rl(t, e, n, o), u.right = rl(t, e, o + 1, r), u
        }
        return null
    }

    function il(t, e, n) {
        var r = n - e;
        if (r > 0) {
            var i = e + Math.floor(r / 2), o = il(t, e, i), s = t.head;
            return s.left = o, t.head = t.head.next, s.right = il(t, i + 1, n), s
        }
        return null
    }

    function ol(t, e, n, r, i) {
        if (!(n >= r)) {
            for (var o = t[n + r >> 1], s = n - 1, a = r + 1; ;) {
                do {
                    s++
                } while (i(t[s], o) < 0);
                do {
                    a--
                } while (i(t[a], o) > 0);
                if (s >= a) break;
                var u = t[s];
                t[s] = t[a], t[a] = u, u = e[s], e[s] = e[a], e[a] = u
            }
            ol(t, e, n, a, i), ol(t, e, a + 1, r, i)
        }
    }

    function sl(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function al(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }

    function ul(t, e, n) {
        return e && al(t.prototype, e), n && al(t, n), t
    }

    var ll = function (t, e) {
        return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y
    }, hl = function (t, e) {
        if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;
        var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x, r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;
        return {ll: {x: n, y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y}, ur: {x: r, y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y}}
    }, cl = Number.EPSILON;
    void 0 === cl && (cl = Math.pow(2, -52));
    var fl = cl * cl, gl = function (t, e) {
            if (-cl < t && t < cl && -cl < e && e < cl) return 0;
            var n = t - e;
            return n * n < fl * t * e ? 0 : t < e ? -1 : 1
        }, pl = function () {
            function t() {
                sl(this, t), this.reset()
            }

            return ul(t, [{
                key: "reset", value: function () {
                    this.xRounder = new vl, this.yRounder = new vl
                }
            }, {
                key: "round", value: function (t, e) {
                    return {x: this.xRounder.round(t), y: this.yRounder.round(e)}
                }
            }]), t
        }(), vl = function () {
            function t() {
                sl(this, t), this.tree = new nl, this.round(0)
            }

            return ul(t, [{
                key: "round", value: function (t) {
                    var e = this.tree.add(t), n = this.tree.prev(e);
                    if (null !== n && 0 === gl(e.key, n.key)) return this.tree.remove(t), n.key;
                    var r = this.tree.next(e);
                    return null !== r && 0 === gl(e.key, r.key) ? (this.tree.remove(t), r.key) : t
                }
            }]), t
        }(), dl = new pl, yl = function (t, e) {
            return t.x * e.y - t.y * e.x
        }, ml = function (t, e) {
            return t.x * e.x + t.y * e.y
        }, _l = function (t, e, n) {
            var r = {x: e.x - t.x, y: e.y - t.y}, i = {x: n.x - t.x, y: n.y - t.y}, o = yl(r, i);
            return gl(o, 0)
        }, xl = function (t) {
            return Math.sqrt(ml(t, t))
        }, El = function (t, e, n) {
            var r = {x: e.x - t.x, y: e.y - t.y}, i = {x: n.x - t.x, y: n.y - t.y};
            return ml(i, r) / xl(i) / xl(r)
        }, kl = function (t, e, n) {
            return 0 === e.y ? null : {x: t.x + e.x / e.y * (n - t.y), y: n}
        }, wl = function (t, e, n) {
            return 0 === e.x ? null : {x: n, y: t.y + e.y / e.x * (n - t.x)}
        }, bl = function () {
            function t(e, n) {
                sl(this, t), void 0 === e.events ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = n
            }

            return ul(t, null, [{
                key: "compare", value: function (e, n) {
                    var r = t.comparePoints(e.point, n.point);
                    return 0 !== r ? r : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : Sl.compare(e.segment, n.segment))
                }
            }, {
                key: "comparePoints", value: function (t, e) {
                    return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0
                }
            }]), ul(t, [{
                key: "link", value: function (t) {
                    if (t.point === this.point) throw new Error("Tried to link already linked events");
                    for (var e = t.point.events, n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        this.point.events.push(i), i.point = this.point
                    }
                    this.checkForConsuming()
                }
            }, {
                key: "checkForConsuming", value: function () {
                    for (var t = this.point.events.length, e = 0; e < t; e++) {
                        var n = this.point.events[e];
                        if (void 0 === n.segment.consumedBy) for (var r = e + 1; r < t; r++) {
                            var i = this.point.events[r];
                            void 0 === i.consumedBy && (n.otherSE.point.events === i.otherSE.point.events && n.segment.consume(i.segment))
                        }
                    }
                }
            }, {
                key: "getAvailableLinkedEvents", value: function () {
                    for (var t = [], e = 0, n = this.point.events.length; e < n; e++) {
                        var r = this.point.events[e];
                        r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r)
                    }
                    return t
                }
            }, {
                key: "getLeftmostComparator", value: function (t) {
                    var e = this, n = new Map, r = function (r) {
                        var i, o, s, a, u, l = r.otherSE;
                        n.set(r, {
                            sine: (i = e.point, o = t.point, s = l.point, a = {
                                x: o.x - i.x,
                                y: o.y - i.y
                            }, u = {x: s.x - i.x, y: s.y - i.y}, yl(u, a) / xl(u) / xl(a)),
                            cosine: El(e.point, t.point, l.point)
                        })
                    };
                    return function (t, e) {
                        n.has(t) || r(t), n.has(e) || r(e);
                        var i = n.get(t), o = i.sine, s = i.cosine, a = n.get(e), u = a.sine, l = a.cosine;
                        return o >= 0 && u >= 0 ? s < l ? 1 : s > l ? -1 : 0 : o < 0 && u < 0 ? s < l ? -1 : s > l ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0
                    }
                }
            }]), t
        }(), Il = 0, Sl = function () {
            function t(e, n, r, i) {
                sl(this, t), this.id = ++Il, this.leftSE = e, e.segment = this, e.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = e, this.rings = r, this.windings = i
            }

            return ul(t, null, [{
                key: "compare", value: function (t, e) {
                    var n = t.leftSE.point.x, r = e.leftSE.point.x, i = t.rightSE.point.x, o = e.rightSE.point.x;
                    if (o < n) return 1;
                    if (i < r) return -1;
                    var s = t.leftSE.point.y, a = e.leftSE.point.y, u = t.rightSE.point.y, l = e.rightSE.point.y;
                    if (n < r) {
                        if (a < s && a < u) return 1;
                        if (a > s && a > u) return -1;
                        var h = t.comparePoint(e.leftSE.point);
                        if (h < 0) return 1;
                        if (h > 0) return -1;
                        var c = e.comparePoint(t.rightSE.point);
                        return 0 !== c ? c : -1
                    }
                    if (n > r) {
                        if (s < a && s < l) return -1;
                        if (s > a && s > l) return 1;
                        var f = e.comparePoint(t.leftSE.point);
                        if (0 !== f) return f;
                        var g = t.comparePoint(e.rightSE.point);
                        return g < 0 ? 1 : g > 0 ? -1 : 1
                    }
                    if (s < a) return -1;
                    if (s > a) return 1;
                    if (i < o) {
                        var p = e.comparePoint(t.rightSE.point);
                        if (0 !== p) return p
                    }
                    if (i > o) {
                        var v = t.comparePoint(e.rightSE.point);
                        if (v < 0) return 1;
                        if (v > 0) return -1
                    }
                    if (i !== o) {
                        var d = u - s, y = i - n, m = l - a, _ = o - r;
                        if (d > y && m < _) return 1;
                        if (d < y && m > _) return -1
                    }
                    return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0
                }
            }]), ul(t, [{
                key: "replaceRightSE", value: function (t) {
                    this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE
                }
            }, {
                key: "bbox", value: function () {
                    var t = this.leftSE.point.y, e = this.rightSE.point.y;
                    return {ll: {x: this.leftSE.point.x, y: t < e ? t : e}, ur: {x: this.rightSE.point.x, y: t > e ? t : e}}
                }
            }, {
                key: "vector", value: function () {
                    return {x: this.rightSE.point.x - this.leftSE.point.x, y: this.rightSE.point.y - this.leftSE.point.y}
                }
            }, {
                key: "isAnEndpoint", value: function (t) {
                    return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y
                }
            }, {
                key: "comparePoint", value: function (t) {
                    if (this.isAnEndpoint(t)) return 0;
                    var e = this.leftSE.point, n = this.rightSE.point, r = this.vector();
                    if (e.x === n.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
                    var i = (t.y - e.y) / r.y, o = e.x + i * r.x;
                    if (t.x === o) return 0;
                    var s = (t.x - e.x) / r.x, a = e.y + s * r.y;
                    return t.y === a ? 0 : t.y < a ? -1 : 1
                }
            }, {
                key: "getIntersection", value: function (t) {
                    var e = this.bbox(), n = t.bbox(), r = hl(e, n);
                    if (null === r) return null;
                    var i = this.leftSE.point, o = this.rightSE.point, s = t.leftSE.point, a = t.rightSE.point,
                        u = ll(e, s) && 0 === this.comparePoint(s), l = ll(n, i) && 0 === t.comparePoint(i),
                        h = ll(e, a) && 0 === this.comparePoint(a), c = ll(n, o) && 0 === t.comparePoint(o);
                    if (l && u) return c && !h ? o : !c && h ? a : null;
                    if (l) return h && i.x === a.x && i.y === a.y ? null : i;
                    if (u) return c && o.x === s.x && o.y === s.y ? null : s;
                    if (c && h) return null;
                    if (c) return o;
                    if (h) return a;
                    var f = function (t, e, n, r) {
                        if (0 === e.x) return wl(n, r, t.x);
                        if (0 === r.x) return wl(t, e, n.x);
                        if (0 === e.y) return kl(n, r, t.y);
                        if (0 === r.y) return kl(t, e, n.y);
                        var i = yl(e, r);
                        if (0 == i) return null;
                        var o = {x: n.x - t.x, y: n.y - t.y}, s = yl(o, e) / i, a = yl(o, r) / i;
                        return {x: (t.x + a * e.x + (n.x + s * r.x)) / 2, y: (t.y + a * e.y + (n.y + s * r.y)) / 2}
                    }(i, this.vector(), s, t.vector());
                    return null === f ? null : ll(r, f) ? dl.round(f.x, f.y) : null
                }
            }, {
                key: "split", value: function (e) {
                    var n = [], r = void 0 !== e.events, i = new bl(e, !0), o = new bl(e, !1), s = this.rightSE;
                    this.replaceRightSE(o), n.push(o), n.push(i);
                    var a = new t(i, s, this.rings.slice(), this.windings.slice());
                    return bl.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), bl.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (i.checkForConsuming(), o.checkForConsuming()), n
                }
            }, {
                key: "swapEvents", value: function () {
                    var t = this.rightSE;
                    this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
                    for (var e = 0, n = this.windings.length; e < n; e++) this.windings[e] *= -1
                }
            }, {
                key: "consume", value: function (e) {
                    for (var n = this, r = e; n.consumedBy;) n = n.consumedBy;
                    for (; r.consumedBy;) r = r.consumedBy;
                    var i = t.compare(n, r);
                    if (0 !== i) {
                        if (i > 0) {
                            var o = n;
                            n = r, r = o
                        }
                        if (n.prev === r) {
                            var s = n;
                            n = r, r = s
                        }
                        for (var a = 0, u = r.rings.length; a < u; a++) {
                            var l = r.rings[a], h = r.windings[a], c = n.rings.indexOf(l);
                            -1 === c ? (n.rings.push(l), n.windings.push(h)) : n.windings[c] += h
                        }
                        r.rings = null, r.windings = null, r.consumedBy = n, r.leftSE.consumedBy = n.leftSE, r.rightSE.consumedBy = n.rightSE
                    }
                }
            }, {
                key: "prevInResult", value: function () {
                    return void 0 !== this._prevInResult || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult
                }
            }, {
                key: "beforeState", value: function () {
                    if (void 0 !== this._beforeState) return this._beforeState;
                    if (this.prev) {
                        var t = this.prev.consumedBy || this.prev;
                        this._beforeState = t.afterState()
                    } else this._beforeState = {rings: [], windings: [], multiPolys: []};
                    return this._beforeState
                }
            }, {
                key: "afterState", value: function () {
                    if (void 0 !== this._afterState) return this._afterState;
                    var t = this.beforeState();
                    this._afterState = {rings: t.rings.slice(0), windings: t.windings.slice(0), multiPolys: []};
                    for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, i = 0, o = this.rings.length; i < o; i++) {
                        var s = this.rings[i], a = this.windings[i], u = e.indexOf(s);
                        -1 === u ? (e.push(s), n.push(a)) : n[u] += a
                    }
                    for (var l = [], h = [], c = 0, f = e.length; c < f; c++) if (0 !== n[c]) {
                        var g = e[c], p = g.poly;
                        if (-1 === h.indexOf(p)) if (g.isExterior) l.push(p); else {
                            -1 === h.indexOf(p) && h.push(p);
                            var v = l.indexOf(g.poly);
                            -1 !== v && l.splice(v, 1)
                        }
                    }
                    for (var d = 0, y = l.length; d < y; d++) {
                        var m = l[d].multiPoly;
                        -1 === r.indexOf(m) && r.push(m)
                    }
                    return this._afterState
                }
            }, {
                key: "isInResult", value: function () {
                    if (this.consumedBy) return !1;
                    if (void 0 !== this._isInResult) return this._isInResult;
                    var t = this.beforeState().multiPolys, e = this.afterState().multiPolys;
                    switch (Dl.type) {
                        case"union":
                            var n = 0 === t.length, r = 0 === e.length;
                            this._isInResult = n !== r;
                            break;
                        case"intersection":
                            var i, o;
                            t.length < e.length ? (i = t.length, o = e.length) : (i = e.length, o = t.length), this._isInResult = o === Dl.numMultiPolys && i < o;
                            break;
                        case"xor":
                            var s = Math.abs(t.length - e.length);
                            this._isInResult = s % 2 == 1;
                            break;
                        case"difference":
                            var a = function (t) {
                                return 1 === t.length && t[0].isSubject
                            };
                            this._isInResult = a(t) !== a(e);
                            break;
                        default:
                            throw new Error("Unrecognized operation type found ".concat(Dl.type))
                    }
                    return this._isInResult
                }
            }], [{
                key: "fromRing", value: function (e, n, r) {
                    var i, o, s, a = bl.comparePoints(e, n);
                    if (a < 0) i = e, o = n, s = 1; else {
                        if (!(a > 0)) throw new Error("Tried to create degenerate segment at [".concat(e.x, ", ").concat(e.y, "]"));
                        i = n, o = e, s = -1
                    }
                    return new t(new bl(i, !0), new bl(o, !1), [r], [s])
                }
            }]), t
        }(), Nl = function () {
            function t(e, n, r) {
                if (sl(this, t), !Array.isArray(e) || 0 === e.length) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                if (this.poly = n, this.isExterior = r, this.segments = [], "number" != typeof e[0][0] || "number" != typeof e[0][1]) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                var i = dl.round(e[0][0], e[0][1]);
                this.bbox = {ll: {x: i.x, y: i.y}, ur: {x: i.x, y: i.y}};
                for (var o = i, s = 1, a = e.length; s < a; s++) {
                    if ("number" != typeof e[s][0] || "number" != typeof e[s][1]) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    var u = dl.round(e[s][0], e[s][1]);
                    u.x === o.x && u.y === o.y || (this.segments.push(Sl.fromRing(o, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), o = u)
                }
                i.x === o.x && i.y === o.y || this.segments.push(Sl.fromRing(o, i, this))
            }

            return ul(t, [{
                key: "getSweepEvents", value: function () {
                    for (var t = [], e = 0, n = this.segments.length; e < n; e++) {
                        var r = this.segments[e];
                        t.push(r.leftSE), t.push(r.rightSE)
                    }
                    return t
                }
            }]), t
        }(), Ml = function () {
            function t(e, n) {
                if (sl(this, t), !Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                this.exteriorRing = new Nl(e[0], this, !0), this.bbox = {
                    ll: {
                        x: this.exteriorRing.bbox.ll.x,
                        y: this.exteriorRing.bbox.ll.y
                    }, ur: {x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y}
                }, this.interiorRings = [];
                for (var r = 1, i = e.length; r < i; r++) {
                    var o = new Nl(e[r], this, !1);
                    o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.interiorRings.push(o)
                }
                this.multiPoly = n
            }

            return ul(t, [{
                key: "getSweepEvents", value: function () {
                    for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++) for (var r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++) t.push(r[i]);
                    return t
                }
            }]), t
        }(), Pl = function () {
            function t(e, n) {
                if (sl(this, t), !Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                try {
                    "number" == typeof e[0][0][0] && (e = [e])
                } catch (t) {
                }
                this.polys = [], this.bbox = {
                    ll: {x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY},
                    ur: {x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY}
                };
                for (var r = 0, i = e.length; r < i; r++) {
                    var o = new Ml(e[r], this);
                    o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.polys.push(o)
                }
                this.isSubject = n
            }

            return ul(t, [{
                key: "getSweepEvents", value: function () {
                    for (var t = [], e = 0, n = this.polys.length; e < n; e++) for (var r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++) t.push(r[i]);
                    return t
                }
            }]), t
        }(), Ll = function () {
            function t(e) {
                sl(this, t), this.events = e;
                for (var n = 0, r = e.length; n < r; n++) e[n].segment.ringOut = this;
                this.poly = null
            }

            return ul(t, null, [{
                key: "factory", value: function (e) {
                    for (var n = [], r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        if (o.isInResult() && !o.ringOut) {
                            for (var s = null, a = o.leftSE, u = o.rightSE, l = [a], h = a.point, c = []; s = a, a = u, l.push(a), a.point !== h;) for (; ;) {
                                var f = a.getAvailableLinkedEvents();
                                if (0 === f.length) {
                                    var g = l[0].point, p = l[l.length - 1].point;
                                    throw new Error("Unable to complete output ring starting at [".concat(g.x, ",") + " ".concat(g.y, "]. Last matching segment found ends at") + " [".concat(p.x, ", ").concat(p.y, "]."))
                                }
                                if (1 === f.length) {
                                    u = f[0].otherSE;
                                    break
                                }
                                for (var v = null, d = 0, y = c.length; d < y; d++) if (c[d].point === a.point) {
                                    v = d;
                                    break
                                }
                                if (null === v) {
                                    c.push({index: l.length, point: a.point});
                                    var m = a.getLeftmostComparator(s);
                                    u = f.sort(m)[0].otherSE;
                                    break
                                }
                                var _ = c.splice(v)[0], x = l.splice(_.index);
                                x.unshift(x[0].otherSE), n.push(new t(x.reverse()))
                            }
                            n.push(new t(l))
                        }
                    }
                    return n
                }
            }]), ul(t, [{
                key: "getGeom", value: function () {
                    for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) {
                        var i = this.events[n].point, o = this.events[n + 1].point;
                        0 !== _l(i, t, o) && (e.push(i), t = i)
                    }
                    if (1 === e.length) return null;
                    var s = e[0], a = e[1];
                    0 === _l(s, t, a) && e.shift(), e.push(e[0]);
                    for (var u = this.isExteriorRing() ? 1 : -1, l = this.isExteriorRing() ? 0 : e.length - 1, h = this.isExteriorRing() ? e.length : -1, c = [], f = l; f != h; f += u) c.push([e[f].x, e[f].y]);
                    return c
                }
            }, {
                key: "isExteriorRing", value: function () {
                    if (void 0 === this._isExteriorRing) {
                        var t = this.enclosingRing();
                        this._isExteriorRing = !t || !t.isExteriorRing()
                    }
                    return this._isExteriorRing
                }
            }, {
                key: "enclosingRing", value: function () {
                    return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing
                }
            }, {
                key: "_calcEnclosingRing", value: function () {
                    for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) {
                        var r = this.events[e];
                        bl.compare(t, r) > 0 && (t = r)
                    }
                    for (var i = t.segment.prevInResult(), o = i ? i.prevInResult() : null; ;) {
                        if (!i) return null;
                        if (!o) return i.ringOut;
                        if (o.ringOut !== i.ringOut) return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing();
                        i = o.prevInResult(), o = i ? i.prevInResult() : null
                    }
                }
            }]), t
        }(), Cl = function () {
            function t(e) {
                sl(this, t), this.exteriorRing = e, e.poly = this, this.interiorRings = []
            }

            return ul(t, [{
                key: "addInterior", value: function (t) {
                    this.interiorRings.push(t), t.poly = this
                }
            }, {
                key: "getGeom", value: function () {
                    var t = [this.exteriorRing.getGeom()];
                    if (null === t[0]) return null;
                    for (var e = 0, n = this.interiorRings.length; e < n; e++) {
                        var r = this.interiorRings[e].getGeom();
                        null !== r && t.push(r)
                    }
                    return t
                }
            }]), t
        }(), Rl = function () {
            function t(e) {
                sl(this, t), this.rings = e, this.polys = this._composePolys(e)
            }

            return ul(t, [{
                key: "getGeom", value: function () {
                    for (var t = [], e = 0, n = this.polys.length; e < n; e++) {
                        var r = this.polys[e].getGeom();
                        null !== r && t.push(r)
                    }
                    return t
                }
            }, {
                key: "_composePolys", value: function (t) {
                    for (var e = [], n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        if (!i.poly) if (i.isExteriorRing()) e.push(new Cl(i)); else {
                            var o = i.enclosingRing();
                            o.poly || e.push(new Cl(o)), o.poly.addInterior(i)
                        }
                    }
                    return e
                }
            }]), t
        }(), Tl = function () {
            function t(e) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Sl.compare;
                sl(this, t), this.queue = e, this.tree = new nl(n), this.segments = []
            }

            return ul(t, [{
                key: "process", value: function (t) {
                    var e = t.segment, n = [];
                    if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n;
                    var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e);
                    if (!r) throw new Error("Unable to find segment #".concat(e.id, " ") + "[".concat(e.leftSE.point.x, ", ").concat(e.leftSE.point.y, "] -> ") + "[".concat(e.rightSE.point.x, ", ").concat(e.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
                    for (var i = r, o = r, s = void 0, a = void 0; void 0 === s;) null === (i = this.tree.prev(i)) ? s = null : void 0 === i.key.consumedBy && (s = i.key);
                    for (; void 0 === a;) null === (o = this.tree.next(o)) ? a = null : void 0 === o.key.consumedBy && (a = o.key);
                    if (t.isLeft) {
                        var u = null;
                        if (s) {
                            var l = s.getIntersection(e);
                            if (null !== l && (e.isAnEndpoint(l) || (u = l), !s.isAnEndpoint(l))) for (var h = this._splitSafely(s, l), c = 0, f = h.length; c < f; c++) n.push(h[c])
                        }
                        var g = null;
                        if (a) {
                            var p = a.getIntersection(e);
                            if (null !== p && (e.isAnEndpoint(p) || (g = p), !a.isAnEndpoint(p))) for (var v = this._splitSafely(a, p), d = 0, y = v.length; d < y; d++) n.push(v[d])
                        }
                        if (null !== u || null !== g) {
                            var m = null;
                            if (null === u) m = g; else if (null === g) m = u; else {
                                m = bl.comparePoints(u, g) <= 0 ? u : g
                            }
                            this.queue.remove(e.rightSE), n.push(e.rightSE);
                            for (var _ = e.split(m), x = 0, E = _.length; x < E; x++) n.push(_[x])
                        }
                        n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = s)
                    } else {
                        if (s && a) {
                            var k = s.getIntersection(a);
                            if (null !== k) {
                                if (!s.isAnEndpoint(k)) for (var w = this._splitSafely(s, k), b = 0, I = w.length; b < I; b++) n.push(w[b]);
                                if (!a.isAnEndpoint(k)) for (var S = this._splitSafely(a, k), N = 0, M = S.length; N < M; N++) n.push(S[N])
                            }
                        }
                        this.tree.remove(e)
                    }
                    return n
                }
            }, {
                key: "_splitSafely", value: function (t, e) {
                    this.tree.remove(t);
                    var n = t.rightSE;
                    this.queue.remove(n);
                    var r = t.split(e);
                    return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r
                }
            }]), t
        }(), Ol = "undefined" != typeof process && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6,
        Al = "undefined" != typeof process && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6,
        Dl = new (function () {
            function t() {
                sl(this, t)
            }

            return ul(t, [{
                key: "run", value: function (t, e, n) {
                    Dl.type = t, dl.reset();
                    for (var r = [new Pl(e, !0)], i = 0, o = n.length; i < o; i++) r.push(new Pl(n[i], !1));
                    if (Dl.numMultiPolys = r.length, "difference" === Dl.type) for (var s = r[0], a = 1; a < r.length;) null !== hl(r[a].bbox, s.bbox) ? a++ : r.splice(a, 1);
                    if ("intersection" === Dl.type) for (var u = 0, l = r.length; u < l; u++) for (var h = r[u], c = u + 1, f = r.length; c < f; c++) if (null === hl(h.bbox, r[c].bbox)) return [];
                    for (var g = new nl(bl.compare), p = 0, v = r.length; p < v; p++) for (var d = r[p].getSweepEvents(), y = 0, m = d.length; y < m; y++) if (g.insert(d[y]), g.size > Ol) throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                    for (var _ = new Tl(g), x = g.size, E = g.pop(); E;) {
                        var k = E.key;
                        if (g.size === x) {
                            var w = k.segment;
                            throw new Error("Unable to pop() ".concat(k.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(k.point.x, ", ").concat(k.point.y, "] from segment #").concat(w.id, " ") + "[".concat(w.leftSE.point.x, ", ").concat(w.leftSE.point.y, "] -> ") + "[".concat(w.rightSE.point.x, ", ").concat(w.rightSE.point.y, "] from queue. ") + "Please file a bug report.")
                        }
                        if (g.size > Ol) throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                        if (_.segments.length > Al) throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                        for (var b = _.process(k), I = 0, S = b.length; I < S; I++) {
                            var N = b[I];
                            void 0 === N.consumedBy && g.insert(N)
                        }
                        x = g.size, E = g.pop()
                    }
                    dl.reset();
                    var M = Ll.factory(_.segments);
                    return new Rl(M).getGeom()
                }
            }]), t
        }()), Fl = {
            union: function (t) {
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                return Dl.run("union", t, n)
            }, intersection: function (t) {
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                return Dl.run("intersection", t, n)
            }, xor: function (t) {
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                return Dl.run("xor", t, n)
            }, difference: function (t) {
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                return Dl.run("difference", t, n)
            }
        };
    var ql = Wt((function (t, n) {
        t.exports = function () {
            function t(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function n(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                }
            }

            function r(t, e, r) {
                return e && n(t.prototype, e), r && n(t, r), t
            }

            function i(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && s(t, e)
            }

            function o(t) {
                return o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                }, o(t)
            }

            function s(t, e) {
                return s = Object.setPrototypeOf || function (t, e) {
                    return t.__proto__ = e, t
                }, s(t, e)
            }

            function a() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                    }))), !0
                } catch (t) {
                    return !1
                }
            }

            function u(t, e, n) {
                return u = a() ? Reflect.construct : function (t, e, n) {
                    var r = [null];
                    r.push.apply(r, e);
                    var i = new (Function.bind.apply(t, r));
                    return n && s(i, n.prototype), i
                }, u.apply(null, arguments)
            }

            function l(t) {
                var e = "function" == typeof Map ? new Map : void 0;
                return l = function (t) {
                    if (null === t || (n = t, -1 === Function.toString.call(n).indexOf("[native code]"))) return t;
                    var n;
                    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== e) {
                        if (e.has(t)) return e.get(t);
                        e.set(t, r)
                    }

                    function r() {
                        return u(t, arguments, o(this).constructor)
                    }

                    return r.prototype = Object.create(t.prototype, {
                        constructor: {
                            value: r,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), s(r, t)
                }, l(t)
            }

            function h(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function c(t, n) {
                if (n && ("object" == e(n) || "function" == typeof n)) return n;
                if (void 0 !== n) throw new TypeError("Derived constructors may only return object or undefined");
                return h(t)
            }

            function f(t) {
                var e = a();
                return function () {
                    var n, r = o(t);
                    if (e) {
                        var i = o(this).constructor;
                        n = Reflect.construct(r, arguments, i)
                    } else n = r.apply(this, arguments);
                    return c(this, n)
                }
            }

            function g(t, e, n) {
                return g = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
                    var r = function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = o(t));) ;
                        return t
                    }(t, e);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, e);
                        return i.get ? i.get.call(n) : i.value
                    }
                }, g(t, e, n || t)
            }

            function p(t) {
                return function (t) {
                    if (Array.isArray(t)) return d(t)
                }(t) || function (t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(t) || v(t) || function () {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function v(t, e) {
                if (t) {
                    if ("string" == typeof t) return d(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? d(t, e) : void 0
                }
            }

            function d(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                return r
            }

            function y(t, e) {
                var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!n) {
                    if (Array.isArray(t) || (n = v(t)) || e && t && "number" == typeof t.length) {
                        n && (t = n);
                        var r = 0, i = function () {
                        };
                        return {
                            s: i, n: function () {
                                return r >= t.length ? {done: !0} : {done: !1, value: t[r++]}
                            }, e: function (t) {
                                throw t
                            }, f: i
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var o, s = !0, a = !1;
                return {
                    s: function () {
                        n = n.call(t)
                    }, n: function () {
                        var t = n.next();
                        return s = t.done, t
                    }, e: function (t) {
                        a = !0, o = t
                    }, f: function () {
                        try {
                            s || null == n.return || n.return()
                        } finally {
                            if (a) throw o
                        }
                    }
                }
            }

            var m = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getEndCapStyle", value: function () {
                        return this._endCapStyle
                    }
                }, {
                    key: "isSingleSided", value: function () {
                        return this._isSingleSided
                    }
                }, {
                    key: "setQuadrantSegments", value: function (t) {
                        this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = e.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = e.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== e.JOIN_ROUND && (this._quadrantSegments = e.DEFAULT_QUADRANT_SEGMENTS)
                    }
                }, {
                    key: "getJoinStyle", value: function () {
                        return this._joinStyle
                    }
                }, {
                    key: "setJoinStyle", value: function (t) {
                        this._joinStyle = t
                    }
                }, {
                    key: "setSimplifyFactor", value: function (t) {
                        this._simplifyFactor = t < 0 ? 0 : t
                    }
                }, {
                    key: "getSimplifyFactor", value: function () {
                        return this._simplifyFactor
                    }
                }, {
                    key: "getQuadrantSegments", value: function () {
                        return this._quadrantSegments
                    }
                }, {
                    key: "setEndCapStyle", value: function (t) {
                        this._endCapStyle = t
                    }
                }, {
                    key: "getMitreLimit", value: function () {
                        return this._mitreLimit
                    }
                }, {
                    key: "setMitreLimit", value: function (t) {
                        this._mitreLimit = t
                    }
                }, {
                    key: "setSingleSided", value: function (t) {
                        this._isSingleSided = t
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._quadrantSegments = e.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = e.CAP_ROUND, this._joinStyle = e.JOIN_ROUND, this._mitreLimit = e.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = e.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ; else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setQuadrantSegments(t)
                        } else if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            this.setQuadrantSegments(n), this.setEndCapStyle(r)
                        } else if (4 === arguments.length) {
                            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3];
                            this.setQuadrantSegments(i), this.setEndCapStyle(o), this.setJoinStyle(s), this.setMitreLimit(a)
                        }
                    }
                }, {
                    key: "bufferDistanceError", value: function (t) {
                        var e = Math.PI / 2 / t;
                        return 1 - Math.cos(e / 2)
                    }
                }]), e
            }();
            m.CAP_ROUND = 1, m.CAP_FLAT = 2, m.CAP_SQUARE = 3, m.JOIN_ROUND = 1, m.JOIN_MITRE = 2, m.JOIN_BEVEL = 3, m.DEFAULT_QUADRANT_SEGMENTS = 8, m.DEFAULT_MITRE_LIMIT = 5, m.DEFAULT_SIMPLIFY_FACTOR = .01;
            var _ = function (e) {
                i(o, e);
                var n = f(o);

                function o(e) {
                    var r;
                    return t(this, o), (r = n.call(this, e)).name = Object.keys({Exception: o})[0], r
                }

                return r(o, [{
                    key: "toString", value: function () {
                        return this.message
                    }
                }]), o
            }(l(Error)), x = function (e) {
                i(r, e);
                var n = f(r);

                function r(e) {
                    var i;
                    return t(this, r), (i = n.call(this, e)).name = Object.keys({IllegalArgumentException: r})[0], i
                }

                return r
            }(_), E = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "filter", value: function (t) {
                    }
                }]), e
            }();

            function k() {
            }

            function w() {
            }

            function b() {
            }

            var I, S, N, M, P, L, C, R, T = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "equalsWithTolerance", value: function (t, e, n) {
                        return Math.abs(t - e) <= n
                    }
                }]), e
            }(), O = function () {
                function e(n, r) {
                    t(this, e), this.low = r || 0, this.high = n || 0
                }

                return r(e, null, [{
                    key: "toBinaryString", value: function (t) {
                        var e, n = "";
                        for (e = 2147483648; e > 0; e >>>= 1) n += (t.high & e) === e ? "1" : "0";
                        for (e = 2147483648; e > 0; e >>>= 1) n += (t.low & e) === e ? "1" : "0";
                        return n
                    }
                }]), e
            }();

            function A() {
            }

            function D() {
            }

            A.NaN = NaN, A.isNaN = function (t) {
                return Number.isNaN(t)
            }, A.isInfinite = function (t) {
                return !Number.isFinite(t)
            }, A.MAX_VALUE = Number.MAX_VALUE, A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, "function" == typeof Float64Array && "function" == typeof Int32Array ? (L = 2146435072, C = new Float64Array(1), R = new Int32Array(C.buffer), A.doubleToLongBits = function (t) {
                C[0] = t;
                var e = 0 | R[0], n = 0 | R[1];
                return (n & L) === L && 0 != (1048575 & n) && 0 !== e && (e = 0, n = 2146959360), new O(n, e)
            }, A.longBitsToDouble = function (t) {
                return R[0] = t.low, R[1] = t.high, C[0]
            }) : (I = 1023, S = Math.log2, N = Math.floor, M = Math.pow, P = function () {
                for (var t = 53; t > 0; t--) {
                    var e = M(2, t) - 1;
                    if (N(S(e)) + 1 === t) return e
                }
                return 0
            }(), A.doubleToLongBits = function (t) {
                var e, n, r, i, o, s, a, u, l;
                if (t < 0 || 1 / t === Number.NEGATIVE_INFINITY ? (s = 1 << 31, t = -t) : s = 0, 0 === t) return new O(u = s, l = 0);
                if (t === 1 / 0) return new O(u = 2146435072 | s, l = 0);
                if (t != t) return new O(u = 2146959360, l = 0);
                if (i = 0, l = 0, (e = N(t)) > 1) if (e <= P) (i = N(S(e))) <= 20 ? (l = 0, u = e << 20 - i & 1048575) : (l = e % (n = M(2, r = i - 20)) << 32 - r, u = e / n & 1048575); else for (r = e, l = 0; 0 !== (r = N(n = r / 2));) i++, l >>>= 1, l |= (1 & u) << 31, u >>>= 1, n !== r && (u |= 524288);
                if (a = i + I, o = 0 === e, e = t - e, i < 52 && 0 !== e) for (r = 0; ;) {
                    if ((n = 2 * e) >= 1 ? (e = n - 1, o ? (a--, o = !1) : (r <<= 1, r |= 1, i++)) : (e = n, o ? 0 == --a && (i++, o = !1) : (r <<= 1, i++)), 20 === i) u |= r, r = 0; else if (52 === i) {
                        l |= r;
                        break
                    }
                    if (1 === n) {
                        i < 20 ? u |= r << 20 - i : i < 52 && (l |= r << 52 - i);
                        break
                    }
                }
                return u |= a << 20, new O(u |= s, l)
            }, A.longBitsToDouble = function (t) {
                var e, n, r, i, o = t.high, s = t.low, a = o & 1 << 31 ? -1 : 1;
                for (r = ((2146435072 & o) >> 20) - I, i = 0, n = 1 << 19, e = 1; e <= 20; e++) o & n && (i += M(2, -e)), n >>>= 1;
                for (n = 1 << 31, e = 21; e <= 52; e++) s & n && (i += M(2, -e)), n >>>= 1;
                if (-1023 === r) {
                    if (0 === i) return 0 * a;
                    r = -1022
                } else {
                    if (1024 === r) return 0 === i ? a / 0 : NaN;
                    i += 1
                }
                return a * i * M(2, r)
            });
            var F = function (e) {
                i(r, e);
                var n = f(r);

                function r(e) {
                    var i;
                    return t(this, r), (i = n.call(this, e)).name = Object.keys({RuntimeException: r})[0], i
                }

                return r
            }(_), q = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, null, [{
                    key: "constructor_", value: function () {
                        if (0 === arguments.length) F.constructor_.call(this); else if (1 === arguments.length) {
                            var t = arguments[0];
                            F.constructor_.call(this, t)
                        }
                    }
                }]), o
            }(F), G = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "shouldNeverReachHere", value: function () {
                        if (0 === arguments.length) e.shouldNeverReachHere(null); else if (1 === arguments.length) {
                            var t = arguments[0];
                            throw new q("Should never reach here" + (null !== t ? ": " + t : ""))
                        }
                    }
                }, {
                    key: "isTrue", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            e.isTrue(t, null)
                        } else if (2 === arguments.length) {
                            var n = arguments[1];
                            if (!arguments[0]) throw null === n ? new q : new q(n)
                        }
                    }
                }, {
                    key: "equals", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], n = arguments[1];
                            e.equals(t, n, null)
                        } else if (3 === arguments.length) {
                            var r = arguments[0], i = arguments[1], o = arguments[2];
                            if (!i.equals(r)) throw new q("Expected " + r + " but encountered " + i + (null !== o ? ": " + o : ""))
                        }
                    }
                }]), e
            }(), Y = new ArrayBuffer(8), B = new Float64Array(Y), z = new Int32Array(Y), X = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getM", value: function () {
                        return A.NaN
                    }
                }, {
                    key: "setOrdinate", value: function (t, n) {
                        switch (t) {
                            case e.X:
                                this.x = n;
                                break;
                            case e.Y:
                                this.y = n;
                                break;
                            case e.Z:
                                this.setZ(n);
                                break;
                            default:
                                throw new x("Invalid ordinate index: " + t)
                        }
                    }
                }, {
                    key: "equals2D", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.x === t.x && this.y === t.y
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            return !!T.equalsWithTolerance(this.x, e.x, n) && !!T.equalsWithTolerance(this.y, e.y, n)
                        }
                    }
                }, {
                    key: "setM", value: function (t) {
                        throw new x("Invalid ordinate index: " + e.M)
                    }
                }, {
                    key: "getZ", value: function () {
                        return this.z
                    }
                }, {
                    key: "getOrdinate", value: function (t) {
                        switch (t) {
                            case e.X:
                                return this.x;
                            case e.Y:
                                return this.y;
                            case e.Z:
                                return this.getZ()
                        }
                        throw new x("Invalid ordinate index: " + t)
                    }
                }, {
                    key: "equals3D", value: function (t) {
                        return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || A.isNaN(this.getZ()) && A.isNaN(t.getZ()))
                    }
                }, {
                    key: "equals", value: function (t) {
                        return t instanceof e && this.equals2D(t)
                    }
                }, {
                    key: "equalInZ", value: function (t, e) {
                        return T.equalsWithTolerance(this.getZ(), t.getZ(), e)
                    }
                }, {
                    key: "setX", value: function (t) {
                        this.x = t
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
                    }
                }, {
                    key: "getX", value: function () {
                        return this.x
                    }
                }, {
                    key: "setZ", value: function (t) {
                        this.z = t
                    }
                }, {
                    key: "clone", value: function () {
                        try {
                            return null
                        } catch (t) {
                            if (t instanceof CloneNotSupportedException) return G.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
                            throw t
                        }
                    }
                }, {
                    key: "copy", value: function () {
                        return new e(this)
                    }
                }, {
                    key: "toString", value: function () {
                        return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")"
                    }
                }, {
                    key: "distance3D", value: function (t) {
                        var e = this.x - t.x, n = this.y - t.y, r = this.getZ() - t.getZ();
                        return Math.sqrt(e * e + n * n + r * r)
                    }
                }, {
                    key: "getY", value: function () {
                        return this.y
                    }
                }, {
                    key: "setY", value: function (t) {
                        this.y = t
                    }
                }, {
                    key: "distance", value: function (t) {
                        var e = this.x - t.x, n = this.y - t.y;
                        return Math.sqrt(e * e + n * n)
                    }
                }, {
                    key: "hashCode", value: function () {
                        var t = 17;
                        return 37 * (t = 37 * t + e.hashCode(this.x)) + e.hashCode(this.y)
                    }
                }, {
                    key: "setCoordinate", value: function (t) {
                        this.x = t.x, this.y = t.y, this.z = t.getZ()
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k, w, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) e.constructor_.call(this, 0, 0); else if (1 === arguments.length) {
                            var t = arguments[0];
                            e.constructor_.call(this, t.x, t.y, t.getZ())
                        } else if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            e.constructor_.call(this, n, r, e.NULL_ORDINATE)
                        } else if (3 === arguments.length) {
                            var i = arguments[0], o = arguments[1], s = arguments[2];
                            this.x = i, this.y = o, this.z = s
                        }
                    }
                }, {
                    key: "hashCode", value: function (t) {
                        return B[0] = t, z[0] ^ z[1]
                    }
                }]), e
            }(), j = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "compare", value: function (t, n) {
                        var r = e.compare(t.x, n.x);
                        if (0 !== r) return r;
                        var i = e.compare(t.y, n.y);
                        return 0 !== i ? i : this._dimensionsToTest <= 2 ? 0 : e.compare(t.getZ(), n.getZ())
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [D]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._dimensionsToTest = 2, 0 === arguments.length) e.constructor_.call(this, 2); else if (1 === arguments.length) {
                            var t = arguments[0];
                            if (2 !== t && 3 !== t) throw new x("only 2 or 3 dimensions may be specified");
                            this._dimensionsToTest = t
                        }
                    }
                }, {
                    key: "compare", value: function (t, e) {
                        return t < e ? -1 : t > e ? 1 : A.isNaN(t) ? A.isNaN(e) ? 0 : -1 : A.isNaN(e) ? 1 : 0
                    }
                }]), e
            }();
            X.DimensionalComparator = j, X.NULL_ORDINATE = A.NaN, X.X = 0, X.Y = 1, X.Z = 2, X.M = 3;
            var U = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getArea", value: function () {
                        return this.getWidth() * this.getHeight()
                    }
                }, {
                    key: "equals", value: function (t) {
                        if (!(t instanceof e)) return !1;
                        var n = t;
                        return this.isNull() ? n.isNull() : this._maxx === n.getMaxX() && this._maxy === n.getMaxY() && this._minx === n.getMinX() && this._miny === n.getMinY()
                    }
                }, {
                    key: "intersection", value: function (t) {
                        if (this.isNull() || t.isNull() || !this.intersects(t)) return new e;
                        var n = this._minx > t._minx ? this._minx : t._minx,
                            r = this._miny > t._miny ? this._miny : t._miny;
                        return new e(n, this._maxx < t._maxx ? this._maxx : t._maxx, r, this._maxy < t._maxy ? this._maxy : t._maxy)
                    }
                }, {
                    key: "isNull", value: function () {
                        return this._maxx < this._minx
                    }
                }, {
                    key: "getMaxX", value: function () {
                        return this._maxx
                    }
                }, {
                    key: "covers", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof X) {
                                var t = arguments[0];
                                return this.covers(t.x, t.y)
                            }
                            if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                return !this.isNull() && !n.isNull() && n.getMinX() >= this._minx && n.getMaxX() <= this._maxx && n.getMinY() >= this._miny && n.getMaxY() <= this._maxy
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            return !this.isNull() && r >= this._minx && r <= this._maxx && i >= this._miny && i <= this._maxy
                        }
                    }
                }, {
                    key: "intersects", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof e) {
                                var t = arguments[0];
                                return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny)
                            }
                            if (arguments[0] instanceof X) {
                                var n = arguments[0];
                                return this.intersects(n.x, n.y)
                            }
                        } else if (2 === arguments.length) {
                            if (arguments[0] instanceof X && arguments[1] instanceof X) {
                                var r = arguments[0], i = arguments[1];
                                return !(this.isNull() || (r.x < i.x ? r.x : i.x) > this._maxx || (r.x > i.x ? r.x : i.x) < this._minx || (r.y < i.y ? r.y : i.y) > this._maxy || (r.y > i.y ? r.y : i.y) < this._miny)
                            }
                            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                                var o = arguments[0], s = arguments[1];
                                return !this.isNull() && !(o > this._maxx || o < this._minx || s > this._maxy || s < this._miny)
                            }
                        }
                    }
                }, {
                    key: "getMinY", value: function () {
                        return this._miny
                    }
                }, {
                    key: "getDiameter", value: function () {
                        if (this.isNull()) return 0;
                        var t = this.getWidth(), e = this.getHeight();
                        return Math.sqrt(t * t + e * e)
                    }
                }, {
                    key: "getMinX", value: function () {
                        return this._minx
                    }
                }, {
                    key: "expandToInclude", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof X) {
                                var t = arguments[0];
                                this.expandToInclude(t.x, t.y)
                            } else if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                if (n.isNull()) return null;
                                this.isNull() ? (this._minx = n.getMinX(), this._maxx = n.getMaxX(), this._miny = n.getMinY(), this._maxy = n.getMaxY()) : (n._minx < this._minx && (this._minx = n._minx), n._maxx > this._maxx && (this._maxx = n._maxx), n._miny < this._miny && (this._miny = n._miny), n._maxy > this._maxy && (this._maxy = n._maxy))
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            this.isNull() ? (this._minx = r, this._maxx = r, this._miny = i, this._maxy = i) : (r < this._minx && (this._minx = r), r > this._maxx && (this._maxx = r), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i))
                        }
                    }
                }, {
                    key: "minExtent", value: function () {
                        if (this.isNull()) return 0;
                        var t = this.getWidth(), e = this.getHeight();
                        return t < e ? t : e
                    }
                }, {
                    key: "getWidth", value: function () {
                        return this.isNull() ? 0 : this._maxx - this._minx
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0
                    }
                }, {
                    key: "translate", value: function (t, e) {
                        if (this.isNull()) return null;
                        this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
                    }
                }, {
                    key: "copy", value: function () {
                        return new e(this)
                    }
                }, {
                    key: "toString", value: function () {
                        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]"
                    }
                }, {
                    key: "setToNull", value: function () {
                        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1
                    }
                }, {
                    key: "disjoint", value: function (t) {
                        return !(!this.isNull() && !t.isNull()) || t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny
                    }
                }, {
                    key: "getHeight", value: function () {
                        return this.isNull() ? 0 : this._maxy - this._miny
                    }
                }, {
                    key: "maxExtent", value: function () {
                        if (this.isNull()) return 0;
                        var t = this.getWidth(), e = this.getHeight();
                        return t > e ? t : e
                    }
                }, {
                    key: "expandBy", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.expandBy(t, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            if (this.isNull()) return null;
                            this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull()
                        }
                    }
                }, {
                    key: "contains", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof e) {
                                var t = arguments[0];
                                return this.covers(t)
                            }
                            if (arguments[0] instanceof X) {
                                var n = arguments[0];
                                return this.covers(n)
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            return this.covers(r, i)
                        }
                    }
                }, {
                    key: "centre", value: function () {
                        return this.isNull() ? null : new X((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
                    }
                }, {
                    key: "init", value: function () {
                        if (0 === arguments.length) this.setToNull(); else if (1 === arguments.length) {
                            if (arguments[0] instanceof X) {
                                var t = arguments[0];
                                this.init(t.x, t.x, t.y, t.y)
                            } else if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                this._minx = n._minx, this._maxx = n._maxx, this._miny = n._miny, this._maxy = n._maxy
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            this.init(r.x, i.x, r.y, i.y)
                        } else if (4 === arguments.length) {
                            var o = arguments[0], s = arguments[1], a = arguments[2], u = arguments[3];
                            o < s ? (this._minx = o, this._maxx = s) : (this._minx = s, this._maxx = o), a < u ? (this._miny = a, this._maxy = u) : (this._miny = u, this._maxy = a)
                        }
                    }
                }, {
                    key: "getMaxY", value: function () {
                        return this._maxy
                    }
                }, {
                    key: "distance", value: function (t) {
                        if (this.intersects(t)) return 0;
                        var e = 0;
                        this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
                        var n = 0;
                        return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
                    }
                }, {
                    key: "hashCode", value: function () {
                        var t = 17;
                        return 37 * (t = 37 * (t = 37 * (t = 37 * t + X.hashCode(this._minx)) + X.hashCode(this._maxx)) + X.hashCode(this._miny)) + X.hashCode(this._maxy)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init(); else if (1 === arguments.length) {
                            if (arguments[0] instanceof X) {
                                var t = arguments[0];
                                this.init(t.x, t.x, t.y, t.y)
                            } else if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                this.init(n)
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            this.init(r.x, i.x, r.y, i.y)
                        } else if (4 === arguments.length) {
                            var o = arguments[0], s = arguments[1], a = arguments[2], u = arguments[3];
                            this.init(o, s, a, u)
                        }
                    }
                }, {
                    key: "intersects", value: function () {
                        if (3 === arguments.length) {
                            var t = arguments[0], e = arguments[1], n = arguments[2];
                            return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y)
                        }
                        if (4 === arguments.length) {
                            var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3],
                                a = Math.min(o.x, s.x), u = Math.max(o.x, s.x), l = Math.min(r.x, i.x),
                                h = Math.max(r.x, i.x);
                            return !(l > u || h < a || (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), l = Math.min(r.y, i.y), h = Math.max(r.y, i.y), l > u || h < a))
                        }
                    }
                }]), e
            }(), V = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "isGeometryCollection", value: function () {
                        return this.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION
                    }
                }, {
                    key: "getFactory", value: function () {
                        return this._factory
                    }
                }, {
                    key: "getGeometryN", value: function (t) {
                        return this
                    }
                }, {
                    key: "getArea", value: function () {
                        return 0
                    }
                }, {
                    key: "isRectangle", value: function () {
                        return !1
                    }
                }, {
                    key: "equalsExact", value: function (t) {
                        return this === t || this.equalsExact(t, 0)
                    }
                }, {
                    key: "geometryChanged", value: function () {
                        this.apply(e.geometryChangedFilter)
                    }
                }, {
                    key: "geometryChangedAction", value: function () {
                        this._envelope = null
                    }
                }, {
                    key: "equalsNorm", value: function (t) {
                        return null !== t && this.norm().equalsExact(t.norm())
                    }
                }, {
                    key: "getLength", value: function () {
                        return 0
                    }
                }, {
                    key: "getNumGeometries", value: function () {
                        return 1
                    }
                }, {
                    key: "compareTo", value: function () {
                        var t;
                        if (1 === arguments.length) {
                            var e = arguments[0];
                            return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            return t = n, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(n, r)
                        }
                    }
                }, {
                    key: "getUserData", value: function () {
                        return this._userData
                    }
                }, {
                    key: "getSRID", value: function () {
                        return this._SRID
                    }
                }, {
                    key: "getEnvelope", value: function () {
                        return this.getFactory().toGeometry(this.getEnvelopeInternal())
                    }
                }, {
                    key: "checkNotGeometryCollection", value: function (t) {
                        if (t.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION) throw new x("This method does not support GeometryCollection arguments")
                    }
                }, {
                    key: "equal", value: function (t, e, n) {
                        return 0 === n ? t.equals(e) : t.distance(e) <= n
                    }
                }, {
                    key: "norm", value: function () {
                        var t = this.copy();
                        return t.normalize(), t
                    }
                }, {
                    key: "reverse", value: function () {
                        var t = this.reverseInternal();
                        return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t
                    }
                }, {
                    key: "copy", value: function () {
                        var t = this.copyInternal();
                        return t.envelope = null == this._envelope ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t
                    }
                }, {
                    key: "getPrecisionModel", value: function () {
                        return this._factory.getPrecisionModel()
                    }
                }, {
                    key: "getEnvelopeInternal", value: function () {
                        return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new U(this._envelope)
                    }
                }, {
                    key: "setSRID", value: function (t) {
                        this._SRID = t
                    }
                }, {
                    key: "setUserData", value: function (t) {
                        this._userData = t
                    }
                }, {
                    key: "compare", value: function (t, e) {
                        for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext();) {
                            var i = n.next(), o = r.next(), s = i.compareTo(o);
                            if (0 !== s) return s
                        }
                        return n.hasNext() ? 1 : r.hasNext() ? -1 : 0
                    }
                }, {
                    key: "hashCode", value: function () {
                        return this.getEnvelopeInternal().hashCode()
                    }
                }, {
                    key: "isEquivalentClass", value: function (t) {
                        return this.getClass() === t.getClass()
                    }
                }, {
                    key: "isGeometryCollectionOrDerived", value: function () {
                        return this.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === e.TYPECODE_MULTIPOINT || this.getTypeCode() === e.TYPECODE_MULTILINESTRING || this.getTypeCode() === e.TYPECODE_MULTIPOLYGON
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [w, k, b]
                    }
                }, {
                    key: "getClass", value: function () {
                        return e
                    }
                }], [{
                    key: "hasNonEmptyElements", value: function (t) {
                        for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
                        return !1
                    }
                }, {
                    key: "hasNullElements", value: function (t) {
                        for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;
                        return !1
                    }
                }]), e
            }();
            V.constructor_ = function (t) {
                t && (this._envelope = null, this._userData = null, this._factory = t, this._SRID = t.getSRID())
            }, V.TYPECODE_POINT = 0, V.TYPECODE_MULTIPOINT = 1, V.TYPECODE_LINESTRING = 2, V.TYPECODE_LINEARRING = 3, V.TYPECODE_MULTILINESTRING = 4, V.TYPECODE_POLYGON = 5, V.TYPECODE_MULTIPOLYGON = 6, V.TYPECODE_GEOMETRYCOLLECTION = 7, V.TYPENAME_POINT = "Point", V.TYPENAME_MULTIPOINT = "MultiPoint", V.TYPENAME_LINESTRING = "LineString", V.TYPENAME_LINEARRING = "LinearRing", V.TYPENAME_MULTILINESTRING = "MultiLineString", V.TYPENAME_POLYGON = "Polygon", V.TYPENAME_MULTIPOLYGON = "MultiPolygon", V.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", V.geometryChangedFilter = {
                get interfaces_() {
                    return [E]
                }, filter: function (t) {
                    t.geometryChangedAction()
                }
            };
            var Z = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "toLocationSymbol", value: function (t) {
                        switch (t) {
                            case e.EXTERIOR:
                                return "e";
                            case e.BOUNDARY:
                                return "b";
                            case e.INTERIOR:
                                return "i";
                            case e.NONE:
                                return "-"
                        }
                        throw new x("Unknown location value: " + t)
                    }
                }]), e
            }();
            Z.INTERIOR = 0, Z.BOUNDARY = 1, Z.EXTERIOR = 2, Z.NONE = -1;
            var H = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "add", value: function () {
                    }
                }, {
                    key: "addAll", value: function () {
                    }
                }, {
                    key: "isEmpty", value: function () {
                    }
                }, {
                    key: "iterator", value: function () {
                    }
                }, {
                    key: "size", value: function () {
                    }
                }, {
                    key: "toArray", value: function () {
                    }
                }, {
                    key: "remove", value: function () {
                    }
                }]), e
            }(), W = function (e) {
                i(r, e);
                var n = f(r);

                function r(e) {
                    var i;
                    return t(this, r), (i = n.call(this, e)).name = Object.keys({NoSuchElementException: r})[0], i
                }

                return r
            }(_), J = function (e) {
                i(r, e);
                var n = f(r);

                function r(e) {
                    var i;
                    return t(this, r), (i = n.call(this, e)).name = Object.keys({UnsupportedOperationException: r})[0], i
                }

                return r
            }(_), Q = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    return t(this, o), n.apply(this, arguments)
                }

                return r(o, [{
                    key: "contains", value: function () {
                    }
                }]), o
            }(H), K = function (e, n) {
                i(s, e);
                var o = f(s);

                function s(e) {
                    var n;
                    return t(this, s), (n = o.call(this)).map = new Map, e instanceof H && n.addAll(e), n
                }

                return r(s, [{
                    key: "contains", value: function (t) {
                        var e = t.hashCode ? t.hashCode() : t;
                        return !!this.map.has(e)
                    }
                }, {
                    key: "add", value: function (t) {
                        var e = t.hashCode ? t.hashCode() : t;
                        return !this.map.has(e) && !!this.map.set(e, t)
                    }
                }, {
                    key: "addAll", value: function (t) {
                        var e, n = y(t);
                        try {
                            for (n.s(); !(e = n.n()).done;) {
                                var r = e.value;
                                this.add(r)
                            }
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                        return !0
                    }
                }, {
                    key: "remove", value: function () {
                        throw new J
                    }
                }, {
                    key: "size", value: function () {
                        return this.map.size
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this.map.size
                    }
                }, {
                    key: "toArray", value: function () {
                        return Array.from(this.map.values())
                    }
                }, {
                    key: "iterator", value: function () {
                        return new $(this.map)
                    }
                }, {
                    key: n, value: function () {
                        return this.map
                    }
                }]), s
            }(Q, Symbol.iterator), $ = function () {
                function e(n) {
                    t(this, e), this.iterator = n.values();
                    var r = this.iterator.next(), i = r.done, o = r.value;
                    this.done = i, this.value = o
                }

                return r(e, [{
                    key: "next", value: function () {
                        if (this.done) throw new W;
                        var t = this.value, e = this.iterator.next(), n = e.done, r = e.value;
                        return this.done = n, this.value = r, t
                    }
                }, {
                    key: "hasNext", value: function () {
                        return !this.done
                    }
                }, {
                    key: "remove", value: function () {
                        throw new J
                    }
                }]), e
            }(), tt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "opposite", value: function (t) {
                        return t === e.LEFT ? e.RIGHT : t === e.RIGHT ? e.LEFT : t
                    }
                }]), e
            }();
            tt.ON = 0, tt.LEFT = 1, tt.RIGHT = 2;
            var et = function (e) {
                i(r, e);
                var n = f(r);

                function r(e) {
                    var i;
                    return t(this, r), (i = n.call(this, e)).name = Object.keys({EmptyStackException: r})[0], i
                }

                return r
            }(_), nt = function (e) {
                i(r, e);
                var n = f(r);

                function r(e) {
                    var i;
                    return t(this, r), (i = n.call(this, e)).name = Object.keys({IndexOutOfBoundsException: r})[0], i
                }

                return r
            }(_), rt = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    return t(this, o), n.apply(this, arguments)
                }

                return r(o, [{
                    key: "get", value: function () {
                    }
                }, {
                    key: "set", value: function () {
                    }
                }, {
                    key: "isEmpty", value: function () {
                    }
                }]), o
            }(H), it = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), (e = n.call(this)).array = [], e
                }

                return r(o, [{
                    key: "add", value: function (t) {
                        return this.array.push(t), !0
                    }
                }, {
                    key: "get", value: function (t) {
                        if (t < 0 || t >= this.size()) throw new nt;
                        return this.array[t]
                    }
                }, {
                    key: "push", value: function (t) {
                        return this.array.push(t), t
                    }
                }, {
                    key: "pop", value: function () {
                        if (0 === this.array.length) throw new et;
                        return this.array.pop()
                    }
                }, {
                    key: "peek", value: function () {
                        if (0 === this.array.length) throw new et;
                        return this.array[this.array.length - 1]
                    }
                }, {
                    key: "empty", value: function () {
                        return 0 === this.array.length
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return this.empty()
                    }
                }, {
                    key: "search", value: function (t) {
                        return this.array.indexOf(t)
                    }
                }, {
                    key: "size", value: function () {
                        return this.array.length
                    }
                }, {
                    key: "toArray", value: function () {
                        return this.array.slice()
                    }
                }]), o
            }(rt);

            function ot(t, e) {
                return t.interfaces_ && t.interfaces_.indexOf(e) > -1
            }

            var st = function () {
                function e(n) {
                    t(this, e), this.str = n
                }

                return r(e, [{
                    key: "append", value: function (t) {
                        this.str += t
                    }
                }, {
                    key: "setCharAt", value: function (t, e) {
                        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
                    }
                }, {
                    key: "toString", value: function () {
                        return this.str
                    }
                }]), e
            }(), at = function () {
                function e(n) {
                    t(this, e), this.value = n
                }

                return r(e, [{
                    key: "intValue", value: function () {
                        return this.value
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        return this.value < t ? -1 : this.value > t ? 1 : 0
                    }
                }], [{
                    key: "compare", value: function (t, e) {
                        return t < e ? -1 : t > e ? 1 : 0
                    }
                }, {
                    key: "isNan", value: function (t) {
                        return Number.isNaN(t)
                    }
                }, {
                    key: "valueOf", value: function (t) {
                        return new e(t)
                    }
                }]), e
            }(), ut = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "isWhitespace", value: function (t) {
                        return t <= 32 && t >= 0 || 127 === t
                    }
                }, {
                    key: "toUpperCase", value: function (t) {
                        return t.toUpperCase()
                    }
                }]), e
            }(), lt = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "le", value: function (t) {
                        return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo
                    }
                }, {
                    key: "extractSignificantDigits", value: function (t, n) {
                        var r = this.abs(), i = e.magnitude(r._hi), o = e.TEN.pow(i);
                        (r = r.divide(o)).gt(e.TEN) ? (r = r.divide(e.TEN), i += 1) : r.lt(e.ONE) && (r = r.multiply(e.TEN), i -= 1);
                        for (var s = i + 1, a = new st, u = e.MAX_PRINT_DIGITS - 1, l = 0; l <= u; l++) {
                            t && l === s && a.append(".");
                            var h = Math.trunc(r._hi);
                            if (h < 0) break;
                            var c = !1, f = 0;
                            h > 9 ? (c = !0, f = "9") : f = "0" + h, a.append(f), r = r.subtract(e.valueOf(h)).multiply(e.TEN), c && r.selfAdd(e.TEN);
                            var g = !0, p = e.magnitude(r._hi);
                            if (p < 0 && Math.abs(p) >= u - l && (g = !1), !g) break
                        }
                        return n[0] = i, a.toString()
                    }
                }, {
                    key: "sqr", value: function () {
                        return this.multiply(this)
                    }
                }, {
                    key: "doubleValue", value: function () {
                        return this._hi + this._lo
                    }
                }, {
                    key: "subtract", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0];
                            return this.add(t.negate())
                        }
                        if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            return this.add(-n)
                        }
                    }
                }, {
                    key: "equals", value: function () {
                        if (1 === arguments.length && arguments[0] instanceof e) {
                            var t = arguments[0];
                            return this._hi === t._hi && this._lo === t._lo
                        }
                    }
                }, {
                    key: "isZero", value: function () {
                        return 0 === this._hi && 0 === this._lo
                    }
                }, {
                    key: "selfSubtract", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0];
                            return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo)
                        }
                        if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            return this.isNaN() ? this : this.selfAdd(-n, 0)
                        }
                    }
                }, {
                    key: "getSpecialNumberString", value: function () {
                        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
                    }
                }, {
                    key: "min", value: function (t) {
                        return this.le(t) ? this : t
                    }
                }, {
                    key: "selfDivide", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof e) {
                                var t = arguments[0];
                                return this.selfDivide(t._hi, t._lo)
                            }
                            if ("number" == typeof arguments[0]) {
                                var n = arguments[0];
                                return this.selfDivide(n, 0)
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1], o = null, s = null, a = null, u = null, l = null,
                                h = null, c = null, f = null;
                            return l = this._hi / r, f = (o = (h = e.SPLIT * l) - (o = h - l)) * (a = (f = e.SPLIT * r) - (a = f - r)) - (c = l * r) + o * (u = r - a) + (s = l - o) * a + s * u, f = l + (h = (this._hi - c - f + this._lo - l * i) / r), this._hi = f, this._lo = l - f + h, this
                        }
                    }
                }, {
                    key: "dump", value: function () {
                        return "DD<" + this._hi + ", " + this._lo + ">"
                    }
                }, {
                    key: "divide", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0], n = null, r = null, i = null, o = null, s = null, a = null, u = null,
                                l = null;
                            return r = (s = this._hi / t._hi) - (n = (a = e.SPLIT * s) - (n = a - s)), l = n * (i = (l = e.SPLIT * t._hi) - (i = l - t._hi)) - (u = s * t._hi) + n * (o = t._hi - i) + r * i + r * o, new e(l = s + (a = (this._hi - u - l + this._lo - s * t._lo) / t._hi), s - l + a)
                        }
                        if ("number" == typeof arguments[0]) {
                            var h = arguments[0];
                            return A.isNaN(h) ? e.createNaN() : e.copy(this).selfDivide(h, 0)
                        }
                    }
                }, {
                    key: "ge", value: function (t) {
                        return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo
                    }
                }, {
                    key: "pow", value: function (t) {
                        if (0 === t) return e.valueOf(1);
                        var n = new e(this), r = e.valueOf(1), i = Math.abs(t);
                        if (i > 1) for (; i > 0;) i % 2 == 1 && r.selfMultiply(n), (i /= 2) > 0 && (n = n.sqr()); else r = n;
                        return t < 0 ? r.reciprocal() : r
                    }
                }, {
                    key: "ceil", value: function () {
                        if (this.isNaN()) return e.NaN;
                        var t = Math.ceil(this._hi), n = 0;
                        return t === this._hi && (n = Math.ceil(this._lo)), new e(t, n)
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0
                    }
                }, {
                    key: "rint", value: function () {
                        return this.isNaN() ? this : this.add(.5).floor()
                    }
                }, {
                    key: "setValue", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0];
                            return this.init(t), this
                        }
                        if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            return this.init(n), this
                        }
                    }
                }, {
                    key: "max", value: function (t) {
                        return this.ge(t) ? this : t
                    }
                }, {
                    key: "sqrt", value: function () {
                        if (this.isZero()) return e.valueOf(0);
                        if (this.isNegative()) return e.NaN;
                        var t = 1 / Math.sqrt(this._hi), n = this._hi * t, r = e.valueOf(n),
                            i = this.subtract(r.sqr())._hi * (.5 * t);
                        return r.add(i)
                    }
                }, {
                    key: "selfAdd", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof e) {
                                var t = arguments[0];
                                return this.selfAdd(t._hi, t._lo)
                            }
                            if ("number" == typeof arguments[0]) {
                                var n = arguments[0], r = null, i = null, o = null, s = null, a = null, u = null;
                                return s = (o = this._hi + n) - (a = o - this._hi), i = (u = (s = n - a + (this._hi - s)) + this._lo) + (o - (r = o + u)), this._hi = r + i, this._lo = i + (r - this._hi), this
                            }
                        } else if (2 === arguments.length) {
                            var l = arguments[0], h = arguments[1], c = null, f = null, g = null, p = null, v = null,
                                d = null, y = null;
                            p = this._hi + l, f = this._lo + h, v = p - (d = p - this._hi), g = f - (y = f - this._lo);
                            var m = (c = p + (d = (v = l - d + (this._hi - v)) + f)) + (d = (g = h - y + (this._lo - g)) + (d + (p - c))),
                                _ = d + (c - m);
                            return this._hi = m, this._lo = _, this
                        }
                    }
                }, {
                    key: "selfMultiply", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof e) {
                                var t = arguments[0];
                                return this.selfMultiply(t._hi, t._lo)
                            }
                            if ("number" == typeof arguments[0]) {
                                var n = arguments[0];
                                return this.selfMultiply(n, 0)
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1], o = null, s = null, a = null, u = null, l = null,
                                h = null;
                            o = (l = e.SPLIT * this._hi) - this._hi, h = e.SPLIT * r, o = l - o, s = this._hi - o, a = h - r;
                            var c = (l = this._hi * r) + (h = o * (a = h - a) - l + o * (u = r - a) + s * a + s * u + (this._hi * i + this._lo * r)),
                                f = h + (o = l - c);
                            return this._hi = c, this._lo = f, this
                        }
                    }
                }, {
                    key: "selfSqr", value: function () {
                        return this.selfMultiply(this)
                    }
                }, {
                    key: "floor", value: function () {
                        if (this.isNaN()) return e.NaN;
                        var t = Math.floor(this._hi), n = 0;
                        return t === this._hi && (n = Math.floor(this._lo)), new e(t, n)
                    }
                }, {
                    key: "negate", value: function () {
                        return this.isNaN() ? this : new e(-this._hi, -this._lo)
                    }
                }, {
                    key: "clone", value: function () {
                        try {
                            return null
                        } catch (t) {
                            if (t instanceof CloneNotSupportedException) return null;
                            throw t
                        }
                    }
                }, {
                    key: "multiply", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0];
                            return t.isNaN() ? e.createNaN() : e.copy(this).selfMultiply(t)
                        }
                        if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            return A.isNaN(n) ? e.createNaN() : e.copy(this).selfMultiply(n, 0)
                        }
                    }
                }, {
                    key: "isNaN", value: function () {
                        return A.isNaN(this._hi)
                    }
                }, {
                    key: "intValue", value: function () {
                        return Math.trunc(this._hi)
                    }
                }, {
                    key: "toString", value: function () {
                        var t = e.magnitude(this._hi);
                        return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
                    }
                }, {
                    key: "toStandardNotation", value: function () {
                        var t = this.getSpecialNumberString();
                        if (null !== t) return t;
                        var n = new Array(1).fill(null), r = this.extractSignificantDigits(!0, n), i = n[0] + 1, o = r;
                        if ("." === r.charAt(0)) o = "0" + r; else if (i < 0) o = "0." + e.stringOfChar("0", -i) + r; else if (-1 === r.indexOf(".")) {
                            var s = i - r.length;
                            o = r + e.stringOfChar("0", s) + ".0"
                        }
                        return this.isNegative() ? "-" + o : o
                    }
                }, {
                    key: "reciprocal", value: function () {
                        var t, n, r, i, o = null, s = null, a = null, u = null;
                        t = (r = 1 / this._hi) - (o = (a = e.SPLIT * r) - (o = a - r)), s = (u = e.SPLIT * this._hi) - this._hi;
                        var l = r + (a = (1 - (i = r * this._hi) - (u = o * (s = u - s) - i + o * (n = this._hi - s) + t * s + t * n) - r * this._lo) / this._hi);
                        return new e(l, r - l + a)
                    }
                }, {
                    key: "toSciNotation", value: function () {
                        if (this.isZero()) return e.SCI_NOT_ZERO;
                        var t = this.getSpecialNumberString();
                        if (null !== t) return t;
                        var n = new Array(1).fill(null), r = this.extractSignificantDigits(!1, n),
                            i = e.SCI_NOT_EXPONENT_CHAR + n[0];
                        if ("0" === r.charAt(0)) throw new IllegalStateException("Found leading zero: " + r);
                        var o = "";
                        r.length > 1 && (o = r.substring(1));
                        var s = r.charAt(0) + "." + o;
                        return this.isNegative() ? "-" + s + i : s + i
                    }
                }, {
                    key: "abs", value: function () {
                        return this.isNaN() ? e.NaN : this.isNegative() ? this.negate() : new e(this)
                    }
                }, {
                    key: "isPositive", value: function () {
                        return this._hi > 0 || 0 === this._hi && this._lo > 0
                    }
                }, {
                    key: "lt", value: function (t) {
                        return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo
                    }
                }, {
                    key: "add", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0];
                            return e.copy(this).selfAdd(t)
                        }
                        if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            return e.copy(this).selfAdd(n)
                        }
                    }
                }, {
                    key: "init", value: function () {
                        if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) {
                                var t = arguments[0];
                                this._hi = t, this._lo = 0
                            } else if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                this._hi = n._hi, this._lo = n._lo
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            this._hi = r, this._lo = i
                        }
                    }
                }, {
                    key: "gt", value: function (t) {
                        return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo
                    }
                }, {
                    key: "isNegative", value: function () {
                        return this._hi < 0 || 0 === this._hi && this._lo < 0
                    }
                }, {
                    key: "trunc", value: function () {
                        return this.isNaN() ? e.NaN : this.isPositive() ? this.floor() : this.ceil()
                    }
                }, {
                    key: "signum", value: function () {
                        return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [b, k, w]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0); else if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) {
                                var t = arguments[0];
                                this.init(t)
                            } else if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                this.init(n)
                            } else if ("string" == typeof arguments[0]) {
                                var r = arguments[0];
                                e.constructor_.call(this, e.parse(r))
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0], o = arguments[1];
                            this.init(i, o)
                        }
                    }
                }, {
                    key: "determinant", value: function () {
                        if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var t = arguments[0], n = arguments[1], r = arguments[2], i = arguments[3];
                            return e.determinant(e.valueOf(t), e.valueOf(n), e.valueOf(r), e.valueOf(i))
                        }
                        if (arguments[3] instanceof e && arguments[2] instanceof e && arguments[0] instanceof e && arguments[1] instanceof e) {
                            var o = arguments[1], s = arguments[2], a = arguments[3];
                            return arguments[0].multiply(a).selfSubtract(o.multiply(s))
                        }
                    }
                }, {
                    key: "sqr", value: function (t) {
                        return e.valueOf(t).selfMultiply(t)
                    }
                }, {
                    key: "valueOf", value: function () {
                        if ("string" == typeof arguments[0]) {
                            var t = arguments[0];
                            return e.parse(t)
                        }
                        if ("number" == typeof arguments[0]) return new e(arguments[0])
                    }
                }, {
                    key: "sqrt", value: function (t) {
                        return e.valueOf(t).sqrt()
                    }
                }, {
                    key: "parse", value: function (t) {
                        for (var n = 0, r = t.length; ut.isWhitespace(t.charAt(n));) n++;
                        var i = !1;
                        if (n < r) {
                            var o = t.charAt(n);
                            "-" !== o && "+" !== o || (n++, "-" === o && (i = !0))
                        }
                        for (var s = new e, a = 0, u = 0, l = 0, h = !1; !(n >= r);) {
                            var c = t.charAt(n);
                            if (n++, ut.isDigit(c)) {
                                var f = c - "0";
                                s.selfMultiply(e.TEN), s.selfAdd(f), a++
                            } else {
                                if ("." !== c) {
                                    if ("e" === c || "E" === c) {
                                        var g = t.substring(n);
                                        try {
                                            l = at.parseInt(g)
                                        } catch (e) {
                                            throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + g + " in string " + t) : e
                                        }
                                        break
                                    }
                                    throw new NumberFormatException("Unexpected character '" + c + "' at position " + n + " in string " + t)
                                }
                                u = a, h = !0
                            }
                        }
                        var p = s;
                        h || (u = a);
                        var v = a - u - l;
                        if (0 === v) p = s; else if (v > 0) {
                            var d = e.TEN.pow(v);
                            p = s.divide(d)
                        } else if (v < 0) {
                            var y = e.TEN.pow(-v);
                            p = s.multiply(y)
                        }
                        return i ? p.negate() : p
                    }
                }, {
                    key: "createNaN", value: function () {
                        return new e(A.NaN, A.NaN)
                    }
                }, {
                    key: "copy", value: function (t) {
                        return new e(t)
                    }
                }, {
                    key: "magnitude", value: function (t) {
                        var e = Math.abs(t), n = Math.log(e) / Math.log(10), r = Math.trunc(Math.floor(n));
                        return 10 * Math.pow(10, r) <= e && (r += 1), r
                    }
                }, {
                    key: "stringOfChar", value: function (t, e) {
                        for (var n = new st, r = 0; r < e; r++) n.append(t);
                        return n.toString()
                    }
                }]), e
            }();
            lt.PI = new lt(3.141592653589793, 12246467991473532e-32), lt.TWO_PI = new lt(6.283185307179586, 24492935982947064e-32), lt.PI_2 = new lt(1.5707963267948966, 6123233995736766e-32), lt.E = new lt(2.718281828459045, 14456468917292502e-32), lt.NaN = new lt(A.NaN, A.NaN), lt.EPS = 123259516440783e-46, lt.SPLIT = 134217729, lt.MAX_PRINT_DIGITS = 32, lt.TEN = lt.valueOf(10), lt.ONE = lt.valueOf(1), lt.SCI_NOT_EXPONENT_CHAR = "E", lt.SCI_NOT_ZERO = "0.0E0";
            var ht = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "orientationIndex", value: function (t, n, r) {
                        var i = e.orientationIndexFilter(t, n, r);
                        if (i <= 1) return i;
                        var o = lt.valueOf(n.x).selfAdd(-t.x), s = lt.valueOf(n.y).selfAdd(-t.y),
                            a = lt.valueOf(r.x).selfAdd(-n.x), u = lt.valueOf(r.y).selfAdd(-n.y);
                        return o.selfMultiply(u).selfSubtract(s.selfMultiply(a)).signum()
                    }
                }, {
                    key: "signOfDet2x2", value: function () {
                        if (arguments[3] instanceof lt && arguments[2] instanceof lt && arguments[0] instanceof lt && arguments[1] instanceof lt) {
                            var t = arguments[1], e = arguments[2], n = arguments[3];
                            return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()
                        }
                        if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3],
                                a = lt.valueOf(r), u = lt.valueOf(i), l = lt.valueOf(o), h = lt.valueOf(s);
                            return a.multiply(h).selfSubtract(u.multiply(l)).signum()
                        }
                    }
                }, {
                    key: "intersection", value: function (t, e, n, r) {
                        var i = new lt(t.y).selfSubtract(e.y), o = new lt(e.x).selfSubtract(t.x),
                            s = new lt(t.x).selfMultiply(e.y).selfSubtract(new lt(e.x).selfMultiply(t.y)),
                            a = new lt(n.y).selfSubtract(r.y), u = new lt(r.x).selfSubtract(n.x),
                            l = new lt(n.x).selfMultiply(r.y).selfSubtract(new lt(r.x).selfMultiply(n.y)),
                            h = o.multiply(l).selfSubtract(u.multiply(s)),
                            c = a.multiply(s).selfSubtract(i.multiply(l)),
                            f = i.multiply(u).selfSubtract(a.multiply(o)), g = h.selfDivide(f).doubleValue(),
                            p = c.selfDivide(f).doubleValue();
                        return A.isNaN(g) || A.isInfinite(g) || A.isNaN(p) || A.isInfinite(p) ? null : new X(g, p)
                    }
                }, {
                    key: "orientationIndexFilter", value: function (t, n, r) {
                        var i = null, o = (t.x - r.x) * (n.y - r.y), s = (t.y - r.y) * (n.x - r.x), a = o - s;
                        if (o > 0) {
                            if (s <= 0) return e.signum(a);
                            i = o + s
                        } else {
                            if (!(o < 0)) return e.signum(a);
                            if (s >= 0) return e.signum(a);
                            i = -o - s
                        }
                        var u = e.DP_SAFE_EPSILON * i;
                        return a >= u || -a >= u ? e.signum(a) : 2
                    }
                }, {
                    key: "signum", value: function (t) {
                        return t > 0 ? 1 : t < 0 ? -1 : 0
                    }
                }]), e
            }();
            ht.DP_SAFE_EPSILON = 1e-15;
            var ct = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "getM", value: function (t) {
                        if (this.hasM()) {
                            var e = this.getDimension() - this.getMeasures();
                            return this.getOrdinate(t, e)
                        }
                        return A.NaN
                    }
                }, {
                    key: "setOrdinate", value: function (t, e, n) {
                    }
                }, {
                    key: "getZ", value: function (t) {
                        return this.hasZ() ? this.getOrdinate(t, 2) : A.NaN
                    }
                }, {
                    key: "size", value: function () {
                    }
                }, {
                    key: "getOrdinate", value: function (t, e) {
                    }
                }, {
                    key: "getCoordinate", value: function () {
                    }
                }, {
                    key: "getCoordinateCopy", value: function (t) {
                    }
                }, {
                    key: "createCoordinate", value: function () {
                    }
                }, {
                    key: "getDimension", value: function () {
                    }
                }, {
                    key: "hasM", value: function () {
                        return this.getMeasures() > 0
                    }
                }, {
                    key: "getX", value: function (t) {
                    }
                }, {
                    key: "hasZ", value: function () {
                        return this.getDimension() - this.getMeasures() > 2
                    }
                }, {
                    key: "getMeasures", value: function () {
                        return 0
                    }
                }, {
                    key: "expandEnvelope", value: function (t) {
                    }
                }, {
                    key: "copy", value: function () {
                    }
                }, {
                    key: "getY", value: function (t) {
                    }
                }, {
                    key: "toCoordinateArray", value: function () {
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [w]
                    }
                }]), e
            }();
            ct.X = 0, ct.Y = 1, ct.Z = 2, ct.M = 3;
            var ft = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "index", value: function (t, e, n) {
                        return ht.orientationIndex(t, e, n)
                    }
                }, {
                    key: "isCCW", value: function () {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0], n = t.length - 1;
                            if (n < 3) throw new x("Ring has fewer than 4 points, so orientation cannot be determined");
                            for (var r = t[0], i = 0, o = 1; o <= n; o++) {
                                var s = t[o];
                                s.y > r.y && (r = s, i = o)
                            }
                            var a = i;
                            do {
                                (a -= 1) < 0 && (a = n)
                            } while (t[a].equals2D(r) && a !== i);
                            var u = i;
                            do {
                                u = (u + 1) % n
                            } while (t[u].equals2D(r) && u !== i);
                            var l = t[a], h = t[u];
                            if (l.equals2D(r) || h.equals2D(r) || l.equals2D(h)) return !1;
                            var c = e.index(l, r, h);
                            return 0 === c ? l.x > h.x : c > 0
                        }
                        if (ot(arguments[0], ct)) {
                            var f = arguments[0], g = f.size() - 1;
                            if (g < 3) throw new x("Ring has fewer than 4 points, so orientation cannot be determined");
                            for (var p = f.getCoordinate(0), v = 0, d = 1; d <= g; d++) {
                                var y = f.getCoordinate(d);
                                y.y > p.y && (p = y, v = d)
                            }
                            var m = null, _ = v;
                            do {
                                (_ -= 1) < 0 && (_ = g), m = f.getCoordinate(_)
                            } while (m.equals2D(p) && _ !== v);
                            var E = null, k = v;
                            do {
                                k = (k + 1) % g, E = f.getCoordinate(k)
                            } while (E.equals2D(p) && k !== v);
                            if (m.equals2D(p) || E.equals2D(p) || m.equals2D(E)) return !1;
                            var w = e.index(m, p, E);
                            return 0 === w ? m.x > E.x : w > 0
                        }
                    }
                }]), e
            }();
            ft.CLOCKWISE = -1, ft.RIGHT = ft.CLOCKWISE, ft.COUNTERCLOCKWISE = 1, ft.LEFT = ft.COUNTERCLOCKWISE, ft.COLLINEAR = 0, ft.STRAIGHT = ft.COLLINEAR;
            var gt = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getCoordinate", value: function () {
                        return this._minCoord
                    }
                }, {
                    key: "getRightmostSide", value: function (t, e) {
                        var n = this.getRightmostSideOfSegment(t, e);
                        return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n
                    }
                }, {
                    key: "findRightmostEdgeAtVertex", value: function () {
                        var t = this._minDe.getEdge().getCoordinates();
                        G.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
                        var e = t[this._minIndex - 1], n = t[this._minIndex + 1], r = ft.index(this._minCoord, n, e),
                            i = !1;
                        (e.y < this._minCoord.y && n.y < this._minCoord.y && r === ft.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && r === ft.CLOCKWISE) && (i = !0), i && (this._minIndex = this._minIndex - 1)
                    }
                }, {
                    key: "getRightmostSideOfSegment", value: function (t, e) {
                        var n = t.getEdge().getCoordinates();
                        if (e < 0 || e + 1 >= n.length) return -1;
                        if (n[e].y === n[e + 1].y) return -1;
                        var r = tt.LEFT;
                        return n[e].y < n[e + 1].y && (r = tt.RIGHT), r
                    }
                }, {
                    key: "getEdge", value: function () {
                        return this._orientedDe
                    }
                }, {
                    key: "checkForRightmostCoordinate", value: function (t) {
                        for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n])
                    }
                }, {
                    key: "findRightmostEdgeAtNode", value: function () {
                        var t = this._minDe.getNode().getEdges();
                        this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1)
                    }
                }, {
                    key: "findEdge", value: function (t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var n = e.next();
                            n.isForward() && this.checkForRightmostCoordinate(n)
                        }
                        G.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === tt.LEFT && (this._orientedDe = this._minDe.getSym())
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null
                    }
                }]), e
            }(), pt = function (e) {
                i(o, e);
                var n = f(o);

                function o(e, r) {
                    var i;
                    return t(this, o), (i = n.call(this, r ? e + " [ " + r + " ]" : e)).pt = r ? new X(r) : void 0, i.name = Object.keys({TopologyException: o})[0], i
                }

                return r(o, [{
                    key: "getCoordinate", value: function () {
                        return this.pt
                    }
                }]), o
            }(F), vt = function () {
                function e() {
                    t(this, e), this.array = []
                }

                return r(e, [{
                    key: "addLast", value: function (t) {
                        this.array.push(t)
                    }
                }, {
                    key: "removeFirst", value: function () {
                        return this.array.shift()
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this.array.length
                    }
                }]), e
            }(), dt = function (e, n) {
                i(s, e);
                var o = f(s);

                function s(e) {
                    var n;
                    return t(this, s), (n = o.call(this)).array = [], e instanceof H && n.addAll(e), n
                }

                return r(s, [{
                    key: "interfaces_", get: function () {
                        return [rt, H]
                    }
                }, {
                    key: "ensureCapacity", value: function () {
                    }
                }, {
                    key: "add", value: function (t) {
                        return 1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0
                    }
                }, {
                    key: "clear", value: function () {
                        this.array = []
                    }
                }, {
                    key: "addAll", value: function (t) {
                        var e, n = y(t);
                        try {
                            for (n.s(); !(e = n.n()).done;) {
                                var r = e.value;
                                this.array.push(r)
                            }
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                    }
                }, {
                    key: "set", value: function (t, e) {
                        var n = this.array[t];
                        return this.array[t] = e, n
                    }
                }, {
                    key: "iterator", value: function () {
                        return new yt(this)
                    }
                }, {
                    key: "get", value: function (t) {
                        if (t < 0 || t >= this.size()) throw new nt;
                        return this.array[t]
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this.array.length
                    }
                }, {
                    key: "sort", value: function (t) {
                        t ? this.array.sort((function (e, n) {
                            return t.compare(e, n)
                        })) : this.array.sort()
                    }
                }, {
                    key: "size", value: function () {
                        return this.array.length
                    }
                }, {
                    key: "toArray", value: function () {
                        return this.array.slice()
                    }
                }, {
                    key: "remove", value: function (t) {
                        for (var e = 0, n = this.array.length; e < n; e++) if (this.array[e] === t) return !!this.array.splice(e, 1);
                        return !1
                    }
                }, {
                    key: n, value: function () {
                        return this.array.values()
                    }
                }]), s
            }(rt, Symbol.iterator), yt = function () {
                function e(n) {
                    t(this, e), this.arrayList = n, this.position = 0
                }

                return r(e, [{
                    key: "next", value: function () {
                        if (this.position === this.arrayList.size()) throw new W;
                        return this.arrayList.get(this.position++)
                    }
                }, {
                    key: "hasNext", value: function () {
                        return this.position < this.arrayList.size()
                    }
                }, {
                    key: "set", value: function (t) {
                        return this.arrayList.set(this.position - 1, t)
                    }
                }, {
                    key: "remove", value: function () {
                        this.arrayList.remove(this.arrayList.get(this.position))
                    }
                }]), e
            }(), mt = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "clearVisitedEdges", value: function () {
                        for (var t = this._dirEdgeList.iterator(); t.hasNext();) t.next().setVisited(!1)
                    }
                }, {
                    key: "getRightmostCoordinate", value: function () {
                        return this._rightMostCoord
                    }
                }, {
                    key: "computeNodeDepth", value: function (t) {
                        for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
                            var r = n.next();
                            if (r.isVisited() || r.getSym().isVisited()) {
                                e = r;
                                break
                            }
                        }
                        if (null === e) throw new pt("unable to find edge to compute depths at " + t.getCoordinate());
                        t.getEdges().computeDepths(e);
                        for (var i = t.getEdges().iterator(); i.hasNext();) {
                            var o = i.next();
                            o.setVisited(!0), this.copySymDepths(o)
                        }
                    }
                }, {
                    key: "computeDepth", value: function (t) {
                        this.clearVisitedEdges();
                        var e = this._finder.getEdge();
                        e.getNode(), e.getLabel(), e.setEdgeDepths(tt.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
                    }
                }, {
                    key: "create", value: function (t) {
                        this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate()
                    }
                }, {
                    key: "findResultEdges", value: function () {
                        for (var t = this._dirEdgeList.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getDepth(tt.RIGHT) >= 1 && e.getDepth(tt.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
                        }
                    }
                }, {
                    key: "computeDepths", value: function (t) {
                        var e = new K, n = new vt, r = t.getNode();
                        for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty();) {
                            var i = n.removeFirst();
                            e.add(i), this.computeNodeDepth(i);
                            for (var o = i.getEdges().iterator(); o.hasNext();) {
                                var s = o.next().getSym();
                                if (!s.isVisited()) {
                                    var a = s.getNode();
                                    e.contains(a) || (n.addLast(a), e.add(a))
                                }
                            }
                        }
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0
                    }
                }, {
                    key: "getEnvelope", value: function () {
                        if (null === this._env) {
                            for (var t = new U, e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++) t.expandToInclude(n[r]);
                            this._env = t
                        }
                        return this._env
                    }
                }, {
                    key: "addReachable", value: function (t) {
                        var e = new it;
                        for (e.add(t); !e.empty();) {
                            var n = e.pop();
                            this.add(n, e)
                        }
                    }
                }, {
                    key: "copySymDepths", value: function (t) {
                        var e = t.getSym();
                        e.setDepth(tt.LEFT, t.getDepth(tt.RIGHT)), e.setDepth(tt.RIGHT, t.getDepth(tt.LEFT))
                    }
                }, {
                    key: "add", value: function (t, e) {
                        t.setVisited(!0), this._nodes.add(t);
                        for (var n = t.getEdges().iterator(); n.hasNext();) {
                            var r = n.next();
                            this._dirEdgeList.add(r);
                            var i = r.getSym().getNode();
                            i.isVisited() || e.push(i)
                        }
                    }
                }, {
                    key: "getNodes", value: function () {
                        return this._nodes
                    }
                }, {
                    key: "getDirectedEdges", value: function () {
                        return this._dirEdgeList
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._finder = null, this._dirEdgeList = new dt, this._nodes = new dt, this._rightMostCoord = null, this._env = null, this._finder = new gt
                    }
                }]), e
            }(), _t = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "intersection", value: function (t, e, n, r) {
                        var i = t.x < e.x ? t.x : e.x, o = t.y < e.y ? t.y : e.y, s = t.x > e.x ? t.x : e.x,
                            a = t.y > e.y ? t.y : e.y, u = n.x < r.x ? n.x : r.x, l = n.y < r.y ? n.y : r.y,
                            h = n.x > r.x ? n.x : r.x, c = n.y > r.y ? n.y : r.y,
                            f = ((i > u ? i : u) + (s < h ? s : h)) / 2, g = ((o > l ? o : l) + (a < c ? a : c)) / 2,
                            p = t.x - f, v = t.y - g, d = e.x - f, y = e.y - g, m = n.x - f, _ = n.y - g, x = r.x - f,
                            E = r.y - g, k = v - y, w = d - p, b = p * y - d * v, I = _ - E, S = x - m,
                            N = m * E - x * _, M = k * S - I * w, P = (w * N - S * b) / M, L = (I * b - k * N) / M;
                        return A.isNaN(P) || A.isInfinite(P) || A.isNaN(L) || A.isInfinite(L) ? null : new X(P + f, L + g)
                    }
                }]), e
            }(), xt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "arraycopy", value: function (t, e, n, r, i) {
                        for (var o = 0, s = e; s < e + i; s++) n[r + o] = t[s], o++
                    }
                }, {
                    key: "getProperty", value: function (t) {
                        return {"line.separator": "\n"}[t]
                    }
                }]), e
            }(), Et = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "log10", value: function (t) {
                        var n = Math.log(t);
                        return A.isInfinite(n) || A.isNaN(n) ? n : n / e.LOG_10
                    }
                }, {
                    key: "min", value: function (t, e, n, r) {
                        var i = t;
                        return e < i && (i = e), n < i && (i = n), r < i && (i = r), i
                    }
                }, {
                    key: "clamp", value: function () {
                        if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var t = arguments[0], e = arguments[1], n = arguments[2];
                            return t < e ? e : t > n ? n : t
                        }
                        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                            var r = arguments[0], i = arguments[1], o = arguments[2];
                            return r < i ? i : r > o ? o : r
                        }
                    }
                }, {
                    key: "wrap", value: function (t, e) {
                        return t < 0 ? e - -t % e : t % e
                    }
                }, {
                    key: "max", value: function () {
                        if (3 === arguments.length) {
                            var t = arguments[1], e = arguments[2], n = arguments[0];
                            return t > n && (n = t), e > n && (n = e), n
                        }
                        if (4 === arguments.length) {
                            var r = arguments[1], i = arguments[2], o = arguments[3], s = arguments[0];
                            return r > s && (s = r), i > s && (s = i), o > s && (s = o), s
                        }
                    }
                }, {
                    key: "average", value: function (t, e) {
                        return (t + e) / 2
                    }
                }]), e
            }();
            Et.LOG_10 = Math.log(10);
            var kt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "segmentToSegment", value: function (t, n, r, i) {
                        if (t.equals(n)) return e.pointToSegment(t, r, i);
                        if (r.equals(i)) return e.pointToSegment(i, t, n);
                        var o = !1;
                        if (U.intersects(t, n, r, i)) {
                            var s = (n.x - t.x) * (i.y - r.y) - (n.y - t.y) * (i.x - r.x);
                            if (0 === s) o = !0; else {
                                var a = (t.y - r.y) * (i.x - r.x) - (t.x - r.x) * (i.y - r.y),
                                    u = ((t.y - r.y) * (n.x - t.x) - (t.x - r.x) * (n.y - t.y)) / s, l = a / s;
                                (l < 0 || l > 1 || u < 0 || u > 1) && (o = !0)
                            }
                        } else o = !0;
                        return o ? Et.min(e.pointToSegment(t, r, i), e.pointToSegment(n, r, i), e.pointToSegment(r, t, n), e.pointToSegment(i, t, n)) : 0
                    }
                }, {
                    key: "pointToSegment", value: function (t, e, n) {
                        if (e.x === n.x && e.y === n.y) return t.distance(e);
                        var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
                            i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / r;
                        if (i <= 0) return t.distance(e);
                        if (i >= 1) return t.distance(n);
                        var o = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;
                        return Math.abs(o) * Math.sqrt(r)
                    }
                }, {
                    key: "pointToLinePerpendicular", value: function (t, e, n) {
                        var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
                            i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;
                        return Math.abs(i) * Math.sqrt(r)
                    }
                }, {
                    key: "pointToSegmentString", value: function (t, n) {
                        if (0 === n.length) throw new x("Line array must contain at least one vertex");
                        for (var r = t.distance(n[0]), i = 0; i < n.length - 1; i++) {
                            var o = e.pointToSegment(t, n[i], n[i + 1]);
                            o < r && (r = o)
                        }
                        return r
                    }
                }]), e
            }(), wt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "create", value: function () {
                        if (1 === arguments.length) arguments[0] instanceof Array || ot(arguments[0], ct); else if (2 === arguments.length) ; else if (3 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            return this.create(t, e)
                        }
                    }
                }]), e
            }(), bt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "filter", value: function (t) {
                    }
                }]), e
            }(), It = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "ofLine", value: function (t) {
                        var e = t.size();
                        if (e <= 1) return 0;
                        var n = 0, r = new X;
                        t.getCoordinate(0, r);
                        for (var i = r.x, o = r.y, s = 1; s < e; s++) {
                            t.getCoordinate(s, r);
                            var a = r.x, u = r.y, l = a - i, h = u - o;
                            n += Math.sqrt(l * l + h * h), i = a, o = u
                        }
                        return n
                    }
                }]), e
            }(), St = function e() {
                t(this, e)
            }, Nt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "copyCoord", value: function (t, e, n, r) {
                        for (var i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++) n.setOrdinate(r, o, t.getOrdinate(e, o))
                    }
                }, {
                    key: "isRing", value: function (t) {
                        var e = t.size();
                        return 0 === e || !(e <= 3) && t.getOrdinate(0, ct.X) === t.getOrdinate(e - 1, ct.X) && t.getOrdinate(0, ct.Y) === t.getOrdinate(e - 1, ct.Y)
                    }
                }, {
                    key: "scroll", value: function () {
                        if (2 === arguments.length) {
                            if (ot(arguments[0], ct) && Number.isInteger(arguments[1])) {
                                var t = arguments[0], n = arguments[1];
                                e.scroll(t, n, e.isRing(t))
                            } else if (ot(arguments[0], ct) && arguments[1] instanceof X) {
                                var r = arguments[0], i = arguments[1], o = e.indexOf(i, r);
                                if (o <= 0) return null;
                                e.scroll(r, o)
                            }
                        } else if (3 === arguments.length) {
                            var s = arguments[0], a = arguments[1], u = arguments[2];
                            if (a <= 0) return null;
                            for (var l = s.copy(), h = u ? s.size() - 1 : s.size(), c = 0; c < h; c++) for (var f = 0; f < s.getDimension(); f++) s.setOrdinate(c, f, l.getOrdinate((a + c) % h, f));
                            if (u) for (var g = 0; g < s.getDimension(); g++) s.setOrdinate(h, g, s.getOrdinate(0, g))
                        }
                    }
                }, {
                    key: "isEqual", value: function (t, e) {
                        var n = t.size();
                        if (n !== e.size()) return !1;
                        for (var r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++) for (var o = 0; o < r; o++) {
                            var s = t.getOrdinate(i, o), a = e.getOrdinate(i, o);
                            if (!(t.getOrdinate(i, o) === e.getOrdinate(i, o) || A.isNaN(s) && A.isNaN(a))) return !1
                        }
                        return !0
                    }
                }, {
                    key: "minCoordinateIndex", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return e.minCoordinateIndex(t, 0, t.size() - 1)
                        }
                        if (3 === arguments.length) {
                            for (var n = arguments[0], r = arguments[2], i = -1, o = null, s = arguments[1]; s <= r; s++) {
                                var a = n.getCoordinate(s);
                                (null === o || o.compareTo(a) > 0) && (o = a, i = s)
                            }
                            return i
                        }
                    }
                }, {
                    key: "extend", value: function (t, n, r) {
                        var i = t.create(r, n.getDimension()), o = n.size();
                        if (e.copy(n, 0, i, 0, o), o > 0) for (var s = o; s < r; s++) e.copy(n, o - 1, i, s, 1);
                        return i
                    }
                }, {
                    key: "reverse", value: function (t) {
                        for (var n = t.size() - 1, r = Math.trunc(n / 2), i = 0; i <= r; i++) e.swap(t, i, n - i)
                    }
                }, {
                    key: "swap", value: function (t, e, n) {
                        if (e === n) return null;
                        for (var r = 0; r < t.getDimension(); r++) {
                            var i = t.getOrdinate(e, r);
                            t.setOrdinate(e, r, t.getOrdinate(n, r)), t.setOrdinate(n, r, i)
                        }
                    }
                }, {
                    key: "copy", value: function (t, n, r, i, o) {
                        for (var s = 0; s < o; s++) e.copyCoord(t, n + s, r, i + s)
                    }
                }, {
                    key: "ensureValidRing", value: function (t, n) {
                        var r = n.size();
                        return 0 === r ? n : r <= 3 ? e.createClosedRing(t, n, 4) : n.getOrdinate(0, ct.X) === n.getOrdinate(r - 1, ct.X) && n.getOrdinate(0, ct.Y) === n.getOrdinate(r - 1, ct.Y) ? n : e.createClosedRing(t, n, r + 1)
                    }
                }, {
                    key: "indexOf", value: function (t, e) {
                        for (var n = 0; n < e.size(); n++) if (t.x === e.getOrdinate(n, ct.X) && t.y === e.getOrdinate(n, ct.Y)) return n;
                        return -1
                    }
                }, {
                    key: "createClosedRing", value: function (t, n, r) {
                        var i = t.create(r, n.getDimension()), o = n.size();
                        e.copy(n, 0, i, 0, o);
                        for (var s = o; s < r; s++) e.copy(n, 0, i, s, 1);
                        return i
                    }
                }, {
                    key: "minCoordinate", value: function (t) {
                        for (var e = null, n = 0; n < t.size(); n++) {
                            var r = t.getCoordinate(n);
                            (null === e || e.compareTo(r) > 0) && (e = r)
                        }
                        return e
                    }
                }]), e
            }(), Mt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "toDimensionSymbol", value: function (t) {
                        switch (t) {
                            case e.FALSE:
                                return e.SYM_FALSE;
                            case e.TRUE:
                                return e.SYM_TRUE;
                            case e.DONTCARE:
                                return e.SYM_DONTCARE;
                            case e.P:
                                return e.SYM_P;
                            case e.L:
                                return e.SYM_L;
                            case e.A:
                                return e.SYM_A
                        }
                        throw new x("Unknown dimension value: " + t)
                    }
                }, {
                    key: "toDimensionValue", value: function (t) {
                        switch (ut.toUpperCase(t)) {
                            case e.SYM_FALSE:
                                return e.FALSE;
                            case e.SYM_TRUE:
                                return e.TRUE;
                            case e.SYM_DONTCARE:
                                return e.DONTCARE;
                            case e.SYM_P:
                                return e.P;
                            case e.SYM_L:
                                return e.L;
                            case e.SYM_A:
                                return e.A
                        }
                        throw new x("Unknown dimension symbol: " + t)
                    }
                }]), e
            }();
            Mt.P = 0, Mt.L = 1, Mt.A = 2, Mt.FALSE = -1, Mt.TRUE = -2, Mt.DONTCARE = -3, Mt.SYM_FALSE = "F", Mt.SYM_TRUE = "T", Mt.SYM_DONTCARE = "*", Mt.SYM_P = "0", Mt.SYM_L = "1", Mt.SYM_A = "2";
            var Pt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "filter", value: function (t) {
                    }
                }]), e
            }(), Lt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "filter", value: function (t, e) {
                    }
                }, {
                    key: "isDone", value: function () {
                    }
                }, {
                    key: "isGeometryChanged", value: function () {
                    }
                }]), e
            }(), Ct = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "computeEnvelopeInternal", value: function () {
                        return this.isEmpty() ? new U : this._points.expandEnvelope(new U)
                    }
                }, {
                    key: "isRing", value: function () {
                        return this.isClosed() && this.isSimple()
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        return this._points.toCoordinateArray()
                    }
                }, {
                    key: "copyInternal", value: function () {
                        return new s(this._points.copy(), this._factory)
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            if (!this.isEquivalentClass(t)) return !1;
                            var n = t;
                            if (this._points.size() !== n._points.size()) return !1;
                            for (var r = 0; r < this._points.size(); r++) if (!this.equal(this._points.getCoordinate(r), n._points.getCoordinate(r), e)) return !1;
                            return !0
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "normalize", value: function () {
                        for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {
                            var e = this._points.size() - 1 - t;
                            if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) {
                                if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) {
                                    var n = this._points.copy();
                                    Nt.reverse(n), this._points = n
                                }
                                return null
                            }
                        }
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this.isEmpty() ? null : this._points.getCoordinate(0)
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return this.isClosed() ? Mt.FALSE : 0
                    }
                }, {
                    key: "isClosed", value: function () {
                        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
                    }
                }, {
                    key: "reverseInternal", value: function () {
                        var t = this._points.copy();
                        return Nt.reverse(t), this.getFactory().createLineString(t)
                    }
                }, {
                    key: "getEndPoint", value: function () {
                        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_LINESTRING
                    }
                }, {
                    key: "getDimension", value: function () {
                        return 1
                    }
                }, {
                    key: "getLength", value: function () {
                        return It.ofLine(this._points)
                    }
                }, {
                    key: "getNumPoints", value: function () {
                        return this._points.size()
                    }
                }, {
                    key: "compareToSameClass", value: function () {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {
                                var r = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));
                                if (0 !== r) return r;
                                e++, n++
                            }
                            return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0];
                            return arguments[1].compare(this._points, i._points)
                        }
                    }
                }, {
                    key: "apply", value: function () {
                        if (ot(arguments[0], bt)) for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e)); else if (ot(arguments[0], Lt)) {
                            var n = arguments[0];
                            if (0 === this._points.size()) return null;
                            for (var r = 0; r < this._points.size() && (n.filter(this._points, r), !n.isDone()); r++) ;
                            n.isGeometryChanged() && this.geometryChanged()
                        } else (ot(arguments[0], Pt) || ot(arguments[0], E)) && arguments[0].filter(this)
                    }
                }, {
                    key: "getBoundary", value: function () {
                        throw new J
                    }
                }, {
                    key: "isEquivalentClass", value: function (t) {
                        return t instanceof s
                    }
                }, {
                    key: "getCoordinateN", value: function (t) {
                        return this._points.getCoordinate(t)
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_LINESTRING
                    }
                }, {
                    key: "getCoordinateSequence", value: function () {
                        return this._points
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this._points.size()
                    }
                }, {
                    key: "init", value: function (t) {
                        if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new x("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
                        this._points = t
                    }
                }, {
                    key: "isCoordinate", value: function (t) {
                        for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;
                        return !1
                    }
                }, {
                    key: "getStartPoint", value: function () {
                        return this.isEmpty() ? null : this.getPointN(0)
                    }
                }, {
                    key: "getPointN", value: function (t) {
                        return this.getFactory().createPoint(this._points.getCoordinate(t))
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [St]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._points = null, 0 === arguments.length) ; else if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            V.constructor_.call(this, e), this.init(t)
                        }
                    }
                }]), s
            }(V), Rt = function e() {
                t(this, e)
            }, Tt = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "computeEnvelopeInternal", value: function () {
                        if (this.isEmpty()) return new U;
                        var t = new U;
                        return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        return this.isEmpty() ? [] : [this.getCoordinate()]
                    }
                }, {
                    key: "copyInternal", value: function () {
                        return new s(this._coordinates.copy(), this._factory)
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e))
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "normalize", value: function () {
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return Mt.FALSE
                    }
                }, {
                    key: "reverseInternal", value: function () {
                        return this.getFactory().createPoint(this._coordinates.copy())
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_POINT
                    }
                }, {
                    key: "getDimension", value: function () {
                        return 0
                    }
                }, {
                    key: "getNumPoints", value: function () {
                        return this.isEmpty() ? 0 : 1
                    }
                }, {
                    key: "getX", value: function () {
                        if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");
                        return this.getCoordinate().x
                    }
                }, {
                    key: "compareToSameClass", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.getCoordinate().compareTo(t.getCoordinate())
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0];
                            return arguments[1].compare(this._coordinates, e._coordinates)
                        }
                    }
                }, {
                    key: "apply", value: function () {
                        if (ot(arguments[0], bt)) {
                            var t = arguments[0];
                            if (this.isEmpty()) return null;
                            t.filter(this.getCoordinate())
                        } else if (ot(arguments[0], Lt)) {
                            var e = arguments[0];
                            if (this.isEmpty()) return null;
                            e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged()
                        } else (ot(arguments[0], Pt) || ot(arguments[0], E)) && arguments[0].filter(this)
                    }
                }, {
                    key: "getBoundary", value: function () {
                        return this.getFactory().createGeometryCollection()
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_POINT
                    }
                }, {
                    key: "getCoordinateSequence", value: function () {
                        return this._coordinates
                    }
                }, {
                    key: "getY", value: function () {
                        if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");
                        return this.getCoordinate().y
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this._coordinates.size()
                    }
                }, {
                    key: "init", value: function (t) {
                        null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), G.isTrue(t.size() <= 1), this._coordinates = t
                    }
                }, {
                    key: "isSimple", value: function () {
                        return !0
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Rt]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._coordinates = null;
                        var t = arguments[0], e = arguments[1];
                        V.constructor_.call(this, e), this.init(t)
                    }
                }]), s
            }(V), Ot = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "ofRing", value: function () {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            return Math.abs(e.ofRingSigned(t))
                        }
                        if (ot(arguments[0], ct)) {
                            var n = arguments[0];
                            return Math.abs(e.ofRingSigned(n))
                        }
                    }
                }, {
                    key: "ofRingSigned", value: function () {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            if (t.length < 3) return 0;
                            for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) {
                                var i = t[r].x - n, o = t[r + 1].y;
                                e += i * (t[r - 1].y - o)
                            }
                            return e / 2
                        }
                        if (ot(arguments[0], ct)) {
                            var s = arguments[0], a = s.size();
                            if (a < 3) return 0;
                            var u = new X, l = new X, h = new X;
                            s.getCoordinate(0, l), s.getCoordinate(1, h);
                            var c = l.x;
                            h.x -= c;
                            for (var f = 0, g = 1; g < a - 1; g++) u.y = l.y, l.x = h.x, l.y = h.y, s.getCoordinate(g + 1, h), h.x -= c, f += l.x * (u.y - h.y);
                            return f / 2
                        }
                    }
                }]), e
            }(), At = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "sort", value: function () {
                        var t = arguments, e = arguments[0];
                        if (1 === arguments.length) e.sort((function (t, e) {
                            return t.compareTo(e)
                        })); else if (2 === arguments.length) e.sort((function (e, n) {
                            return t[1].compare(e, n)
                        })); else if (3 === arguments.length) {
                            var n = e.slice(arguments[1], arguments[2]);
                            n.sort();
                            var r = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length));
                            e.splice(0, e.length);
                            var i, o = y(r);
                            try {
                                for (o.s(); !(i = o.n()).done;) {
                                    var s = i.value;
                                    e.push(s)
                                }
                            } catch (t) {
                                o.e(t)
                            } finally {
                                o.f()
                            }
                        } else if (4 === arguments.length) {
                            var a = e.slice(arguments[1], arguments[2]);
                            a.sort((function (e, n) {
                                return t[3].compare(e, n)
                            }));
                            var u = e.slice(0, arguments[1]).concat(a, e.slice(arguments[2], e.length));
                            e.splice(0, e.length);
                            var l, h = y(u);
                            try {
                                for (h.s(); !(l = h.n()).done;) {
                                    var c = l.value;
                                    e.push(c)
                                }
                            } catch (t) {
                                h.e(t)
                            } finally {
                                h.f()
                            }
                        }
                    }
                }, {
                    key: "asList", value: function (t) {
                        var e, n = new dt, r = y(t);
                        try {
                            for (r.s(); !(e = r.n()).done;) {
                                var i = e.value;
                                n.add(i)
                            }
                        } catch (t) {
                            r.e(t)
                        } finally {
                            r.f()
                        }
                        return n
                    }
                }, {
                    key: "copyOf", value: function (t, e) {
                        return t.slice(0, e)
                    }
                }]), e
            }(), Dt = function e() {
                t(this, e)
            }, Ft = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "computeEnvelopeInternal", value: function () {
                        return this._shell.getEnvelopeInternal()
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        if (this.isEmpty()) return [];
                        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), r = 0; r < n.length; r++) t[++e] = n[r];
                        for (var i = 0; i < this._holes.length; i++) for (var o = this._holes[i].getCoordinates(), s = 0; s < o.length; s++) t[++e] = o[s];
                        return t
                    }
                }, {
                    key: "getArea", value: function () {
                        var t = 0;
                        t += Ot.ofRing(this._shell.getCoordinateSequence());
                        for (var e = 0; e < this._holes.length; e++) t -= Ot.ofRing(this._holes[e].getCoordinateSequence());
                        return t
                    }
                }, {
                    key: "copyInternal", value: function () {
                        for (var t = this._shell.copy(), e = new Array(this._holes.length).fill(null), n = 0; n < this._holes.length; n++) e[n] = this._holes[n].copy();
                        return new s(t, e, this._factory)
                    }
                }, {
                    key: "isRectangle", value: function () {
                        if (0 !== this.getNumInteriorRing()) return !1;
                        if (null === this._shell) return !1;
                        if (5 !== this._shell.getNumPoints()) return !1;
                        for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
                            var r = t.getX(n);
                            if (r !== e.getMinX() && r !== e.getMaxX()) return !1;
                            var i = t.getY(n);
                            if (i !== e.getMinY() && i !== e.getMaxY()) return !1
                        }
                        for (var o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {
                            var u = t.getX(a), l = t.getY(a);
                            if (u !== o == (l !== s)) return !1;
                            o = u, s = l
                        }
                        return !0
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            if (!this.isEquivalentClass(t)) return !1;
                            var n = t, r = this._shell, i = n._shell;
                            if (!r.equalsExact(i, e)) return !1;
                            if (this._holes.length !== n._holes.length) return !1;
                            for (var a = 0; a < this._holes.length; a++) if (!this._holes[a].equalsExact(n._holes[a], e)) return !1;
                            return !0
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "normalize", value: function () {
                        if (0 === arguments.length) {
                            this._shell = this.normalized(this._shell, !0);
                            for (var t = 0; t < this._holes.length; t++) this._holes[t] = this.normalized(this._holes[t], !1);
                            At.sort(this._holes)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            if (e.isEmpty()) return null;
                            var r = e.getCoordinateSequence(), i = Nt.minCoordinateIndex(r, 0, r.size() - 2);
                            Nt.scroll(r, i, !0), ft.isCCW(r) === n && Nt.reverse(r)
                        }
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this._shell.getCoordinate()
                    }
                }, {
                    key: "getNumInteriorRing", value: function () {
                        return this._holes.length
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return 1
                    }
                }, {
                    key: "reverseInternal", value: function () {
                        for (var t = this.getExteriorRing().reverse(), e = new Array(this.getNumInteriorRing()).fill(null), n = 0; n < e.length; n++) e[n] = this.getInteriorRingN(n).reverse();
                        return this.getFactory().createPolygon(t, e)
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_POLYGON
                    }
                }, {
                    key: "getDimension", value: function () {
                        return 2
                    }
                }, {
                    key: "getLength", value: function () {
                        var t = 0;
                        t += this._shell.getLength();
                        for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();
                        return t
                    }
                }, {
                    key: "getNumPoints", value: function () {
                        for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();
                        return t
                    }
                }, {
                    key: "convexHull", value: function () {
                        return this.getExteriorRing().convexHull()
                    }
                }, {
                    key: "normalized", value: function (t, e) {
                        var n = t.copy();
                        return this.normalize(n, e), n
                    }
                }, {
                    key: "compareToSameClass", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0], e = this._shell, n = t._shell;
                            return e.compareToSameClass(n)
                        }
                        if (2 === arguments.length) {
                            var r = arguments[1], i = arguments[0], o = this._shell, s = i._shell,
                                a = o.compareToSameClass(s, r);
                            if (0 !== a) return a;
                            for (var u = this.getNumInteriorRing(), l = i.getNumInteriorRing(), h = 0; h < u && h < l;) {
                                var c = this.getInteriorRingN(h), f = i.getInteriorRingN(h),
                                    g = c.compareToSameClass(f, r);
                                if (0 !== g) return g;
                                h++
                            }
                            return h < u ? 1 : h < l ? -1 : 0
                        }
                    }
                }, {
                    key: "apply", value: function () {
                        if (ot(arguments[0], bt)) {
                            var t = arguments[0];
                            this._shell.apply(t);
                            for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
                        } else if (ot(arguments[0], Lt)) {
                            var n = arguments[0];
                            if (this._shell.apply(n), !n.isDone()) for (var r = 0; r < this._holes.length && (this._holes[r].apply(n), !n.isDone()); r++) ;
                            n.isGeometryChanged() && this.geometryChanged()
                        } else if (ot(arguments[0], Pt)) arguments[0].filter(this); else if (ot(arguments[0], E)) {
                            var i = arguments[0];
                            i.filter(this), this._shell.apply(i);
                            for (var o = 0; o < this._holes.length; o++) this._holes[o].apply(i)
                        }
                    }
                }, {
                    key: "getBoundary", value: function () {
                        if (this.isEmpty()) return this.getFactory().createMultiLineString();
                        var t = new Array(this._holes.length + 1).fill(null);
                        t[0] = this._shell;
                        for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];
                        return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_POLYGON
                    }
                }, {
                    key: "getExteriorRing", value: function () {
                        return this._shell
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return this._shell.isEmpty()
                    }
                }, {
                    key: "getInteriorRingN", value: function (t) {
                        return this._holes[t]
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Dt]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._shell = null, this._holes = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        if (V.constructor_.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), V.hasNullElements(e)) throw new x("holes must not contain null elements");
                        if (t.isEmpty() && V.hasNonEmptyElements(e)) throw new x("shell is empty but holes are not");
                        this._shell = t, this._holes = e
                    }
                }]), s
            }(V), qt = function (e) {
                i(r, e);
                var n = f(r);

                function r() {
                    return t(this, r), n.apply(this, arguments)
                }

                return r
            }(Q), Gt = function (e) {
                i(o, e);
                var n = f(o);

                function o(e) {
                    var r;
                    return t(this, o), (r = n.call(this)).array = [], e instanceof H && r.addAll(e), r
                }

                return r(o, [{
                    key: "contains", value: function (t) {
                        var e, n = y(this.array);
                        try {
                            for (n.s(); !(e = n.n()).done;) if (0 === e.value.compareTo(t)) return !0
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                        return !1
                    }
                }, {
                    key: "add", value: function (t) {
                        if (this.contains(t)) return !1;
                        for (var e = 0, n = this.array.length; e < n; e++) if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t);
                        return this.array.push(t), !0
                    }
                }, {
                    key: "addAll", value: function (t) {
                        var e, n = y(t);
                        try {
                            for (n.s(); !(e = n.n()).done;) {
                                var r = e.value;
                                this.add(r)
                            }
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                        return !0
                    }
                }, {
                    key: "remove", value: function () {
                        throw new J
                    }
                }, {
                    key: "size", value: function () {
                        return this.array.length
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this.array.length
                    }
                }, {
                    key: "toArray", value: function () {
                        return this.array.slice()
                    }
                }, {
                    key: "iterator", value: function () {
                        return new Yt(this.array)
                    }
                }]), o
            }(qt), Yt = function () {
                function e(n) {
                    t(this, e), this.array = n, this.position = 0
                }

                return r(e, [{
                    key: "next", value: function () {
                        if (this.position === this.array.length) throw new W;
                        return this.array[this.position++]
                    }
                }, {
                    key: "hasNext", value: function () {
                        return this.position < this.array.length
                    }
                }, {
                    key: "remove", value: function () {
                        throw new J
                    }
                }]), e
            }(), Bt = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "computeEnvelopeInternal", value: function () {
                        for (var t = new U, e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());
                        return t
                    }
                }, {
                    key: "getGeometryN", value: function (t) {
                        return this._geometries[t]
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++) t[++e] = r[i];
                        return t
                    }
                }, {
                    key: "getArea", value: function () {
                        for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();
                        return t
                    }
                }, {
                    key: "copyInternal", value: function () {
                        for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
                        return new s(t, this._factory)
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            if (!this.isEquivalentClass(t)) return !1;
                            var n = t;
                            if (this._geometries.length !== n._geometries.length) return !1;
                            for (var r = 0; r < this._geometries.length; r++) if (!this._geometries[r].equalsExact(n._geometries[r], e)) return !1;
                            return !0
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "normalize", value: function () {
                        for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();
                        At.sort(this._geometries)
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this.isEmpty() ? null : this._geometries[0].getCoordinate()
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        for (var t = Mt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());
                        return t
                    }
                }, {
                    key: "reverseInternal", value: function () {
                        for (var t = this._geometries.length, e = new dt(t), n = 0; n < t; n++) e.add(this._geometries[n].reverse());
                        return this.getFactory().buildGeometry(e)
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_GEOMETRYCOLLECTION
                    }
                }, {
                    key: "getDimension", value: function () {
                        for (var t = Mt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());
                        return t
                    }
                }, {
                    key: "getLength", value: function () {
                        for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();
                        return t
                    }
                }, {
                    key: "getNumPoints", value: function () {
                        for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();
                        return t
                    }
                }, {
                    key: "getNumGeometries", value: function () {
                        return this._geometries.length
                    }
                }, {
                    key: "compareToSameClass", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0], e = new Gt(At.asList(this._geometries)),
                                n = new Gt(At.asList(t._geometries));
                            return this.compare(e, n)
                        }
                        if (2 === arguments.length) {
                            for (var r = arguments[1], i = arguments[0], o = this.getNumGeometries(), s = i.getNumGeometries(), a = 0; a < o && a < s;) {
                                var u = this.getGeometryN(a), l = i.getGeometryN(a), h = u.compareToSameClass(l, r);
                                if (0 !== h) return h;
                                a++
                            }
                            return a < o ? 1 : a < s ? -1 : 0
                        }
                    }
                }, {
                    key: "apply", value: function () {
                        if (ot(arguments[0], bt)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t); else if (ot(arguments[0], Lt)) {
                            var n = arguments[0];
                            if (0 === this._geometries.length) return null;
                            for (var r = 0; r < this._geometries.length && (this._geometries[r].apply(n), !n.isDone()); r++) ;
                            n.isGeometryChanged() && this.geometryChanged()
                        } else if (ot(arguments[0], Pt)) {
                            var i = arguments[0];
                            i.filter(this);
                            for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(i)
                        } else if (ot(arguments[0], E)) {
                            var s = arguments[0];
                            s.filter(this);
                            for (var a = 0; a < this._geometries.length; a++) this._geometries[a].apply(s)
                        }
                    }
                }, {
                    key: "getBoundary", value: function () {
                        return V.checkNotGeometryCollection(this), G.shouldNeverReachHere(), null
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_GEOMETRYCOLLECTION
                    }
                }, {
                    key: "isEmpty", value: function () {
                        for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;
                        return !0
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._geometries = null, 0 === arguments.length) ; else if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            if (V.constructor_.call(this, e), null === t && (t = []), V.hasNullElements(t)) throw new x("geometries must not contain null elements");
                            this._geometries = t
                        }
                    }
                }]), s
            }(V), zt = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "copyInternal", value: function () {
                        for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
                        return new s(t, this._factory)
                    }
                }, {
                    key: "isValid", value: function () {
                        return !0
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            return !!this.isEquivalentClass(t) && g(o(s.prototype), "equalsExact", this).call(this, t, e)
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        if (1 === arguments.length && Number.isInteger(arguments[0])) {
                            var t = arguments[0];
                            return this._geometries[t].getCoordinate()
                        }
                        return g(o(s.prototype), "getCoordinate", this).apply(this, arguments)
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return Mt.FALSE
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_MULTIPOINT
                    }
                }, {
                    key: "getDimension", value: function () {
                        return 0
                    }
                }, {
                    key: "getBoundary", value: function () {
                        return this.getFactory().createGeometryCollection()
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_MULTIPOINT
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Rt]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0], e = arguments[1];
                        Bt.constructor_.call(this, t, e)
                    }
                }]), s
            }(Bt), Xt = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "copyInternal", value: function () {
                        return new s(this._points.copy(), this._factory)
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return Mt.FALSE
                    }
                }, {
                    key: "isClosed", value: function () {
                        return !!this.isEmpty() || g(o(s.prototype), "isClosed", this).call(this)
                    }
                }, {
                    key: "reverseInternal", value: function () {
                        var t = this._points.copy();
                        return Nt.reverse(t), this.getFactory().createLinearRing(t)
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_LINEARRING
                    }
                }, {
                    key: "validateConstruction", value: function () {
                        if (!this.isEmpty() && !g(o(s.prototype), "isClosed", this).call(this)) throw new x("Points of LinearRing do not form a closed linestring");
                        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < s.MINIMUM_VALID_SIZE) throw new x("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_LINEARRING
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0], e = arguments[1];
                        Ct.constructor_.call(this, t, e), this.validateConstruction()
                    }
                }]), s
            }(Ct);
            Xt.MINIMUM_VALID_SIZE = 4;
            var jt = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "setOrdinate", value: function (t, e) {
                        switch (t) {
                            case o.X:
                                this.x = e;
                                break;
                            case o.Y:
                                this.y = e;
                                break;
                            default:
                                throw new x("Invalid ordinate index: " + t)
                        }
                    }
                }, {
                    key: "getZ", value: function () {
                        return X.NULL_ORDINATE
                    }
                }, {
                    key: "getOrdinate", value: function (t) {
                        switch (t) {
                            case o.X:
                                return this.x;
                            case o.Y:
                                return this.y
                        }
                        throw new x("Invalid ordinate index: " + t)
                    }
                }, {
                    key: "setZ", value: function (t) {
                        throw new x("CoordinateXY dimension 2 does not support z-ordinate")
                    }
                }, {
                    key: "copy", value: function () {
                        return new o(this)
                    }
                }, {
                    key: "toString", value: function () {
                        return "(" + this.x + ", " + this.y + ")"
                    }
                }, {
                    key: "setCoordinate", value: function (t) {
                        this.x = t.x, this.y = t.y, this.z = t.getZ()
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (0 === arguments.length) X.constructor_.call(this); else if (1 === arguments.length) {
                            if (arguments[0] instanceof o) {
                                var t = arguments[0];
                                X.constructor_.call(this, t.x, t.y)
                            } else if (arguments[0] instanceof X) {
                                var e = arguments[0];
                                X.constructor_.call(this, e.x, e.y)
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            X.constructor_.call(this, n, r, X.NULL_ORDINATE)
                        }
                    }
                }]), o
            }(X);
            jt.X = 0, jt.Y = 1, jt.Z = -1, jt.M = -1;
            var Ut = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "getM", value: function () {
                        return this._m
                    }
                }, {
                    key: "setOrdinate", value: function (t, e) {
                        switch (t) {
                            case o.X:
                                this.x = e;
                                break;
                            case o.Y:
                                this.y = e;
                                break;
                            case o.M:
                                this._m = e;
                                break;
                            default:
                                throw new x("Invalid ordinate index: " + t)
                        }
                    }
                }, {
                    key: "setM", value: function (t) {
                        this._m = t
                    }
                }, {
                    key: "getZ", value: function () {
                        return X.NULL_ORDINATE
                    }
                }, {
                    key: "getOrdinate", value: function (t) {
                        switch (t) {
                            case o.X:
                                return this.x;
                            case o.Y:
                                return this.y;
                            case o.M:
                                return this._m
                        }
                        throw new x("Invalid ordinate index: " + t)
                    }
                }, {
                    key: "setZ", value: function (t) {
                        throw new x("CoordinateXY dimension 2 does not support z-ordinate")
                    }
                }, {
                    key: "copy", value: function () {
                        return new o(this)
                    }
                }, {
                    key: "toString", value: function () {
                        return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")"
                    }
                }, {
                    key: "setCoordinate", value: function (t) {
                        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM()
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0; else if (1 === arguments.length) {
                            if (arguments[0] instanceof o) {
                                var t = arguments[0];
                                X.constructor_.call(this, t.x, t.y), this._m = t._m
                            } else if (arguments[0] instanceof X) {
                                var e = arguments[0];
                                X.constructor_.call(this, e.x, e.y), this._m = this.getM()
                            }
                        } else if (3 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2];
                            X.constructor_.call(this, n, r, X.NULL_ORDINATE), this._m = i
                        }
                    }
                }]), o
            }(X);
            Ut.X = 0, Ut.Y = 1, Ut.Z = -1, Ut.M = 2;
            var Vt = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "getM", value: function () {
                        return this._m
                    }
                }, {
                    key: "setOrdinate", value: function (t, e) {
                        switch (t) {
                            case X.X:
                                this.x = e;
                                break;
                            case X.Y:
                                this.y = e;
                                break;
                            case X.Z:
                                this.z = e;
                                break;
                            case X.M:
                                this._m = e;
                                break;
                            default:
                                throw new x("Invalid ordinate index: " + t)
                        }
                    }
                }, {
                    key: "setM", value: function (t) {
                        this._m = t
                    }
                }, {
                    key: "getOrdinate", value: function (t) {
                        switch (t) {
                            case X.X:
                                return this.x;
                            case X.Y:
                                return this.y;
                            case X.Z:
                                return this.getZ();
                            case X.M:
                                return this.getM()
                        }
                        throw new x("Invalid ordinate index: " + t)
                    }
                }, {
                    key: "copy", value: function () {
                        return new o(this)
                    }
                }, {
                    key: "toString", value: function () {
                        return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")"
                    }
                }, {
                    key: "setCoordinate", value: function (t) {
                        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM()
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0; else if (1 === arguments.length) {
                            if (arguments[0] instanceof o) {
                                var t = arguments[0];
                                X.constructor_.call(this, t), this._m = t._m
                            } else if (arguments[0] instanceof X) {
                                var e = arguments[0];
                                X.constructor_.call(this, e), this._m = this.getM()
                            }
                        } else if (4 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2], s = arguments[3];
                            X.constructor_.call(this, n, r, i), this._m = s
                        }
                    }
                }]), o
            }(X), Zt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "measures", value: function (t) {
                        return t instanceof jt ? 0 : t instanceof Ut || t instanceof Vt ? 1 : 0
                    }
                }, {
                    key: "dimension", value: function (t) {
                        return t instanceof jt ? 2 : t instanceof Ut ? 3 : t instanceof Vt ? 4 : 3
                    }
                }, {
                    key: "create", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return e.create(t, 0)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            return 2 === n ? new jt : 3 === n && 0 === r ? new X : 3 === n && 1 === r ? new Ut : 4 === n && 1 === r ? new Vt : new X
                        }
                    }
                }]), e
            }(), Ht = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "getCoordinate", value: function (t) {
                        return this.get(t)
                    }
                }, {
                    key: "addAll", value: function () {
                        if (2 === arguments.length && "boolean" == typeof arguments[1] && ot(arguments[0], H)) {
                            for (var t = arguments[1], e = !1, n = arguments[0].iterator(); n.hasNext();) this.add(n.next(), t), e = !0;
                            return e
                        }
                        return g(o(s.prototype), "addAll", this).apply(this, arguments)
                    }
                }, {
                    key: "clone", value: function () {
                        for (var t = g(o(s.prototype), "clone", this).call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).clone());
                        return t
                    }
                }, {
                    key: "toCoordinateArray", value: function () {
                        if (0 === arguments.length) return this.toArray(s.coordArrayType);
                        if (1 === arguments.length) {
                            if (arguments[0]) return this.toArray(s.coordArrayType);
                            for (var t = this.size(), e = new Array(t).fill(null), n = 0; n < t; n++) e[n] = this.get(t - n - 1);
                            return e
                        }
                    }
                }, {
                    key: "add", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return g(o(s.prototype), "add", this).call(this, t)
                        }
                        if (2 === arguments.length) {
                            if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                                var e = arguments[0], n = arguments[1];
                                return this.add(e, n, !0), !0
                            }
                            if (arguments[0] instanceof X && "boolean" == typeof arguments[1]) {
                                var r = arguments[0];
                                if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(r)) return null;
                                g(o(s.prototype), "add", this).call(this, r)
                            } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                                var i = arguments[0], a = arguments[1];
                                return this.add(i, a), !0
                            }
                        } else if (3 === arguments.length) {
                            if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                                var u = arguments[0], l = arguments[1];
                                if (arguments[2]) for (var h = 0; h < u.length; h++) this.add(u[h], l); else for (var c = u.length - 1; c >= 0; c--) this.add(u[c], l);
                                return !0
                            }
                            if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof X) {
                                var f = arguments[0], p = arguments[1];
                                if (!arguments[2]) {
                                    var v = this.size();
                                    if (v > 0) {
                                        if (f > 0 && this.get(f - 1).equals2D(p)) return null;
                                        if (f < v && this.get(f).equals2D(p)) return null
                                    }
                                }
                                g(o(s.prototype), "add", this).call(this, f, p)
                            }
                        } else if (4 === arguments.length) {
                            var d = arguments[0], y = arguments[1], m = arguments[2], _ = arguments[3], x = 1;
                            m > _ && (x = -1);
                            for (var E = m; E !== _; E += x) this.add(d[E], y);
                            return !0
                        }
                    }
                }, {
                    key: "closeRing", value: function () {
                        if (this.size() > 0) {
                            var t = this.get(0).copy();
                            this.add(t, !1)
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (0 === arguments.length) ; else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.ensureCapacity(t.length), this.add(t, !0)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            this.ensureCapacity(e.length), this.add(e, n)
                        }
                    }
                }]), s
            }(dt);
            Ht.coordArrayType = new Array(0).fill(null);
            var Wt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "isRing", value: function (t) {
                        return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
                    }
                }, {
                    key: "ptNotInList", value: function (t, n) {
                        for (var r = 0; r < t.length; r++) {
                            var i = t[r];
                            if (e.indexOf(i, n) < 0) return i
                        }
                        return null
                    }
                }, {
                    key: "scroll", value: function (t, n) {
                        var r = e.indexOf(n, t);
                        if (r < 0) return null;
                        var i = new Array(t.length).fill(null);
                        xt.arraycopy(t, r, i, 0, t.length - r), xt.arraycopy(t, 0, i, t.length - r, r), xt.arraycopy(i, 0, t, 0, t.length)
                    }
                }, {
                    key: "equals", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            if (t === e) return !0;
                            if (null === t || null === e) return !1;
                            if (t.length !== e.length) return !1;
                            for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;
                            return !0
                        }
                        if (3 === arguments.length) {
                            var r = arguments[0], i = arguments[1], o = arguments[2];
                            if (r === i) return !0;
                            if (null === r || null === i) return !1;
                            if (r.length !== i.length) return !1;
                            for (var s = 0; s < r.length; s++) if (0 !== o.compare(r[s], i[s])) return !1;
                            return !0
                        }
                    }
                }, {
                    key: "intersection", value: function (t, e) {
                        for (var n = new Ht, r = 0; r < t.length; r++) e.intersects(t[r]) && n.add(t[r], !0);
                        return n.toCoordinateArray()
                    }
                }, {
                    key: "measures", value: function (t) {
                        if (null === t || 0 === t.length) return 0;
                        var e, n = 0, r = y(t);
                        try {
                            for (r.s(); !(e = r.n()).done;) {
                                var i = e.value;
                                n = Math.max(n, Zt.measures(i))
                            }
                        } catch (t) {
                            r.e(t)
                        } finally {
                            r.f()
                        }
                        return n
                    }
                }, {
                    key: "hasRepeatedPoints", value: function (t) {
                        for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
                        return !1
                    }
                }, {
                    key: "removeRepeatedPoints", value: function (t) {
                        return e.hasRepeatedPoints(t) ? new Ht(t, !1).toCoordinateArray() : t
                    }
                }, {
                    key: "reverse", value: function (t) {
                        for (var e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) {
                            var i = t[r];
                            t[r] = t[e - r], t[e - r] = i
                        }
                    }
                }, {
                    key: "removeNull", value: function (t) {
                        for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;
                        var r = new Array(e).fill(null);
                        if (0 === e) return r;
                        for (var i = 0, o = 0; o < t.length; o++) null !== t[o] && (r[i++] = t[o]);
                        return r
                    }
                }, {
                    key: "copyDeep", value: function () {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = t[n].copy();
                            return e
                        }
                        if (5 === arguments.length) for (var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++) o[s + u] = r[i + u].copy()
                    }
                }, {
                    key: "isEqualReversed", value: function (t, e) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n], i = e[t.length - n - 1];
                            if (0 !== r.compareTo(i)) return !1
                        }
                        return !0
                    }
                }, {
                    key: "envelope", value: function (t) {
                        for (var e = new U, n = 0; n < t.length; n++) e.expandToInclude(t[n]);
                        return e
                    }
                }, {
                    key: "toCoordinateArray", value: function (t) {
                        return t.toArray(e.coordArrayType)
                    }
                }, {
                    key: "dimension", value: function (t) {
                        if (null === t || 0 === t.length) return 3;
                        var e, n = 0, r = y(t);
                        try {
                            for (r.s(); !(e = r.n()).done;) {
                                var i = e.value;
                                n = Math.max(n, Zt.dimension(i))
                            }
                        } catch (t) {
                            r.e(t)
                        } finally {
                            r.f()
                        }
                        return n
                    }
                }, {
                    key: "atLeastNCoordinatesOrNothing", value: function (t, e) {
                        return e.length >= t ? e : []
                    }
                }, {
                    key: "indexOf", value: function (t, e) {
                        for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;
                        return -1
                    }
                }, {
                    key: "increasingDirection", value: function (t) {
                        for (var e = 0; e < Math.trunc(t.length / 2); e++) {
                            var n = t.length - 1 - e, r = t[e].compareTo(t[n]);
                            if (0 !== r) return r
                        }
                        return 1
                    }
                }, {
                    key: "compare", value: function (t, e) {
                        for (var n = 0; n < t.length && n < e.length;) {
                            var r = t[n].compareTo(e[n]);
                            if (0 !== r) return r;
                            n++
                        }
                        return n < e.length ? -1 : n < t.length ? 1 : 0
                    }
                }, {
                    key: "minCoordinate", value: function (t) {
                        for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
                        return e
                    }
                }, {
                    key: "extract", value: function (t, e, n) {
                        e = Et.clamp(e, 0, t.length);
                        var r = (n = Et.clamp(n, -1, t.length)) - e + 1;
                        n < 0 && (r = 0), e >= t.length && (r = 0), n < e && (r = 0);
                        var i = new Array(r).fill(null);
                        if (0 === r) return i;
                        for (var o = 0, s = e; s <= n; s++) i[o++] = t[s];
                        return i
                    }
                }]), e
            }(), Jt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "compare", value: function (t, e) {
                        var n = t, r = e;
                        return Wt.compare(n, r)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [D]
                    }
                }]), e
            }(), Qt = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "compare", value: function (t, e) {
                        var n = t, r = e;
                        if (n.length < r.length) return -1;
                        if (n.length > r.length) return 1;
                        if (0 === n.length) return 0;
                        var i = Wt.compare(n, r);
                        return Wt.isEqualReversed(n, r) ? 0 : i
                    }
                }, {
                    key: "OLDcompare", value: function (t, e) {
                        var n = t, r = e;
                        if (n.length < r.length) return -1;
                        if (n.length > r.length) return 1;
                        if (0 === n.length) return 0;
                        for (var i = Wt.increasingDirection(n), o = Wt.increasingDirection(r), s = i > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {
                            var l = n[s].compareTo(r[a]);
                            if (0 !== l) return l;
                            s += i, a += o
                        }
                        return 0
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [D]
                    }
                }]), e
            }();
            Wt.ForwardComparator = Jt, Wt.BidirectionalComparator = Qt, Wt.coordArrayType = new Array(0).fill(null);
            var Kt = function () {
                function e(n) {
                    t(this, e), this.str = n
                }

                return r(e, [{
                    key: "append", value: function (t) {
                        this.str += t
                    }
                }, {
                    key: "setCharAt", value: function (t, e) {
                        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
                    }
                }, {
                    key: "toString", value: function () {
                        return this.str
                    }
                }]), e
            }(), $t = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getM", value: function (t) {
                        return this.hasM() ? this._coordinates[t].getM() : A.NaN
                    }
                }, {
                    key: "setOrdinate", value: function (t, e, n) {
                        switch (e) {
                            case ct.X:
                                this._coordinates[t].x = n;
                                break;
                            case ct.Y:
                                this._coordinates[t].y = n;
                                break;
                            default:
                                this._coordinates[t].setOrdinate(e, n)
                        }
                    }
                }, {
                    key: "getZ", value: function (t) {
                        return this.hasZ() ? this._coordinates[t].getZ() : A.NaN
                    }
                }, {
                    key: "size", value: function () {
                        return this._coordinates.length
                    }
                }, {
                    key: "getOrdinate", value: function (t, e) {
                        switch (e) {
                            case ct.X:
                                return this._coordinates[t].x;
                            case ct.Y:
                                return this._coordinates[t].y;
                            default:
                                return this._coordinates[t].getOrdinate(e)
                        }
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this._coordinates[t]
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0];
                            arguments[1].setCoordinate(this._coordinates[e])
                        }
                    }
                }, {
                    key: "getCoordinateCopy", value: function (t) {
                        var e = this.createCoordinate();
                        return e.setCoordinate(this._coordinates[t]), e
                    }
                }, {
                    key: "createCoordinate", value: function () {
                        return Zt.create(this.getDimension(), this.getMeasures())
                    }
                }, {
                    key: "getDimension", value: function () {
                        return this._dimension
                    }
                }, {
                    key: "getX", value: function (t) {
                        return this._coordinates[t].x
                    }
                }, {
                    key: "getMeasures", value: function () {
                        return this._measures
                    }
                }, {
                    key: "expandEnvelope", value: function (t) {
                        for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);
                        return t
                    }
                }, {
                    key: "copy", value: function () {
                        for (var t = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++) {
                            var r = this.createCoordinate();
                            r.setCoordinate(this._coordinates[n]), t[n] = r
                        }
                        return new e(t, this._dimension, this._measures)
                    }
                }, {
                    key: "toString", value: function () {
                        if (this._coordinates.length > 0) {
                            var t = new Kt(17 * this._coordinates.length);
                            t.append("("), t.append(this._coordinates[0]);
                            for (var e = 1; e < this._coordinates.length; e++) t.append(", "), t.append(this._coordinates[e]);
                            return t.append(")"), t.toString()
                        }
                        return "()"
                    }
                }, {
                    key: "getY", value: function (t) {
                        return this._coordinates[t].y
                    }
                }, {
                    key: "toCoordinateArray", value: function () {
                        return this._coordinates
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [ct, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) {
                            if (arguments[0] instanceof Array) {
                                var t = arguments[0];
                                e.constructor_.call(this, t, Wt.dimension(t), Wt.measures(t))
                            } else if (Number.isInteger(arguments[0])) {
                                var n = arguments[0];
                                this._coordinates = new Array(n).fill(null);
                                for (var r = 0; r < n; r++) this._coordinates[r] = new X
                            } else if (ot(arguments[0], ct)) {
                                var i = arguments[0];
                                if (null === i) return this._coordinates = new Array(0).fill(null), null;
                                this._dimension = i.getDimension(), this._measures = i.getMeasures(), this._coordinates = new Array(i.size()).fill(null);
                                for (var o = 0; o < this._coordinates.length; o++) this._coordinates[o] = i.getCoordinateCopy(o)
                            }
                        } else if (2 === arguments.length) {
                            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                                var s = arguments[0], a = arguments[1];
                                e.constructor_.call(this, s, a, Wt.measures(s))
                            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                                var u = arguments[0], l = arguments[1];
                                this._coordinates = new Array(u).fill(null), this._dimension = l;
                                for (var h = 0; h < u; h++) this._coordinates[h] = Zt.create(l)
                            }
                        } else if (3 === arguments.length) if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                            var c = arguments[0], f = arguments[1], g = arguments[2];
                            this._dimension = f, this._measures = g, this._coordinates = null === c ? new Array(0).fill(null) : c
                        } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                            var p = arguments[0], v = arguments[1], d = arguments[2];
                            this._coordinates = new Array(p).fill(null), this._dimension = v, this._measures = d;
                            for (var y = 0; y < p; y++) this._coordinates[y] = this.createCoordinate()
                        }
                    }
                }]), e
            }(), te = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "readResolve", value: function () {
                        return e.instance()
                    }
                }, {
                    key: "create", value: function () {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof Array) return new $t(arguments[0]);
                            if (ot(arguments[0], ct)) return new $t(arguments[0])
                        } else {
                            if (2 === arguments.length) {
                                var t = arguments[1];
                                return t > 3 && (t = 3), t < 2 && (t = 2), new $t(arguments[0], t)
                            }
                            if (3 === arguments.length) {
                                var e = arguments[2], n = arguments[1] - e;
                                return e > 1 && (e = 1), n > 3 && (n = 3), n < 2 && (n = 2), new $t(arguments[0], n + e, e)
                            }
                        }
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [wt, b]
                    }
                }], [{
                    key: "instance", value: function () {
                        return e.instanceObject
                    }
                }]), e
            }();
            te.instanceObject = new te;
            var ee = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "copyInternal", value: function () {
                        for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
                        return new s(t, this._factory)
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            return !!this.isEquivalentClass(t) && g(o(s.prototype), "equalsExact", this).call(this, t, e)
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return 1
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_MULTIPOLYGON
                    }
                }, {
                    key: "getDimension", value: function () {
                        return 2
                    }
                }, {
                    key: "getBoundary", value: function () {
                        if (this.isEmpty()) return this.getFactory().createMultiLineString();
                        for (var t = new dt, e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++) t.add(n.getGeometryN(r));
                        var i = new Array(t.size()).fill(null);
                        return this.getFactory().createMultiLineString(t.toArray(i))
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_MULTIPOLYGON
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Dt]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0], e = arguments[1];
                        Bt.constructor_.call(this, t, e)
                    }
                }]), s
            }(Bt), ne = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "get", value: function () {
                    }
                }, {
                    key: "put", value: function () {
                    }
                }, {
                    key: "size", value: function () {
                    }
                }, {
                    key: "values", value: function () {
                    }
                }, {
                    key: "entrySet", value: function () {
                    }
                }]), e
            }(), re = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), (e = n.call(this)).map = new Map, e
                }

                return r(o, [{
                    key: "get", value: function (t) {
                        return this.map.get(t) || null
                    }
                }, {
                    key: "put", value: function (t, e) {
                        return this.map.set(t, e), e
                    }
                }, {
                    key: "values", value: function () {
                        for (var t = new dt, e = this.map.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();
                        return t
                    }
                }, {
                    key: "entrySet", value: function () {
                        var t = new K;
                        return this.map.entries().forEach((function (e) {
                            return t.add(e)
                        })), t
                    }
                }, {
                    key: "size", value: function () {
                        return this.map.size()
                    }
                }]), o
            }(ne), ie = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "equals", value: function (t) {
                        if (!(t instanceof e)) return !1;
                        var n = t;
                        return this._modelType === n._modelType && this._scale === n._scale
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t, n = this.getMaximumSignificantDigits(), r = e.getMaximumSignificantDigits();
                        return at.compare(n, r)
                    }
                }, {
                    key: "getScale", value: function () {
                        return this._scale
                    }
                }, {
                    key: "isFloating", value: function () {
                        return this._modelType === e.FLOATING || this._modelType === e.FLOATING_SINGLE
                    }
                }, {
                    key: "getType", value: function () {
                        return this._modelType
                    }
                }, {
                    key: "toString", value: function () {
                        var t = "UNKNOWN";
                        return this._modelType === e.FLOATING ? t = "Floating" : this._modelType === e.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === e.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t
                    }
                }, {
                    key: "makePrecise", value: function () {
                        if ("number" == typeof arguments[0]) {
                            var t = arguments[0];
                            return A.isNaN(t) || this._modelType === e.FLOATING_SINGLE ? t : this._modelType === e.FIXED ? Math.round(t * this._scale) / this._scale : t
                        }
                        if (arguments[0] instanceof X) {
                            var n = arguments[0];
                            if (this._modelType === e.FLOATING) return null;
                            n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y)
                        }
                    }
                }, {
                    key: "getMaximumSignificantDigits", value: function () {
                        var t = 16;
                        return this._modelType === e.FLOATING ? t = 16 : this._modelType === e.FLOATING_SINGLE ? t = 6 : this._modelType === e.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t
                    }
                }, {
                    key: "setScale", value: function (t) {
                        this._scale = Math.abs(t)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [b, k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = e.FLOATING; else if (1 === arguments.length) if (arguments[0] instanceof oe) {
                            var t = arguments[0];
                            this._modelType = t, t === e.FIXED && this.setScale(1)
                        } else if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            this._modelType = e.FIXED, this.setScale(n)
                        } else if (arguments[0] instanceof e) {
                            var r = arguments[0];
                            this._modelType = r._modelType, this._scale = r._scale
                        }
                    }
                }, {
                    key: "mostPrecise", value: function (t, e) {
                        return t.compareTo(e) >= 0 ? t : e
                    }
                }]), e
            }(), oe = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "readResolve", value: function () {
                        return e.nameToTypeMap.get(this._name)
                    }
                }, {
                    key: "toString", value: function () {
                        return this._name
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._name = null;
                        var t = arguments[0];
                        this._name = t, e.nameToTypeMap.put(t, this)
                    }
                }]), e
            }();
            oe.nameToTypeMap = new re, ie.Type = oe, ie.FIXED = new oe("FIXED"), ie.FLOATING = new oe("FLOATING"), ie.FLOATING_SINGLE = new oe("FLOATING SINGLE"), ie.maximumPreciseValue = 9007199254740992;
            var se = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "copyInternal", value: function () {
                        for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
                        return new s(t, this._factory)
                    }
                }, {
                    key: "equalsExact", value: function () {
                        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
                            var t = arguments[0], e = arguments[1];
                            return !!this.isEquivalentClass(t) && g(o(s.prototype), "equalsExact", this).call(this, t, e)
                        }
                        return g(o(s.prototype), "equalsExact", this).apply(this, arguments)
                    }
                }, {
                    key: "getBoundaryDimension", value: function () {
                        return this.isClosed() ? Mt.FALSE : 0
                    }
                }, {
                    key: "isClosed", value: function () {
                        if (this.isEmpty()) return !1;
                        for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;
                        return !0
                    }
                }, {
                    key: "getTypeCode", value: function () {
                        return V.TYPECODE_MULTILINESTRING
                    }
                }, {
                    key: "getDimension", value: function () {
                        return 1
                    }
                }, {
                    key: "getBoundary", value: function () {
                        throw new J
                    }
                }, {
                    key: "getGeometryType", value: function () {
                        return V.TYPENAME_MULTILINESTRING
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [St]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0], e = arguments[1];
                        Bt.constructor_.call(this, t, e)
                    }
                }]), s
            }(Bt), ae = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "createEmpty", value: function (t) {
                        switch (t) {
                            case-1:
                                return this.createGeometryCollection();
                            case 0:
                                return this.createPoint();
                            case 1:
                                return this.createLineString();
                            case 2:
                                return this.createPolygon();
                            default:
                                throw new x("Invalid dimension: " + t)
                        }
                    }
                }, {
                    key: "toGeometry", value: function (t) {
                        return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new X(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new X(t.getMinX(), t.getMinY()), new X(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new X(t.getMinX(), t.getMinY()), new X(t.getMinX(), t.getMaxY()), new X(t.getMaxX(), t.getMaxY()), new X(t.getMaxX(), t.getMinY()), new X(t.getMinX(), t.getMinY())]), null)
                    }
                }, {
                    key: "createLineString", value: function () {
                        if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof Array) {
                                var t = arguments[0];
                                return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                            }
                            if (ot(arguments[0], ct)) return new Ct(arguments[0], this)
                        }
                    }
                }, {
                    key: "createMultiLineString", value: function () {
                        return 0 === arguments.length ? new se(null, this) : 1 === arguments.length ? new se(arguments[0], this) : void 0
                    }
                }, {
                    key: "buildGeometry", value: function (t) {
                        for (var n = null, r = !1, i = !1, o = t.iterator(); o.hasNext();) {
                            var s = o.next(), a = s.getTypeCode();
                            null === n && (n = a), a !== n && (r = !0), s instanceof Bt && (i = !0)
                        }
                        if (null === n) return this.createGeometryCollection();
                        if (r || i) return this.createGeometryCollection(e.toGeometryArray(t));
                        var u = t.iterator().next();
                        if (t.size() > 1) {
                            if (u instanceof Ft) return this.createMultiPolygon(e.toPolygonArray(t));
                            if (u instanceof Ct) return this.createMultiLineString(e.toLineStringArray(t));
                            if (u instanceof Tt) return this.createMultiPoint(e.toPointArray(t));
                            G.shouldNeverReachHere("Unhandled geometry type: " + u.getGeometryType())
                        }
                        return u
                    }
                }, {
                    key: "createMultiPointFromCoords", value: function (t) {
                        return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                    }
                }, {
                    key: "createPoint", value: function () {
                        if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof X) {
                                var t = arguments[0];
                                return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
                            }
                            if (ot(arguments[0], ct)) return new Tt(arguments[0], this)
                        }
                    }
                }, {
                    key: "getCoordinateSequenceFactory", value: function () {
                        return this._coordinateSequenceFactory
                    }
                }, {
                    key: "createPolygon", value: function () {
                        if (0 === arguments.length) return this.createPolygon(null, null);
                        if (1 === arguments.length) {
                            if (ot(arguments[0], ct)) {
                                var t = arguments[0];
                                return this.createPolygon(this.createLinearRing(t))
                            }
                            if (arguments[0] instanceof Array) {
                                var e = arguments[0];
                                return this.createPolygon(this.createLinearRing(e))
                            }
                            if (arguments[0] instanceof Xt) {
                                var n = arguments[0];
                                return this.createPolygon(n, null)
                            }
                        } else if (2 === arguments.length) return new Ft(arguments[0], arguments[1], this)
                    }
                }, {
                    key: "getSRID", value: function () {
                        return this._SRID
                    }
                }, {
                    key: "createGeometryCollection", value: function () {
                        return 0 === arguments.length ? new Bt(null, this) : 1 === arguments.length ? new Bt(arguments[0], this) : void 0
                    }
                }, {
                    key: "getPrecisionModel", value: function () {
                        return this._precisionModel
                    }
                }, {
                    key: "createLinearRing", value: function () {
                        if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof Array) {
                                var t = arguments[0];
                                return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                            }
                            if (ot(arguments[0], ct)) return new Xt(arguments[0], this)
                        }
                    }
                }, {
                    key: "createMultiPolygon", value: function () {
                        return 0 === arguments.length ? new ee(null, this) : 1 === arguments.length ? new ee(arguments[0], this) : void 0
                    }
                }, {
                    key: "createMultiPoint", value: function () {
                        if (0 === arguments.length) return new zt(null, this);
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof Array) return new zt(arguments[0], this);
                            if (ot(arguments[0], ct)) {
                                var t = arguments[0];
                                if (null === t) return this.createMultiPoint(new Array(0).fill(null));
                                for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {
                                    var r = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures());
                                    Nt.copy(t, n, r, 0, 1), e[n] = this.createPoint(r)
                                }
                                return this.createMultiPoint(e)
                            }
                        }
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) e.constructor_.call(this, new ie, 0); else if (1 === arguments.length) {
                            if (ot(arguments[0], wt)) {
                                var t = arguments[0];
                                e.constructor_.call(this, new ie, 0, t)
                            } else if (arguments[0] instanceof ie) {
                                var n = arguments[0];
                                e.constructor_.call(this, n, 0, e.getDefaultCoordinateSequenceFactory())
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            e.constructor_.call(this, r, i, e.getDefaultCoordinateSequenceFactory())
                        } else if (3 === arguments.length) {
                            var o = arguments[0], s = arguments[1], a = arguments[2];
                            this._precisionModel = o, this._coordinateSequenceFactory = a, this._SRID = s
                        }
                    }
                }, {
                    key: "toMultiPolygonArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "toGeometryArray", value: function (t) {
                        if (null === t) return null;
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "getDefaultCoordinateSequenceFactory", value: function () {
                        return te.instance()
                    }
                }, {
                    key: "toMultiLineStringArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "toLineStringArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "toMultiPointArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "toLinearRingArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "toPointArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "toPolygonArray", value: function (t) {
                        var e = new Array(t.size()).fill(null);
                        return t.toArray(e)
                    }
                }, {
                    key: "createPointFromInternalCoord", value: function (t, e) {
                        return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
                    }
                }]), e
            }(), ue = "XY", le = "XYZ", he = "XYM", ce = "XYZM", fe = {
                POINT: "Point",
                LINE_STRING: "LineString",
                LINEAR_RING: "LinearRing",
                POLYGON: "Polygon",
                MULTI_POINT: "MultiPoint",
                MULTI_LINE_STRING: "MultiLineString",
                MULTI_POLYGON: "MultiPolygon",
                GEOMETRY_COLLECTION: "GeometryCollection",
                CIRCLE: "Circle"
            }, ge = "EMPTY", pe = 1, ve = 2, de = 3, ye = 4, me = 5, _e = 6, xe = {};
            for (var Ee in fe) xe[Ee] = fe[Ee].toUpperCase();
            var ke = function () {
                function e(n) {
                    t(this, e), this.wkt = n, this.index_ = -1
                }

                return r(e, [{
                    key: "isAlpha_", value: function (t) {
                        return t >= "a" && t <= "z" || t >= "A" && t <= "Z"
                    }
                }, {
                    key: "isNumeric_", value: function (t, e) {
                        return t >= "0" && t <= "9" || "." == t && !(void 0 !== e && e)
                    }
                }, {
                    key: "isWhiteSpace_", value: function (t) {
                        return " " == t || "\t" == t || "\r" == t || "\n" == t
                    }
                }, {
                    key: "nextChar_", value: function () {
                        return this.wkt.charAt(++this.index_)
                    }
                }, {
                    key: "nextToken", value: function () {
                        var t, e = this.nextChar_(), n = this.index_, r = e;
                        if ("(" == e) t = ve; else if ("," == e) t = me; else if (")" == e) t = de; else if (this.isNumeric_(e) || "-" == e) t = ye, r = this.readNumber_(); else if (this.isAlpha_(e)) t = pe, r = this.readText_(); else {
                            if (this.isWhiteSpace_(e)) return this.nextToken();
                            if ("" !== e) throw new Error("Unexpected character: " + e);
                            t = _e
                        }
                        return {position: n, value: r, type: t}
                    }
                }, {
                    key: "readNumber_", value: function () {
                        var t, e = this.index_, n = !1, r = !1;
                        do {
                            "." == t ? n = !0 : "e" != t && "E" != t || (r = !0), t = this.nextChar_()
                        } while (this.isNumeric_(t, n) || !r && ("e" == t || "E" == t) || r && ("-" == t || "+" == t));
                        return parseFloat(this.wkt.substring(e, this.index_--))
                    }
                }, {
                    key: "readText_", value: function () {
                        var t, e = this.index_;
                        do {
                            t = this.nextChar_()
                        } while (this.isAlpha_(t));
                        return this.wkt.substring(e, this.index_--).toUpperCase()
                    }
                }]), e
            }(), we = function () {
                function e(n, r) {
                    t(this, e), this.lexer_ = n, this.token_, this.layout_ = ue, this.factory = r
                }

                return r(e, [{
                    key: "consume_", value: function () {
                        this.token_ = this.lexer_.nextToken()
                    }
                }, {
                    key: "isTokenType", value: function (t) {
                        return this.token_.type == t
                    }
                }, {
                    key: "match", value: function (t) {
                        var e = this.isTokenType(t);
                        return e && this.consume_(), e
                    }
                }, {
                    key: "parse", value: function () {
                        return this.consume_(), this.parseGeometry_()
                    }
                }, {
                    key: "parseGeometryLayout_", value: function () {
                        var t = ue, e = this.token_;
                        if (this.isTokenType(pe)) {
                            var n = e.value;
                            "Z" === n ? t = le : "M" === n ? t = he : "ZM" === n && (t = ce), t !== ue && this.consume_()
                        }
                        return t
                    }
                }, {
                    key: "parseGeometryCollectionText_", value: function () {
                        if (this.match(ve)) {
                            var t = [];
                            do {
                                t.push(this.parseGeometry_())
                            } while (this.match(me));
                            if (this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return [];
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parsePointText_", value: function () {
                        if (this.match(ve)) {
                            var t = this.parsePoint_();
                            if (this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return null;
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parseLineStringText_", value: function () {
                        if (this.match(ve)) {
                            var t = this.parsePointList_();
                            if (this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return [];
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parsePolygonText_", value: function () {
                        if (this.match(ve)) {
                            var t = this.parseLineStringTextList_();
                            if (this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return [];
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parseMultiPointText_", value: function () {
                        var t;
                        if (this.match(ve)) {
                            if (t = this.token_.type == ve ? this.parsePointTextList_() : this.parsePointList_(), this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return [];
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parseMultiLineStringText_", value: function () {
                        if (this.match(ve)) {
                            var t = this.parseLineStringTextList_();
                            if (this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return [];
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parseMultiPolygonText_", value: function () {
                        if (this.match(ve)) {
                            var t = this.parsePolygonTextList_();
                            if (this.match(de)) return t
                        } else if (this.isEmptyGeometry_()) return [];
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parsePoint_", value: function () {
                        for (var t = [], e = this.layout_.length, n = 0; n < e; ++n) {
                            var r = this.token_;
                            if (!this.match(ye)) break;
                            t.push(r.value)
                        }
                        if (t.length == e) return t;
                        throw new Error(this.formatErrorMessage_())
                    }
                }, {
                    key: "parsePointList_", value: function () {
                        for (var t = [this.parsePoint_()]; this.match(me);) t.push(this.parsePoint_());
                        return t
                    }
                }, {
                    key: "parsePointTextList_", value: function () {
                        for (var t = [this.parsePointText_()]; this.match(me);) t.push(this.parsePointText_());
                        return t
                    }
                }, {
                    key: "parseLineStringTextList_", value: function () {
                        for (var t = [this.parseLineStringText_()]; this.match(me);) t.push(this.parseLineStringText_());
                        return t
                    }
                }, {
                    key: "parsePolygonTextList_", value: function () {
                        for (var t = [this.parsePolygonText_()]; this.match(me);) t.push(this.parsePolygonText_());
                        return t
                    }
                }, {
                    key: "isEmptyGeometry_", value: function () {
                        var t = this.isTokenType(pe) && this.token_.value == ge;
                        return t && this.consume_(), t
                    }
                }, {
                    key: "formatErrorMessage_", value: function () {
                        return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`"
                    }
                }, {
                    key: "parseGeometry_", value: function () {
                        var t = this.factory, e = function (t) {
                            return u(X, p(t))
                        }, n = function (n) {
                            var r = n.map((function (n) {
                                return t.createLinearRing(n.map(e))
                            }));
                            return r.length > 1 ? t.createPolygon(r[0], r.slice(1)) : t.createPolygon(r[0])
                        }, r = this.token_;
                        if (this.match(pe)) {
                            var i = r.value;
                            if (this.layout_ = this.parseGeometryLayout_(), "GEOMETRYCOLLECTION" == i) {
                                var o = this.parseGeometryCollectionText_();
                                return t.createGeometryCollection(o)
                            }
                            switch (i) {
                                case"POINT":
                                    var s = this.parsePointText_();
                                    return s ? t.createPoint(u(X, p(s))) : t.createPoint();
                                case"LINESTRING":
                                    var a = this.parseLineStringText_().map(e);
                                    return t.createLineString(a);
                                case"LINEARRING":
                                    var l = this.parseLineStringText_().map(e);
                                    return t.createLinearRing(l);
                                case"POLYGON":
                                    var h = this.parsePolygonText_();
                                    return h && 0 !== h.length ? n(h) : t.createPolygon();
                                case"MULTIPOINT":
                                    var c = this.parseMultiPointText_();
                                    if (!c || 0 === c.length) return t.createMultiPoint();
                                    var f = c.map(e).map((function (e) {
                                        return t.createPoint(e)
                                    }));
                                    return t.createMultiPoint(f);
                                case"MULTILINESTRING":
                                    var g = this.parseMultiLineStringText_().map((function (n) {
                                        return t.createLineString(n.map(e))
                                    }));
                                    return t.createMultiLineString(g);
                                case"MULTIPOLYGON":
                                    var v = this.parseMultiPolygonText_();
                                    if (!v || 0 === v.length) return t.createMultiPolygon();
                                    var d = v.map(n);
                                    return t.createMultiPolygon(d);
                                default:
                                    throw new Error("Invalid geometry type: " + i)
                            }
                        }
                        throw new Error(this.formatErrorMessage_())
                    }
                }]), e
            }();

            function be(t) {
                if (t.isEmpty()) return "";
                var e = t.getCoordinate(), n = [e.x, e.y];
                return void 0 === e.z || Number.isNaN(e.z) || n.push(e.z), void 0 === e.m || Number.isNaN(e.m) || n.push(e.m), n.join(" ")
            }

            function Ie(t) {
                for (var e = t.getCoordinates().map((function (t) {
                    var e = [t.x, t.y];
                    return void 0 === t.z || Number.isNaN(t.z) || e.push(t.z), void 0 === t.m || Number.isNaN(t.m) || e.push(t.m), e
                })), n = [], r = 0, i = e.length; r < i; ++r) n.push(e[r].join(" "));
                return n.join(", ")
            }

            function Se(t) {
                var e = [];
                e.push("(" + Ie(t.getExteriorRing()) + ")");
                for (var n = 0, r = t.getNumInteriorRing(); n < r; ++n) e.push("(" + Ie(t.getInteriorRingN(n)) + ")");
                return e.join(", ")
            }

            var Ne = {
                Point: be, LineString: Ie, LinearRing: Ie, Polygon: Se, MultiPoint: function (t) {
                    for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push("(" + be(t.getGeometryN(n)) + ")");
                    return e.join(", ")
                }, MultiLineString: function (t) {
                    for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push("(" + Ie(t.getGeometryN(n)) + ")");
                    return e.join(", ")
                }, MultiPolygon: function (t) {
                    for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push("(" + Se(t.getGeometryN(n)) + ")");
                    return e.join(", ")
                }, GeometryCollection: function (t) {
                    for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push(Me(t.getGeometryN(n)));
                    return e.join(", ")
                }
            };

            function Me(t) {
                var e = t.getGeometryType(), n = Ne[e];
                e = e.toUpperCase();
                var r = function (t) {
                    var e = "";
                    if (t.isEmpty()) return e;
                    var n = t.getCoordinate();
                    return void 0 === n.z || Number.isNaN(n.z) || (e += "Z"), void 0 === n.m || Number.isNaN(n.m) || (e += "M"), e
                }(t);
                return r.length > 0 && (e += " " + r), t.isEmpty() ? e + " " + ge : e + " (" + n(t) + ")"
            }

            var Pe = function () {
                function e(n) {
                    t(this, e), this.geometryFactory = n || new ae, this.precisionModel = this.geometryFactory.getPrecisionModel()
                }

                return r(e, [{
                    key: "read", value: function (t) {
                        var e = new ke(t);
                        return new we(e, this.geometryFactory).parse()
                    }
                }, {
                    key: "write", value: function (t) {
                        return Me(t)
                    }
                }]), e
            }(), Le = function () {
                function e(n) {
                    t(this, e), this.parser = new Pe(n)
                }

                return r(e, [{
                    key: "write", value: function (t) {
                        return this.parser.write(t)
                    }
                }], [{
                    key: "toLineString", value: function (t, e) {
                        if (2 !== arguments.length) throw new Error("Not implemented");
                        return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
                    }
                }]), e
            }(), Ce = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getIndexAlongSegment", value: function (t, e) {
                        return this.computeIntLineIndex(), this._intLineIndex[t][e]
                    }
                }, {
                    key: "getTopologySummary", value: function () {
                        var t = new Kt;
                        return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString()
                    }
                }, {
                    key: "computeIntersection", value: function (t, e, n, r) {
                        this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = r, this._result = this.computeIntersect(t, e, n, r)
                    }
                }, {
                    key: "getIntersectionNum", value: function () {
                        return this._result
                    }
                }, {
                    key: "computeIntLineIndex", value: function () {
                        if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map((function () {
                            return Array(2)
                        })), this.computeIntLineIndex(0), this.computeIntLineIndex(1)); else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0)
                        }
                    }
                }, {
                    key: "isProper", value: function () {
                        return this.hasIntersection() && this._isProper
                    }
                }, {
                    key: "setPrecisionModel", value: function (t) {
                        this._precisionModel = t
                    }
                }, {
                    key: "isInteriorIntersection", value: function () {
                        if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;
                            return !1
                        }
                    }
                }, {
                    key: "getIntersection", value: function (t) {
                        return this._intPt[t]
                    }
                }, {
                    key: "isEndPoint", value: function () {
                        return this.hasIntersection() && !this._isProper
                    }
                }, {
                    key: "hasIntersection", value: function () {
                        return this._result !== e.NO_INTERSECTION
                    }
                }, {
                    key: "getEdgeDistance", value: function (t, n) {
                        return e.computeEdgeDistance(this._intPt[n], this._inputLines[t][0], this._inputLines[t][1])
                    }
                }, {
                    key: "isCollinear", value: function () {
                        return this._result === e.COLLINEAR_INTERSECTION
                    }
                }, {
                    key: "toString", value: function () {
                        return Le.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Le.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
                    }
                }, {
                    key: "getEndpoint", value: function (t, e) {
                        return this._inputLines[t][e]
                    }
                }, {
                    key: "isIntersection", value: function (t) {
                        for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;
                        return !1
                    }
                }, {
                    key: "getIntersectionAlongSegment", value: function (t, e) {
                        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._result = null, this._inputLines = Array(2).fill().map((function () {
                            return Array(2)
                        })), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new X, this._intPt[1] = new X, this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0
                    }
                }, {
                    key: "computeEdgeDistance", value: function (t, e, n) {
                        var r = Math.abs(n.x - e.x), i = Math.abs(n.y - e.y), o = -1;
                        if (t.equals(e)) o = 0; else if (t.equals(n)) o = r > i ? r : i; else {
                            var s = Math.abs(t.x - e.x), a = Math.abs(t.y - e.y);
                            0 !== (o = r > i ? s : a) || t.equals(e) || (o = Math.max(s, a))
                        }
                        return G.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o
                    }
                }, {
                    key: "nonRobustComputeEdgeDistance", value: function (t, e, n) {
                        var r = t.x - e.x, i = t.y - e.y, o = Math.sqrt(r * r + i * i);
                        return G.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o
                    }
                }]), e
            }();
            Ce.DONT_INTERSECT = 0, Ce.DO_INTERSECT = 1, Ce.COLLINEAR = 2, Ce.NO_INTERSECTION = 0, Ce.POINT_INTERSECTION = 1, Ce.COLLINEAR_INTERSECTION = 2;
            var Re = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    return t(this, s), n.call(this)
                }

                return r(s, [{
                    key: "isInSegmentEnvelopes", value: function (t) {
                        var e = new U(this._inputLines[0][0], this._inputLines[0][1]),
                            n = new U(this._inputLines[1][0], this._inputLines[1][1]);
                        return e.contains(t) && n.contains(t)
                    }
                }, {
                    key: "computeIntersection", value: function () {
                        if (3 !== arguments.length) return g(o(s.prototype), "computeIntersection", this).apply(this, arguments);
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        if (this._isProper = !1, U.intersects(e, n, t) && 0 === ft.index(e, n, t) && 0 === ft.index(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = Ce.POINT_INTERSECTION, null;
                        this._result = Ce.NO_INTERSECTION
                    }
                }, {
                    key: "intersection", value: function (t, e, n, r) {
                        var i = this.intersectionSafe(t, e, n, r);
                        return this.isInSegmentEnvelopes(i) || (i = new X(s.nearestEndpoint(t, e, n, r))), null !== this._precisionModel && this._precisionModel.makePrecise(i), i
                    }
                }, {
                    key: "checkDD", value: function (t, e, n, r, i) {
                        var o = ht.intersection(t, e, n, r), s = this.isInSegmentEnvelopes(o);
                        xt.out.println("DD in env = " + s + "  --------------------- " + o), i.distance(o) > 1e-4 && xt.out.println("Distance = " + i.distance(o))
                    }
                }, {
                    key: "intersectionSafe", value: function (t, e, n, r) {
                        var i = _t.intersection(t, e, n, r);
                        return null === i && (i = s.nearestEndpoint(t, e, n, r)), i
                    }
                }, {
                    key: "computeCollinearIntersection", value: function (t, e, n, r) {
                        var i = U.intersects(t, e, n), o = U.intersects(t, e, r), s = U.intersects(n, r, t),
                            a = U.intersects(n, r, e);
                        return i && o ? (this._intPt[0] = n, this._intPt[1] = r, Ce.COLLINEAR_INTERSECTION) : s && a ? (this._intPt[0] = t, this._intPt[1] = e, Ce.COLLINEAR_INTERSECTION) : i && s ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || o || a ? Ce.COLLINEAR_INTERSECTION : Ce.POINT_INTERSECTION) : i && a ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || o || s ? Ce.COLLINEAR_INTERSECTION : Ce.POINT_INTERSECTION) : o && s ? (this._intPt[0] = r, this._intPt[1] = t, !r.equals(t) || i || a ? Ce.COLLINEAR_INTERSECTION : Ce.POINT_INTERSECTION) : o && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || i || s ? Ce.COLLINEAR_INTERSECTION : Ce.POINT_INTERSECTION) : Ce.NO_INTERSECTION
                    }
                }, {
                    key: "computeIntersect", value: function (t, e, n, r) {
                        if (this._isProper = !1, !U.intersects(t, e, n, r)) return Ce.NO_INTERSECTION;
                        var i = ft.index(t, e, n), o = ft.index(t, e, r);
                        if (i > 0 && o > 0 || i < 0 && o < 0) return Ce.NO_INTERSECTION;
                        var s = ft.index(n, r, t), a = ft.index(n, r, e);
                        return s > 0 && a > 0 || s < 0 && a < 0 ? Ce.NO_INTERSECTION : 0 === i && 0 === o && 0 === s && 0 === a ? this.computeCollinearIntersection(t, e, n, r) : (0 === i || 0 === o || 0 === s || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(r) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(r) ? this._intPt[0] = e : 0 === i ? this._intPt[0] = new X(n) : 0 === o ? this._intPt[0] = new X(r) : 0 === s ? this._intPt[0] = new X(t) : 0 === a && (this._intPt[0] = new X(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, r)), Ce.POINT_INTERSECTION)
                    }
                }], [{
                    key: "nearestEndpoint", value: function (t, e, n, r) {
                        var i = t, o = kt.pointToSegment(t, n, r), s = kt.pointToSegment(e, n, r);
                        return s < o && (o = s, i = e), (s = kt.pointToSegment(n, t, e)) < o && (o = s, i = n), (s = kt.pointToSegment(r, t, e)) < o && (o = s, i = r), i
                    }
                }]), s
            }(Ce), Te = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "countSegment", value: function (t, e) {
                        if (t.x < this._p.x && e.x < this._p.x) return null;
                        if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;
                        if (t.y === this._p.y && e.y === this._p.y) {
                            var n = t.x, r = e.x;
                            return n > r && (n = e.x, r = t.x), this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0), null
                        }
                        if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
                            var i = ft.index(t, e, this._p);
                            if (i === ft.COLLINEAR) return this._isPointOnSegment = !0, null;
                            e.y < t.y && (i = -i), i === ft.LEFT && this._crossingCount++
                        }
                    }
                }, {
                    key: "isPointInPolygon", value: function () {
                        return this.getLocation() !== Z.EXTERIOR
                    }
                }, {
                    key: "getLocation", value: function () {
                        return this._isPointOnSegment ? Z.BOUNDARY : this._crossingCount % 2 == 1 ? Z.INTERIOR : Z.EXTERIOR
                    }
                }, {
                    key: "isOnSegment", value: function () {
                        return this._isPointOnSegment
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
                        var t = arguments[0];
                        this._p = t
                    }
                }, {
                    key: "locatePointInRing", value: function () {
                        if (arguments[0] instanceof X && ot(arguments[1], ct)) {
                            for (var t = arguments[1], n = new e(arguments[0]), r = new X, i = new X, o = 1; o < t.size(); o++) if (t.getCoordinate(o, r), t.getCoordinate(o - 1, i), n.countSegment(r, i), n.isOnSegment()) return n.getLocation();
                            return n.getLocation()
                        }
                        if (arguments[0] instanceof X && arguments[1] instanceof Array) {
                            for (var s = arguments[1], a = new e(arguments[0]), u = 1; u < s.length; u++) {
                                var l = s[u], h = s[u - 1];
                                if (a.countSegment(l, h), a.isOnSegment()) return a.getLocation()
                            }
                            return a.getLocation()
                        }
                    }
                }]), e
            }(), Oe = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "isOnLine", value: function () {
                        if (arguments[0] instanceof X && ot(arguments[1], ct)) {
                            for (var t = arguments[0], e = arguments[1], n = new Re, r = new X, i = new X, o = e.size(), s = 1; s < o; s++) if (e.getCoordinate(s - 1, r), e.getCoordinate(s, i), n.computeIntersection(t, r, i), n.hasIntersection()) return !0;
                            return !1
                        }
                        if (arguments[0] instanceof X && arguments[1] instanceof Array) {
                            for (var a = arguments[0], u = arguments[1], l = new Re, h = 1; h < u.length; h++) {
                                var c = u[h - 1], f = u[h];
                                if (l.computeIntersection(a, c, f), l.hasIntersection()) return !0
                            }
                            return !1
                        }
                    }
                }, {
                    key: "locateInRing", value: function (t, e) {
                        return Te.locatePointInRing(t, e)
                    }
                }, {
                    key: "isInRing", value: function (t, n) {
                        return e.locateInRing(t, n) !== Z.EXTERIOR
                    }
                }]), e
            }(), Ae = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "setAllLocations", value: function (t) {
                        for (var e = 0; e < this.location.length; e++) this.location[e] = t
                    }
                }, {
                    key: "isNull", value: function () {
                        for (var t = 0; t < this.location.length; t++) if (this.location[t] !== Z.NONE) return !1;
                        return !0
                    }
                }, {
                    key: "setAllLocationsIfNull", value: function (t) {
                        for (var e = 0; e < this.location.length; e++) this.location[e] === Z.NONE && (this.location[e] = t)
                    }
                }, {
                    key: "isLine", value: function () {
                        return 1 === this.location.length
                    }
                }, {
                    key: "merge", value: function (t) {
                        if (t.location.length > this.location.length) {
                            var e = new Array(3).fill(null);
                            e[tt.ON] = this.location[tt.ON], e[tt.LEFT] = Z.NONE, e[tt.RIGHT] = Z.NONE, this.location = e
                        }
                        for (var n = 0; n < this.location.length; n++) this.location[n] === Z.NONE && n < t.location.length && (this.location[n] = t.location[n])
                    }
                }, {
                    key: "getLocations", value: function () {
                        return this.location
                    }
                }, {
                    key: "flip", value: function () {
                        if (this.location.length <= 1) return null;
                        var t = this.location[tt.LEFT];
                        this.location[tt.LEFT] = this.location[tt.RIGHT], this.location[tt.RIGHT] = t
                    }
                }, {
                    key: "toString", value: function () {
                        var t = new st;
                        return this.location.length > 1 && t.append(Z.toLocationSymbol(this.location[tt.LEFT])), t.append(Z.toLocationSymbol(this.location[tt.ON])), this.location.length > 1 && t.append(Z.toLocationSymbol(this.location[tt.RIGHT])), t.toString()
                    }
                }, {
                    key: "setLocations", value: function (t, e, n) {
                        this.location[tt.ON] = t, this.location[tt.LEFT] = e, this.location[tt.RIGHT] = n
                    }
                }, {
                    key: "get", value: function (t) {
                        return t < this.location.length ? this.location[t] : Z.NONE
                    }
                }, {
                    key: "isArea", value: function () {
                        return this.location.length > 1
                    }
                }, {
                    key: "isAnyNull", value: function () {
                        for (var t = 0; t < this.location.length; t++) if (this.location[t] === Z.NONE) return !0;
                        return !1
                    }
                }, {
                    key: "setLocation", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setLocation(tt.ON, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            this.location[e] = n
                        }
                    }
                }, {
                    key: "init", value: function (t) {
                        this.location = new Array(t).fill(null), this.setAllLocations(Z.NONE)
                    }
                }, {
                    key: "isEqualOnSide", value: function (t, e) {
                        return this.location[e] === t.location[e]
                    }
                }, {
                    key: "allPositionsEqual", value: function (t) {
                        for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;
                        return !0
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this.location = null, 1 === arguments.length) {
                            if (arguments[0] instanceof Array) {
                                var t = arguments[0];
                                this.init(t.length)
                            } else if (Number.isInteger(arguments[0])) {
                                var n = arguments[0];
                                this.init(1), this.location[tt.ON] = n
                            } else if (arguments[0] instanceof e) {
                                var r = arguments[0];
                                if (this.init(r.location.length), null !== r) for (var i = 0; i < this.location.length; i++) this.location[i] = r.location[i]
                            }
                        } else if (3 === arguments.length) {
                            var o = arguments[0], s = arguments[1], a = arguments[2];
                            this.init(3), this.location[tt.ON] = o, this.location[tt.LEFT] = s, this.location[tt.RIGHT] = a
                        }
                    }
                }]), e
            }(), De = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getGeometryCount", value: function () {
                        var t = 0;
                        return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
                    }
                }, {
                    key: "setAllLocations", value: function (t, e) {
                        this.elt[t].setAllLocations(e)
                    }
                }, {
                    key: "isNull", value: function (t) {
                        return this.elt[t].isNull()
                    }
                }, {
                    key: "setAllLocationsIfNull", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            this.elt[e].setAllLocationsIfNull(n)
                        }
                    }
                }, {
                    key: "isLine", value: function (t) {
                        return this.elt[t].isLine()
                    }
                }, {
                    key: "merge", value: function (t) {
                        for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Ae(t.elt[e]) : this.elt[e].merge(t.elt[e])
                    }
                }, {
                    key: "flip", value: function () {
                        this.elt[0].flip(), this.elt[1].flip()
                    }
                }, {
                    key: "getLocation", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.elt[t].get(tt.ON)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            return this.elt[e].get(n)
                        }
                    }
                }, {
                    key: "toString", value: function () {
                        var t = new st;
                        return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString()
                    }
                }, {
                    key: "isArea", value: function () {
                        if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.elt[t].isArea()
                        }
                    }
                }, {
                    key: "isAnyNull", value: function (t) {
                        return this.elt[t].isAnyNull()
                    }
                }, {
                    key: "setLocation", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            this.elt[t].setLocation(tt.ON, e)
                        } else if (3 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2];
                            this.elt[n].setLocation(r, i)
                        }
                    }
                }, {
                    key: "isEqualOnSide", value: function (t, e) {
                        return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
                    }
                }, {
                    key: "allPositionsEqual", value: function (t, e) {
                        return this.elt[t].allPositionsEqual(e)
                    }
                }, {
                    key: "toLine", value: function (t) {
                        this.elt[t].isArea() && (this.elt[t] = new Ae(this.elt[t].location[0]))
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
                            if (Number.isInteger(arguments[0])) {
                                var t = arguments[0];
                                this.elt[0] = new Ae(t), this.elt[1] = new Ae(t)
                            } else if (arguments[0] instanceof e) {
                                var n = arguments[0];
                                this.elt[0] = new Ae(n.elt[0]), this.elt[1] = new Ae(n.elt[1])
                            }
                        } else if (2 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            this.elt[0] = new Ae(Z.NONE), this.elt[1] = new Ae(Z.NONE), this.elt[r].setLocation(i)
                        } else if (3 === arguments.length) {
                            var o = arguments[0], s = arguments[1], a = arguments[2];
                            this.elt[0] = new Ae(o, s, a), this.elt[1] = new Ae(o, s, a)
                        } else if (4 === arguments.length) {
                            var u = arguments[0], l = arguments[1], h = arguments[2], c = arguments[3];
                            this.elt[0] = new Ae(Z.NONE, Z.NONE, Z.NONE), this.elt[1] = new Ae(Z.NONE, Z.NONE, Z.NONE), this.elt[u].setLocations(l, h, c)
                        }
                    }
                }, {
                    key: "toLineLabel", value: function (t) {
                        for (var n = new e(Z.NONE), r = 0; r < 2; r++) n.setLocation(r, t.getLocation(r));
                        return n
                    }
                }]), e
            }(), Fe = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "computeRing", value: function () {
                        if (null !== this._ring) return null;
                        for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);
                        this._ring = this._geometryFactory.createLinearRing(t), this._isHole = ft.isCCW(this._ring.getCoordinates())
                    }
                }, {
                    key: "isIsolated", value: function () {
                        return 1 === this._label.getGeometryCount()
                    }
                }, {
                    key: "computePoints", value: function (t) {
                        this._startDe = t;
                        var e = t, n = !0;
                        do {
                            if (null === e) throw new pt("Found null DirectedEdge");
                            if (e.getEdgeRing() === this) throw new pt("Directed Edge visited twice during ring-building at " + e.getCoordinate());
                            this._edges.add(e);
                            var r = e.getLabel();
                            G.isTrue(r.isArea()), this.mergeLabel(r), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e)
                        } while (e !== this._startDe)
                    }
                }, {
                    key: "getLinearRing", value: function () {
                        return this._ring
                    }
                }, {
                    key: "getCoordinate", value: function (t) {
                        return this._pts.get(t)
                    }
                }, {
                    key: "computeMaxNodeDegree", value: function () {
                        this._maxNodeDegree = 0;
                        var t = this._startDe;
                        do {
                            var e = t.getNode().getEdges().getOutgoingDegree(this);
                            e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t)
                        } while (t !== this._startDe);
                        this._maxNodeDegree *= 2
                    }
                }, {
                    key: "addPoints", value: function (t, e, n) {
                        var r = t.getCoordinates();
                        if (e) {
                            var i = 1;
                            n && (i = 0);
                            for (var o = i; o < r.length; o++) this._pts.add(r[o])
                        } else {
                            var s = r.length - 2;
                            n && (s = r.length - 1);
                            for (var a = s; a >= 0; a--) this._pts.add(r[a])
                        }
                    }
                }, {
                    key: "isHole", value: function () {
                        return this._isHole
                    }
                }, {
                    key: "setInResult", value: function () {
                        var t = this._startDe;
                        do {
                            t.getEdge().setInResult(!0), t = t.getNext()
                        } while (t !== this._startDe)
                    }
                }, {
                    key: "containsPoint", value: function (t) {
                        var e = this.getLinearRing();
                        if (!e.getEnvelopeInternal().contains(t)) return !1;
                        if (!Oe.isInRing(t, e.getCoordinates())) return !1;
                        for (var n = this._holes.iterator(); n.hasNext();) if (n.next().containsPoint(t)) return !1;
                        return !0
                    }
                }, {
                    key: "addHole", value: function (t) {
                        this._holes.add(t)
                    }
                }, {
                    key: "isShell", value: function () {
                        return null === this._shell
                    }
                }, {
                    key: "getLabel", value: function () {
                        return this._label
                    }
                }, {
                    key: "getEdges", value: function () {
                        return this._edges
                    }
                }, {
                    key: "getMaxNodeDegree", value: function () {
                        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree
                    }
                }, {
                    key: "getShell", value: function () {
                        return this._shell
                    }
                }, {
                    key: "mergeLabel", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.mergeLabel(t, 0), this.mergeLabel(t, 1)
                        } else if (2 === arguments.length) {
                            var e = arguments[1], n = arguments[0].getLocation(e, tt.RIGHT);
                            if (n === Z.NONE) return null;
                            if (this._label.getLocation(e) === Z.NONE) return this._label.setLocation(e, n), null
                        }
                    }
                }, {
                    key: "setShell", value: function (t) {
                        this._shell = t, null !== t && t.addHole(this)
                    }
                }, {
                    key: "toPolygon", value: function (t) {
                        for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();
                        return t.createPolygon(this.getLinearRing(), e)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new dt, this._pts = new dt, this._label = new De(Z.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new dt, this._geometryFactory = null, 0 === arguments.length) ; else if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            this._geometryFactory = e, this.computePoints(t), this.computeRing()
                        }
                    }
                }]), e
            }(), qe = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "setEdgeRing", value: function (t, e) {
                        t.setMinEdgeRing(e)
                    }
                }, {
                    key: "getNext", value: function (t) {
                        return t.getNextMin()
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0], e = arguments[1];
                        Fe.constructor_.call(this, t, e)
                    }
                }]), o
            }(Fe), Ge = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "buildMinimalRings", value: function () {
                        var t = new dt, e = this._startDe;
                        do {
                            if (null === e.getMinEdgeRing()) {
                                var n = new qe(e, this._geometryFactory);
                                t.add(n)
                            }
                            e = e.getNext()
                        } while (e !== this._startDe);
                        return t
                    }
                }, {
                    key: "setEdgeRing", value: function (t, e) {
                        t.setEdgeRing(e)
                    }
                }, {
                    key: "linkDirectedEdgesForMinimalEdgeRings", value: function () {
                        var t = this._startDe;
                        do {
                            t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext()
                        } while (t !== this._startDe)
                    }
                }, {
                    key: "getNext", value: function (t) {
                        return t.getNext()
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0], e = arguments[1];
                        Fe.constructor_.call(this, t, e)
                    }
                }]), o
            }(Fe), Ye = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "setVisited", value: function (t) {
                        this._isVisited = t
                    }
                }, {
                    key: "setInResult", value: function (t) {
                        this._isInResult = t
                    }
                }, {
                    key: "isCovered", value: function () {
                        return this._isCovered
                    }
                }, {
                    key: "isCoveredSet", value: function () {
                        return this._isCoveredSet
                    }
                }, {
                    key: "setLabel", value: function (t) {
                        this._label = t
                    }
                }, {
                    key: "getLabel", value: function () {
                        return this._label
                    }
                }, {
                    key: "setCovered", value: function (t) {
                        this._isCovered = t, this._isCoveredSet = !0
                    }
                }, {
                    key: "updateIM", value: function (t) {
                        G.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t)
                    }
                }, {
                    key: "isInResult", value: function () {
                        return this._isInResult
                    }
                }, {
                    key: "isVisited", value: function () {
                        return this._isVisited
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ; else if (1 === arguments.length) {
                            var t = arguments[0];
                            this._label = t
                        }
                    }
                }]), e
            }(), Be = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "isIncidentEdgeInResult", value: function () {
                        for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) if (t.next().getEdge().isInResult()) return !0;
                        return !1
                    }
                }, {
                    key: "isIsolated", value: function () {
                        return 1 === this._label.getGeometryCount()
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this._coord
                    }
                }, {
                    key: "print", value: function (t) {
                        t.println("node " + this._coord + " lbl: " + this._label)
                    }
                }, {
                    key: "computeIM", value: function (t) {
                    }
                }, {
                    key: "computeMergedLocation", value: function (t, e) {
                        var n = Z.NONE;
                        if (n = this._label.getLocation(e), !t.isNull(e)) {
                            var r = t.getLocation(e);
                            n !== Z.BOUNDARY && (n = r)
                        }
                        return n
                    }
                }, {
                    key: "setLabel", value: function () {
                        if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return g(o(s.prototype), "setLabel", this).apply(this, arguments);
                        var t = arguments[0], e = arguments[1];
                        null === this._label ? this._label = new De(t, e) : this._label.setLocation(t, e)
                    }
                }, {
                    key: "getEdges", value: function () {
                        return this._edges
                    }
                }, {
                    key: "mergeLabel", value: function () {
                        if (arguments[0] instanceof s) {
                            var t = arguments[0];
                            this.mergeLabel(t._label)
                        } else if (arguments[0] instanceof De) for (var e = arguments[0], n = 0; n < 2; n++) {
                            var r = this.computeMergedLocation(e, n);
                            this._label.getLocation(n) === Z.NONE && this._label.setLocation(n, r)
                        }
                    }
                }, {
                    key: "add", value: function (t) {
                        this._edges.insert(t), t.setNode(this)
                    }
                }, {
                    key: "setLabelBoundary", value: function (t) {
                        if (null === this._label) return null;
                        var e = Z.NONE;
                        null !== this._label && (e = this._label.getLocation(t));
                        var n = null;
                        switch (e) {
                            case Z.BOUNDARY:
                                n = Z.INTERIOR;
                                break;
                            case Z.INTERIOR:
                            default:
                                n = Z.BOUNDARY
                        }
                        this._label.setLocation(t, n)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._coord = null, this._edges = null;
                        var t = arguments[0], e = arguments[1];
                        this._coord = t, this._edges = e, this._label = new De(0, Z.NONE)
                    }
                }]), s
            }(Ye), ze = function (e) {
                i(r, e);
                var n = f(r);

                function r() {
                    return t(this, r), n.apply(this, arguments)
                }

                return r
            }(ne);

            function Xe(t) {
                return null == t ? 0 : t.color
            }

            function je(t) {
                return null == t ? null : t.parent
            }

            function Ue(t, e) {
                null !== t && (t.color = e)
            }

            function Ve(t) {
                return null == t ? null : t.left
            }

            function Ze(t) {
                return null == t ? null : t.right
            }

            var He = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), (e = n.call(this)).root_ = null, e.size_ = 0, e
                }

                return r(o, [{
                    key: "get", value: function (t) {
                        for (var e = this.root_; null !== e;) {
                            var n = t.compareTo(e.key);
                            if (n < 0) e = e.left; else {
                                if (!(n > 0)) return e.value;
                                e = e.right
                            }
                        }
                        return null
                    }
                }, {
                    key: "put", value: function (t, e) {
                        if (null === this.root_) return this.root_ = {
                            key: t,
                            value: e,
                            left: null,
                            right: null,
                            parent: null,
                            color: 0,
                            getValue: function () {
                                return this.value
                            },
                            getKey: function () {
                                return this.key
                            }
                        }, this.size_ = 1, null;
                        var n, r, i = this.root_;
                        do {
                            if (n = i, (r = t.compareTo(i.key)) < 0) i = i.left; else {
                                if (!(r > 0)) {
                                    var o = i.value;
                                    return i.value = e, o
                                }
                                i = i.right
                            }
                        } while (null !== i);
                        var s = {
                            key: t, left: null, right: null, value: e, parent: n, color: 0, getValue: function () {
                                return this.value
                            }, getKey: function () {
                                return this.key
                            }
                        };
                        return r < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null
                    }
                }, {
                    key: "fixAfterInsertion", value: function (t) {
                        var e;
                        for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) je(t) === Ve(je(je(t))) ? 1 === Xe(e = Ze(je(je(t)))) ? (Ue(je(t), 0), Ue(e, 0), Ue(je(je(t)), 1), t = je(je(t))) : (t === Ze(je(t)) && (t = je(t), this.rotateLeft(t)), Ue(je(t), 0), Ue(je(je(t)), 1), this.rotateRight(je(je(t)))) : 1 === Xe(e = Ve(je(je(t)))) ? (Ue(je(t), 0), Ue(e, 0), Ue(je(je(t)), 1), t = je(je(t))) : (t === Ve(je(t)) && (t = je(t), this.rotateRight(t)), Ue(je(t), 0), Ue(je(je(t)), 1), this.rotateLeft(je(je(t))));
                        this.root_.color = 0
                    }
                }, {
                    key: "values", value: function () {
                        var t = new dt, e = this.getFirstEntry();
                        if (null !== e) for (t.add(e.value); null !== (e = o.successor(e));) t.add(e.value);
                        return t
                    }
                }, {
                    key: "entrySet", value: function () {
                        var t = new K, e = this.getFirstEntry();
                        if (null !== e) for (t.add(e); null !== (e = o.successor(e));) t.add(e);
                        return t
                    }
                }, {
                    key: "rotateLeft", value: function (t) {
                        if (null != t) {
                            var e = t.right;
                            t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e
                        }
                    }
                }, {
                    key: "rotateRight", value: function (t) {
                        if (null != t) {
                            var e = t.left;
                            t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e
                        }
                    }
                }, {
                    key: "getFirstEntry", value: function () {
                        var t = this.root_;
                        if (null != t) for (; null != t.left;) t = t.left;
                        return t
                    }
                }, {
                    key: "size", value: function () {
                        return this.size_
                    }
                }, {
                    key: "containsKey", value: function (t) {
                        for (var e = this.root_; null !== e;) {
                            var n = t.compareTo(e.key);
                            if (n < 0) e = e.left; else {
                                if (!(n > 0)) return !0;
                                e = e.right
                            }
                        }
                        return !1
                    }
                }], [{
                    key: "successor", value: function (t) {
                        var e;
                        if (null === t) return null;
                        if (null !== t.right) {
                            for (e = t.right; null !== e.left;) e = e.left;
                            return e
                        }
                        e = t.parent;
                        for (var n = t; null !== e && n === e.right;) n = e, e = e.parent;
                        return e
                    }
                }]), o
            }(ze), We = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "find", value: function (t) {
                        return this.nodeMap.get(t)
                    }
                }, {
                    key: "addNode", value: function () {
                        if (arguments[0] instanceof X) {
                            var t = arguments[0], e = this.nodeMap.get(t);
                            return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
                        }
                        if (arguments[0] instanceof Be) {
                            var n = arguments[0], r = this.nodeMap.get(n.getCoordinate());
                            return null === r ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r)
                        }
                    }
                }, {
                    key: "print", value: function (t) {
                        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                    }
                }, {
                    key: "iterator", value: function () {
                        return this.nodeMap.values().iterator()
                    }
                }, {
                    key: "values", value: function () {
                        return this.nodeMap.values()
                    }
                }, {
                    key: "getBoundaryNodes", value: function (t) {
                        for (var e = new dt, n = this.iterator(); n.hasNext();) {
                            var r = n.next();
                            r.getLabel().getLocation(t) === Z.BOUNDARY && e.add(r)
                        }
                        return e
                    }
                }, {
                    key: "add", value: function (t) {
                        var e = t.getCoordinate();
                        this.addNode(e).add(t)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this.nodeMap = new He, this.nodeFact = null;
                        var t = arguments[0];
                        this.nodeFact = t
                    }
                }]), e
            }(), Je = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "isNorthern", value: function (t) {
                        return t === e.NE || t === e.NW
                    }
                }, {
                    key: "isOpposite", value: function (t, e) {
                        return t !== e && 2 == (t - e + 4) % 4
                    }
                }, {
                    key: "commonHalfPlane", value: function (t, e) {
                        if (t === e) return t;
                        if (2 == (t - e + 4) % 4) return -1;
                        var n = t < e ? t : e;
                        return 0 === n && 3 === (t > e ? t : e) ? 3 : n
                    }
                }, {
                    key: "isInHalfPlane", value: function (t, n) {
                        return n === e.SE ? t === e.SE || t === e.SW : t === n || t === n + 1
                    }
                }, {
                    key: "quadrant", value: function () {
                        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var t = arguments[0], n = arguments[1];
                            if (0 === t && 0 === n) throw new x("Cannot compute the quadrant for point ( " + t + ", " + n + " )");
                            return t >= 0 ? n >= 0 ? e.NE : e.SE : n >= 0 ? e.NW : e.SW
                        }
                        if (arguments[0] instanceof X && arguments[1] instanceof X) {
                            var r = arguments[0], i = arguments[1];
                            if (i.x === r.x && i.y === r.y) throw new x("Cannot compute the quadrant for two identical points " + r);
                            return i.x >= r.x ? i.y >= r.y ? e.NE : e.SE : i.y >= r.y ? e.NW : e.SW
                        }
                    }
                }]), e
            }();
            Je.NE = 0, Je.NW = 1, Je.SW = 2, Je.SE = 3;
            var Qe = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "compareDirection", value: function (t) {
                        return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : ft.index(t._p0, t._p1, this._p1)
                    }
                }, {
                    key: "getDy", value: function () {
                        return this._dy
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this._p0
                    }
                }, {
                    key: "setNode", value: function (t) {
                        this._node = t
                    }
                }, {
                    key: "print", value: function (t) {
                        var e = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), r = n.lastIndexOf("."),
                            i = n.substring(r + 1);
                        t.print("  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label)
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this.compareDirection(e)
                    }
                }, {
                    key: "getDirectedCoordinate", value: function () {
                        return this._p1
                    }
                }, {
                    key: "getDx", value: function () {
                        return this._dx
                    }
                }, {
                    key: "getLabel", value: function () {
                        return this._label
                    }
                }, {
                    key: "getEdge", value: function () {
                        return this._edge
                    }
                }, {
                    key: "getQuadrant", value: function () {
                        return this._quadrant
                    }
                }, {
                    key: "getNode", value: function () {
                        return this._node
                    }
                }, {
                    key: "toString", value: function () {
                        var t = Math.atan2(this._dy, this._dx), e = this.getClass().getName(), n = e.lastIndexOf(".");
                        return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label
                    }
                }, {
                    key: "computeLabel", value: function (t) {
                    }
                }, {
                    key: "init", value: function (t, e) {
                        this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Je.quadrant(this._dx, this._dy), G.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found")
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
                            var t = arguments[0];
                            this._edge = t
                        } else if (3 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2];
                            e.constructor_.call(this, n, r, i, null)
                        } else if (4 === arguments.length) {
                            var o = arguments[0], s = arguments[1], a = arguments[2], u = arguments[3];
                            e.constructor_.call(this, o), this.init(s, a), this._label = u
                        }
                    }
                }]), e
            }(), Ke = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "getNextMin", value: function () {
                        return this._nextMin
                    }
                }, {
                    key: "getDepth", value: function (t) {
                        return this._depth[t]
                    }
                }, {
                    key: "setVisited", value: function (t) {
                        this._isVisited = t
                    }
                }, {
                    key: "computeDirectedLabel", value: function () {
                        this._label = new De(this._edge.getLabel()), this._isForward || this._label.flip()
                    }
                }, {
                    key: "getNext", value: function () {
                        return this._next
                    }
                }, {
                    key: "setDepth", value: function (t, e) {
                        if (-999 !== this._depth[t] && this._depth[t] !== e) throw new pt("assigned depths do not match", this.getCoordinate());
                        this._depth[t] = e
                    }
                }, {
                    key: "isInteriorAreaEdge", value: function () {
                        for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, tt.LEFT) === Z.INTERIOR && this._label.getLocation(e, tt.RIGHT) === Z.INTERIOR || (t = !1);
                        return t
                    }
                }, {
                    key: "setNextMin", value: function (t) {
                        this._nextMin = t
                    }
                }, {
                    key: "print", value: function (t) {
                        g(o(s.prototype), "print", this).call(this, t), t.print(" " + this._depth[tt.LEFT] + "/" + this._depth[tt.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult")
                    }
                }, {
                    key: "setMinEdgeRing", value: function (t) {
                        this._minEdgeRing = t
                    }
                }, {
                    key: "isLineEdge", value: function () {
                        var t = this._label.isLine(0) || this._label.isLine(1),
                            e = !this._label.isArea(0) || this._label.allPositionsEqual(0, Z.EXTERIOR),
                            n = !this._label.isArea(1) || this._label.allPositionsEqual(1, Z.EXTERIOR);
                        return t && e && n
                    }
                }, {
                    key: "setEdgeRing", value: function (t) {
                        this._edgeRing = t
                    }
                }, {
                    key: "getMinEdgeRing", value: function () {
                        return this._minEdgeRing
                    }
                }, {
                    key: "getDepthDelta", value: function () {
                        var t = this._edge.getDepthDelta();
                        return this._isForward || (t = -t), t
                    }
                }, {
                    key: "setInResult", value: function (t) {
                        this._isInResult = t
                    }
                }, {
                    key: "getSym", value: function () {
                        return this._sym
                    }
                }, {
                    key: "isForward", value: function () {
                        return this._isForward
                    }
                }, {
                    key: "getEdge", value: function () {
                        return this._edge
                    }
                }, {
                    key: "printEdge", value: function (t) {
                        this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t)
                    }
                }, {
                    key: "setSym", value: function (t) {
                        this._sym = t
                    }
                }, {
                    key: "setVisitedEdge", value: function (t) {
                        this.setVisited(t), this._sym.setVisited(t)
                    }
                }, {
                    key: "setEdgeDepths", value: function (t, e) {
                        var n = this.getEdge().getDepthDelta();
                        this._isForward || (n = -n);
                        var r = 1;
                        t === tt.LEFT && (r = -1);
                        var i = tt.opposite(t), o = e + n * r;
                        this.setDepth(t, e), this.setDepth(i, o)
                    }
                }, {
                    key: "getEdgeRing", value: function () {
                        return this._edgeRing
                    }
                }, {
                    key: "isInResult", value: function () {
                        return this._isInResult
                    }
                }, {
                    key: "setNext", value: function (t) {
                        this._next = t
                    }
                }, {
                    key: "isVisited", value: function () {
                        return this._isVisited
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
                        var t = arguments[0], e = arguments[1];
                        if (Qe.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1)); else {
                            var n = t.getNumPoints() - 1;
                            this.init(t.getCoordinate(n), t.getCoordinate(n - 1))
                        }
                        this.computeDirectedLabel()
                    }
                }, {
                    key: "depthFactor", value: function (t, e) {
                        return t === Z.EXTERIOR && e === Z.INTERIOR ? 1 : t === Z.INTERIOR && e === Z.EXTERIOR ? -1 : 0
                    }
                }]), s
            }(Qe), $e = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "createNode", value: function (t) {
                        return new Be(t, null)
                    }
                }]), e
            }(), tn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "printEdges", value: function (t) {
                        t.println("Edges:");
                        for (var e = 0; e < this._edges.size(); e++) {
                            t.println("edge " + e + ":");
                            var n = this._edges.get(e);
                            n.print(t), n.eiList.print(t)
                        }
                    }
                }, {
                    key: "find", value: function (t) {
                        return this._nodes.find(t)
                    }
                }, {
                    key: "addNode", value: function () {
                        if (arguments[0] instanceof Be) {
                            var t = arguments[0];
                            return this._nodes.addNode(t)
                        }
                        if (arguments[0] instanceof X) {
                            var e = arguments[0];
                            return this._nodes.addNode(e)
                        }
                    }
                }, {
                    key: "getNodeIterator", value: function () {
                        return this._nodes.iterator()
                    }
                }, {
                    key: "linkResultDirectedEdges", value: function () {
                        for (var t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkResultDirectedEdges()
                    }
                }, {
                    key: "debugPrintln", value: function (t) {
                        xt.out.println(t)
                    }
                }, {
                    key: "isBoundaryNode", value: function (t, e) {
                        var n = this._nodes.find(e);
                        if (null === n) return !1;
                        var r = n.getLabel();
                        return null !== r && r.getLocation(t) === Z.BOUNDARY
                    }
                }, {
                    key: "linkAllDirectedEdges", value: function () {
                        for (var t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkAllDirectedEdges()
                    }
                }, {
                    key: "matchInSameDirection", value: function (t, e, n, r) {
                        return !!t.equals(n) && ft.index(t, e, r) === ft.COLLINEAR && Je.quadrant(t, e) === Je.quadrant(n, r)
                    }
                }, {
                    key: "getEdgeEnds", value: function () {
                        return this._edgeEndList
                    }
                }, {
                    key: "debugPrint", value: function (t) {
                        xt.out.print(t)
                    }
                }, {
                    key: "getEdgeIterator", value: function () {
                        return this._edges.iterator()
                    }
                }, {
                    key: "findEdgeInSameDirection", value: function (t, e) {
                        for (var n = 0; n < this._edges.size(); n++) {
                            var r = this._edges.get(n), i = r.getCoordinates();
                            if (this.matchInSameDirection(t, e, i[0], i[1])) return r;
                            if (this.matchInSameDirection(t, e, i[i.length - 1], i[i.length - 2])) return r
                        }
                        return null
                    }
                }, {
                    key: "insertEdge", value: function (t) {
                        this._edges.add(t)
                    }
                }, {
                    key: "findEdgeEnd", value: function (t) {
                        for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
                            var n = e.next();
                            if (n.getEdge() === t) return n
                        }
                        return null
                    }
                }, {
                    key: "addEdges", value: function (t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var n = e.next();
                            this._edges.add(n);
                            var r = new Ke(n, !0), i = new Ke(n, !1);
                            r.setSym(i), i.setSym(r), this.add(r), this.add(i)
                        }
                    }
                }, {
                    key: "add", value: function (t) {
                        this._nodes.add(t), this._edgeEndList.add(t)
                    }
                }, {
                    key: "getNodes", value: function () {
                        return this._nodes.values()
                    }
                }, {
                    key: "findEdge", value: function (t, e) {
                        for (var n = 0; n < this._edges.size(); n++) {
                            var r = this._edges.get(n), i = r.getCoordinates();
                            if (t.equals(i[0]) && e.equals(i[1])) return r
                        }
                        return null
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._edges = new dt, this._nodes = null, this._edgeEndList = new dt, 0 === arguments.length) this._nodes = new We(new $e); else if (1 === arguments.length) {
                            var t = arguments[0];
                            this._nodes = new We(t)
                        }
                    }
                }, {
                    key: "linkResultDirectedEdges", value: function (t) {
                        for (var e = t.iterator(); e.hasNext();) e.next().getEdges().linkResultDirectedEdges()
                    }
                }]), e
            }(), en = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "sortShellsAndHoles", value: function (t, e, n) {
                        for (var r = t.iterator(); r.hasNext();) {
                            var i = r.next();
                            i.isHole() ? n.add(i) : e.add(i)
                        }
                    }
                }, {
                    key: "computePolygons", value: function (t) {
                        for (var e = new dt, n = t.iterator(); n.hasNext();) {
                            var r = n.next().toPolygon(this._geometryFactory);
                            e.add(r)
                        }
                        return e
                    }
                }, {
                    key: "placeFreeHoles", value: function (t, n) {
                        for (var r = n.iterator(); r.hasNext();) {
                            var i = r.next();
                            if (null === i.getShell()) {
                                var o = e.findEdgeRingContaining(i, t);
                                if (null === o) throw new pt("unable to assign hole to a shell", i.getCoordinate(0));
                                i.setShell(o)
                            }
                        }
                    }
                }, {
                    key: "buildMinimalEdgeRings", value: function (t, e, n) {
                        for (var r = new dt, i = t.iterator(); i.hasNext();) {
                            var o = i.next();
                            if (o.getMaxNodeDegree() > 2) {
                                o.linkDirectedEdgesForMinimalEdgeRings();
                                var s = o.buildMinimalRings(), a = this.findShell(s);
                                null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s)
                            } else r.add(o)
                        }
                        return r
                    }
                }, {
                    key: "buildMaximalEdgeRings", value: function (t) {
                        for (var e = new dt, n = t.iterator(); n.hasNext();) {
                            var r = n.next();
                            if (r.isInResult() && r.getLabel().isArea() && null === r.getEdgeRing()) {
                                var i = new Ge(r, this._geometryFactory);
                                e.add(i), i.setInResult()
                            }
                        }
                        return e
                    }
                }, {
                    key: "placePolygonHoles", value: function (t, e) {
                        for (var n = e.iterator(); n.hasNext();) {
                            var r = n.next();
                            r.isHole() && r.setShell(t)
                        }
                    }
                }, {
                    key: "getPolygons", value: function () {
                        return this.computePolygons(this._shellList)
                    }
                }, {
                    key: "findShell", value: function (t) {
                        for (var e = 0, n = null, r = t.iterator(); r.hasNext();) {
                            var i = r.next();
                            i.isHole() || (n = i, e++)
                        }
                        return G.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n
                    }
                }, {
                    key: "add", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.add(t.getEdgeEnds(), t.getNodes())
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            tn.linkResultDirectedEdges(n);
                            var r = this.buildMaximalEdgeRings(e), i = new dt,
                                o = this.buildMinimalEdgeRings(r, this._shellList, i);
                            this.sortShellsAndHoles(o, this._shellList, i), this.placeFreeHoles(this._shellList, i)
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._geometryFactory = null, this._shellList = new dt;
                        var t = arguments[0];
                        this._geometryFactory = t
                    }
                }, {
                    key: "findEdgeRingContaining", value: function (t, e) {
                        for (var n = t.getLinearRing(), r = n.getEnvelopeInternal(), i = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
                            var u = a.next(), l = u.getLinearRing(), h = l.getEnvelopeInternal();
                            if (!h.equals(r) && h.contains(r)) {
                                i = Wt.ptNotInList(n.getCoordinates(), l.getCoordinates());
                                var c = !1;
                                Oe.isInRing(i, l.getCoordinates()) && (c = !0), c && (null === o || s.contains(h)) && (s = (o = u).getLinearRing().getEnvelopeInternal())
                            }
                        }
                        return o
                    }
                }]), e
            }(), nn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "getBounds", value: function () {
                    }
                }]), e
            }(), rn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getItem", value: function () {
                        return this._item
                    }
                }, {
                    key: "getBounds", value: function () {
                        return this._bounds
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [nn, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._bounds = null, this._item = null;
                        var t = arguments[0], e = arguments[1];
                        this._bounds = t, this._item = e
                    }
                }]), e
            }(), on = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "poll", value: function () {
                        if (this.isEmpty()) return null;
                        var t = this._items.get(1);
                        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t
                    }
                }, {
                    key: "size", value: function () {
                        return this._size
                    }
                }, {
                    key: "reorder", value: function (t) {
                        for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));
                        this._items.set(t, n)
                    }
                }, {
                    key: "clear", value: function () {
                        this._size = 0, this._items.clear()
                    }
                }, {
                    key: "peek", value: function () {
                        return this.isEmpty() ? null : this._items.get(1)
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return 0 === this._size
                    }
                }, {
                    key: "add", value: function (t) {
                        this._items.add(null), this._size += 1;
                        var e = this._size;
                        for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));
                        this._items.set(e, t)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._size = null, this._items = null, this._size = 0, this._items = new dt, this._items.add(null)
                    }
                }]), e
            }(), sn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "insert", value: function (t, e) {
                    }
                }, {
                    key: "remove", value: function (t, e) {
                    }
                }, {
                    key: "query", value: function () {
                    }
                }]), e
            }(), an = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getLevel", value: function () {
                        return this._level
                    }
                }, {
                    key: "size", value: function () {
                        return this._childBoundables.size()
                    }
                }, {
                    key: "getChildBoundables", value: function () {
                        return this._childBoundables
                    }
                }, {
                    key: "addChildBoundable", value: function (t) {
                        G.isTrue(null === this._bounds), this._childBoundables.add(t)
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return this._childBoundables.isEmpty()
                    }
                }, {
                    key: "getBounds", value: function () {
                        return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [nn, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._childBoundables = new dt, this._bounds = null, this._level = null, 0 === arguments.length) ; else if (1 === arguments.length) {
                            var t = arguments[0];
                            this._level = t
                        }
                    }
                }]), e
            }(), un = {
                reverseOrder: function () {
                    return {
                        compare: function (t, e) {
                            return e.compareTo(t)
                        }
                    }
                }, min: function (t) {
                    return un.sort(t), t.get(0)
                }, sort: function (t, e) {
                    var n = t.toArray();
                    e ? At.sort(n, e) : At.sort(n);
                    for (var r = t.iterator(), i = 0, o = n.length; i < o; i++) r.next(), r.set(n[i])
                }, singletonList: function (t) {
                    var e = new dt;
                    return e.add(t), e
                }
            }, ln = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "maxDistance", value: function (t, n, r, i, o, s, a, u) {
                        var l = e.distance(t, n, o, s);
                        return l = Math.max(l, e.distance(t, n, a, u)), l = Math.max(l, e.distance(r, i, o, s)), Math.max(l, e.distance(r, i, a, u))
                    }
                }, {
                    key: "distance", value: function (t, e, n, r) {
                        var i = n - t, o = r - e;
                        return Math.sqrt(i * i + o * o)
                    }
                }, {
                    key: "maximumDistance", value: function (t, n) {
                        var r = Math.min(t.getMinX(), n.getMinX()), i = Math.min(t.getMinY(), n.getMinY()),
                            o = Math.max(t.getMaxX(), n.getMaxX()), s = Math.max(t.getMaxY(), n.getMaxY());
                        return e.distance(r, i, o, s)
                    }
                }, {
                    key: "minMaxDistance", value: function (t, n) {
                        var r = t.getMinX(), i = t.getMinY(), o = t.getMaxX(), s = t.getMaxY(), a = n.getMinX(),
                            u = n.getMinY(), l = n.getMaxX(), h = n.getMaxY(),
                            c = e.maxDistance(r, i, r, s, a, u, a, h);
                        return c = Math.min(c, e.maxDistance(r, i, r, s, a, u, l, u)), c = Math.min(c, e.maxDistance(r, i, r, s, l, h, a, h)), c = Math.min(c, e.maxDistance(r, i, r, s, l, h, l, u)), c = Math.min(c, e.maxDistance(r, i, o, i, a, u, a, h)), c = Math.min(c, e.maxDistance(r, i, o, i, a, u, l, u)), c = Math.min(c, e.maxDistance(r, i, o, i, l, h, a, h)), c = Math.min(c, e.maxDistance(r, i, o, i, l, h, l, u)), c = Math.min(c, e.maxDistance(o, s, r, s, a, u, a, h)), c = Math.min(c, e.maxDistance(o, s, r, s, a, u, l, u)), c = Math.min(c, e.maxDistance(o, s, r, s, l, h, a, h)), c = Math.min(c, e.maxDistance(o, s, r, s, l, h, l, u)), c = Math.min(c, e.maxDistance(o, s, o, i, a, u, a, h)), c = Math.min(c, e.maxDistance(o, s, o, i, a, u, l, u)), c = Math.min(c, e.maxDistance(o, s, o, i, l, h, a, h)), Math.min(c, e.maxDistance(o, s, o, i, l, h, l, u))
                    }
                }]), e
            }(), hn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "maximumDistance", value: function () {
                        return ln.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds())
                    }
                }, {
                    key: "expandToQueue", value: function (t, n) {
                        var r = e.isComposite(this._boundable1), i = e.isComposite(this._boundable2);
                        if (r && i) return e.area(this._boundable1) > e.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, t, n), null) : (this.expand(this._boundable2, this._boundable1, !0, t, n), null);
                        if (r) return this.expand(this._boundable1, this._boundable2, !1, t, n), null;
                        if (i) return this.expand(this._boundable2, this._boundable1, !0, t, n), null;
                        throw new x("neither boundable is composite")
                    }
                }, {
                    key: "isLeaves", value: function () {
                        return !(e.isComposite(this._boundable1) || e.isComposite(this._boundable2))
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
                    }
                }, {
                    key: "expand", value: function (t, n, r, i, o) {
                        for (var s = t.getChildBoundables().iterator(); s.hasNext();) {
                            var a = s.next(), u = null;
                            (u = r ? new e(n, a, this._itemDistance) : new e(a, n, this._itemDistance)).getDistance() < o && i.add(u)
                        }
                    }
                }, {
                    key: "getBoundable", value: function (t) {
                        return 0 === t ? this._boundable1 : this._boundable2
                    }
                }, {
                    key: "getDistance", value: function () {
                        return this._distance
                    }
                }, {
                    key: "distance", value: function () {
                        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds())
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance()
                    }
                }, {
                    key: "area", value: function (t) {
                        return t.getBounds().getArea()
                    }
                }, {
                    key: "isComposite", value: function (t) {
                        return t instanceof an
                    }
                }]), e
            }(), cn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "visitItem", value: function (t) {
                    }
                }]), e
            }(), fn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "queryInternal", value: function () {
                        if (ot(arguments[2], cn) && arguments[0] instanceof Object && arguments[1] instanceof an) for (var t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(), r = 0; r < n.size(); r++) {
                            var i = n.get(r);
                            this.getIntersectsOp().intersects(i.getBounds(), t) && (i instanceof an ? this.queryInternal(t, i, e) : i instanceof rn ? e.visitItem(i.getItem()) : G.shouldNeverReachHere())
                        } else if (ot(arguments[2], rt) && arguments[0] instanceof Object && arguments[1] instanceof an) for (var o = arguments[0], s = arguments[2], a = arguments[1].getChildBoundables(), u = 0; u < a.size(); u++) {
                            var l = a.get(u);
                            this.getIntersectsOp().intersects(l.getBounds(), o) && (l instanceof an ? this.queryInternal(o, l, s) : l instanceof rn ? s.add(l.getItem()) : G.shouldNeverReachHere())
                        }
                    }
                }, {
                    key: "getNodeCapacity", value: function () {
                        return this._nodeCapacity
                    }
                }, {
                    key: "lastNode", value: function (t) {
                        return t.get(t.size() - 1)
                    }
                }, {
                    key: "size", value: function () {
                        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
                        if (1 === arguments.length) {
                            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
                                var n = e.next();
                                n instanceof an ? t += this.size(n) : n instanceof rn && (t += 1)
                            }
                            return t
                        }
                    }
                }, {
                    key: "removeItem", value: function (t, e) {
                        for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext();) {
                            var i = r.next();
                            i instanceof rn && i.getItem() === e && (n = i)
                        }
                        return null !== n && (t.getChildBoundables().remove(n), !0)
                    }
                }, {
                    key: "itemsTree", value: function () {
                        if (0 === arguments.length) {
                            this.build();
                            var t = this.itemsTree(this._root);
                            return null === t ? new dt : t
                        }
                        if (1 === arguments.length) {
                            for (var e = arguments[0], n = new dt, r = e.getChildBoundables().iterator(); r.hasNext();) {
                                var i = r.next();
                                if (i instanceof an) {
                                    var o = this.itemsTree(i);
                                    null !== o && n.add(o)
                                } else i instanceof rn ? n.add(i.getItem()) : G.shouldNeverReachHere()
                            }
                            return n.size() <= 0 ? null : n
                        }
                    }
                }, {
                    key: "insert", value: function (t, e) {
                        G.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new rn(t, e))
                    }
                }, {
                    key: "boundablesAtLevel", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0], e = new dt;
                            return this.boundablesAtLevel(t, this._root, e), e
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2];
                            if (G.isTrue(n > -2), r.getLevel() === n) return i.add(r), null;
                            for (var o = r.getChildBoundables().iterator(); o.hasNext();) {
                                var s = o.next();
                                s instanceof an ? this.boundablesAtLevel(n, s, i) : (G.isTrue(s instanceof rn), -1 === n && i.add(s))
                            }
                            return null
                        }
                    }
                }, {
                    key: "query", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.build();
                            var e = new dt;
                            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e), e
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            if (this.build(), this.isEmpty()) return null;
                            this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.queryInternal(n, this._root, r)
                        }
                    }
                }, {
                    key: "build", value: function () {
                        if (this._built) return null;
                        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0
                    }
                }, {
                    key: "getRoot", value: function () {
                        return this.build(), this._root
                    }
                }, {
                    key: "remove", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e)
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2], o = this.removeItem(r, i);
                            if (o) return !0;
                            for (var s = null, a = r.getChildBoundables().iterator(); a.hasNext();) {
                                var u = a.next();
                                if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof an && (o = this.remove(n, u, i))) {
                                    s = u;
                                    break
                                }
                            }
                            return null !== s && s.getChildBoundables().isEmpty() && r.getChildBoundables().remove(s), o
                        }
                    }
                }, {
                    key: "createHigherLevels", value: function (t, e) {
                        G.isTrue(!t.isEmpty());
                        var n = this.createParentBoundables(t, e + 1);
                        return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1)
                    }
                }, {
                    key: "depth", value: function () {
                        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
                        if (1 === arguments.length) {
                            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
                                var n = e.next();
                                if (n instanceof an) {
                                    var r = this.depth(n);
                                    r > t && (t = r)
                                }
                            }
                            return t + 1
                        }
                    }
                }, {
                    key: "createParentBoundables", value: function (t, e) {
                        G.isTrue(!t.isEmpty());
                        var n = new dt;
                        n.add(this.createNode(e));
                        var r = new dt(t);
                        un.sort(r, this.getComparator());
                        for (var i = r.iterator(); i.hasNext();) {
                            var o = i.next();
                            this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o)
                        }
                        return n
                    }
                }, {
                    key: "isEmpty", value: function () {
                        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty()
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._root = null, this._built = !1, this._itemBoundables = new dt, this._nodeCapacity = null, 0 === arguments.length) e.constructor_.call(this, e.DEFAULT_NODE_CAPACITY); else if (1 === arguments.length) {
                            var t = arguments[0];
                            G.isTrue(t > 1, "Node capacity must be greater than 1"), this._nodeCapacity = t
                        }
                    }
                }, {
                    key: "compareDoubles", value: function (t, e) {
                        return t > e ? 1 : t < e ? -1 : 0
                    }
                }]), e
            }();
            fn.IntersectsOp = function () {
            }, fn.DEFAULT_NODE_CAPACITY = 10;
            var gn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "distance", value: function (t, e) {
                    }
                }]), e
            }(), pn = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "createParentBoundablesFromVerticalSlices", value: function (t, e) {
                        G.isTrue(t.length > 0);
                        for (var n = new dt, r = 0; r < t.length; r++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e));
                        return n
                    }
                }, {
                    key: "nearestNeighbourK", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            return this.nearestNeighbourK(t, A.POSITIVE_INFINITY, e)
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0], r = arguments[2], i = arguments[1], o = new on;
                            o.add(n);
                            for (var a = new on; !o.isEmpty() && i >= 0;) {
                                var u = o.poll(), l = u.getDistance();
                                if (l >= i) break;
                                u.isLeaves() ? a.size() < r ? a.add(u) : (a.peek().getDistance() > l && (a.poll(), a.add(u)), i = a.peek().getDistance()) : u.expandToQueue(o, i)
                            }
                            return s.getItems(a)
                        }
                    }
                }, {
                    key: "createNode", value: function (t) {
                        return new vn(t)
                    }
                }, {
                    key: "size", value: function () {
                        return 0 === arguments.length ? g(o(s.prototype), "size", this).call(this) : g(o(s.prototype), "size", this).apply(this, arguments)
                    }
                }, {
                    key: "insert", value: function () {
                        if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U)) return g(o(s.prototype), "insert", this).apply(this, arguments);
                        var t = arguments[0], e = arguments[1];
                        if (t.isNull()) return null;
                        g(o(s.prototype), "insert", this).call(this, t, e)
                    }
                }, {
                    key: "getIntersectsOp", value: function () {
                        return s.intersectsOp
                    }
                }, {
                    key: "verticalSlices", value: function (t, e) {
                        for (var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0; o < e; o++) {
                            r[o] = new dt;
                            for (var s = 0; i.hasNext() && s < n;) {
                                var a = i.next();
                                r[o].add(a), s++
                            }
                        }
                        return r
                    }
                }, {
                    key: "query", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return g(o(s.prototype), "query", this).call(this, t)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            g(o(s.prototype), "query", this).call(this, e, n)
                        }
                    }
                }, {
                    key: "getComparator", value: function () {
                        return s.yComparator
                    }
                }, {
                    key: "createParentBoundablesFromVerticalSlice", value: function (t, e) {
                        return g(o(s.prototype), "createParentBoundables", this).call(this, t, e)
                    }
                }, {
                    key: "remove", value: function () {
                        if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) {
                            var t = arguments[0], e = arguments[1];
                            return g(o(s.prototype), "remove", this).call(this, t, e)
                        }
                        return g(o(s.prototype), "remove", this).apply(this, arguments)
                    }
                }, {
                    key: "depth", value: function () {
                        return 0 === arguments.length ? g(o(s.prototype), "depth", this).call(this) : g(o(s.prototype), "depth", this).apply(this, arguments)
                    }
                }, {
                    key: "createParentBoundables", value: function (t, e) {
                        G.isTrue(!t.isEmpty());
                        var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())), r = new dt(t);
                        un.sort(r, s.xComparator);
                        var i = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n))));
                        return this.createParentBoundablesFromVerticalSlices(i, e)
                    }
                }, {
                    key: "nearestNeighbour", value: function () {
                        if (1 === arguments.length) {
                            if (ot(arguments[0], gn)) {
                                var t = arguments[0];
                                if (this.isEmpty()) return null;
                                var e = new hn(this.getRoot(), this.getRoot(), t);
                                return this.nearestNeighbour(e)
                            }
                            if (arguments[0] instanceof hn) {
                                var n = arguments[0], r = A.POSITIVE_INFINITY, i = null, o = new on;
                                for (o.add(n); !o.isEmpty() && r > 0;) {
                                    var s = o.poll(), a = s.getDistance();
                                    if (a >= r) break;
                                    s.isLeaves() ? (r = a, i = s) : s.expandToQueue(o, r)
                                }
                                return null === i ? null : [i.getBoundable(0).getItem(), i.getBoundable(1).getItem()]
                            }
                        } else {
                            if (2 === arguments.length) {
                                var u = arguments[0], l = arguments[1];
                                if (this.isEmpty() || u.isEmpty()) return null;
                                var h = new hn(this.getRoot(), u.getRoot(), l);
                                return this.nearestNeighbour(h)
                            }
                            if (3 === arguments.length) {
                                var c = arguments[2], f = new rn(arguments[0], arguments[1]),
                                    g = new hn(this.getRoot(), f, c);
                                return this.nearestNeighbour(g)[0]
                            }
                            if (4 === arguments.length) {
                                var p = arguments[2], v = arguments[3], d = new rn(arguments[0], arguments[1]),
                                    y = new hn(this.getRoot(), d, p);
                                return this.nearestNeighbourK(y, v)
                            }
                        }
                    }
                }, {
                    key: "isWithinDistance", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1], n = A.POSITIVE_INFINITY, r = new on;
                            for (r.add(t); !r.isEmpty();) {
                                var i = r.poll(), o = i.getDistance();
                                if (o > e) return !1;
                                if (i.maximumDistance() <= e) return !0;
                                if (i.isLeaves()) {
                                    if ((n = o) <= e) return !0
                                } else i.expandToQueue(r, n)
                            }
                            return !1
                        }
                        if (3 === arguments.length) {
                            var s = arguments[0], a = arguments[1], u = arguments[2],
                                l = new hn(this.getRoot(), s.getRoot(), a);
                            return this.isWithinDistance(l, u)
                        }
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [sn, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (0 === arguments.length) s.constructor_.call(this, s.DEFAULT_NODE_CAPACITY); else if (1 === arguments.length) {
                            var t = arguments[0];
                            fn.constructor_.call(this, t)
                        }
                    }
                }, {
                    key: "centreX", value: function (t) {
                        return s.avg(t.getMinX(), t.getMaxX())
                    }
                }, {
                    key: "avg", value: function (t, e) {
                        return (t + e) / 2
                    }
                }, {
                    key: "getItems", value: function (t) {
                        for (var e = new Array(t.size()).fill(null), n = 0; !t.isEmpty();) {
                            var r = t.poll();
                            e[n] = r.getBoundable(0).getItem(), n++
                        }
                        return e
                    }
                }, {
                    key: "centreY", value: function (t) {
                        return s.avg(t.getMinY(), t.getMaxY())
                    }
                }]), s
            }(fn), vn = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "computeBounds", value: function () {
                        for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
                            var n = e.next();
                            null === t ? t = new U(n.getBounds()) : t.expandToInclude(n.getBounds())
                        }
                        return t
                    }
                }], [{
                    key: "constructor_", value: function () {
                        var t = arguments[0];
                        an.constructor_.call(this, t)
                    }
                }]), o
            }(an);
            pn.STRtreeNode = vn, pn.xComparator = new (function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "interfaces_", get: function () {
                        return [D]
                    }
                }, {
                    key: "compare", value: function (t, e) {
                        return fn.compareDoubles(pn.centreX(t.getBounds()), pn.centreX(e.getBounds()))
                    }
                }]), e
            }()), pn.yComparator = new (function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "interfaces_", get: function () {
                        return [D]
                    }
                }, {
                    key: "compare", value: function (t, e) {
                        return fn.compareDoubles(pn.centreY(t.getBounds()), pn.centreY(e.getBounds()))
                    }
                }]), e
            }()), pn.intersectsOp = new (function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "interfaces_", get: function () {
                        return [IntersectsOp]
                    }
                }, {
                    key: "intersects", value: function (t, e) {
                        return t.intersects(e)
                    }
                }]), e
            }()), pn.DEFAULT_NODE_CAPACITY = 10;
            var dn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "relativeSign", value: function (t, e) {
                        return t < e ? -1 : t > e ? 1 : 0
                    }
                }, {
                    key: "compare", value: function (t, n, r) {
                        if (n.equals2D(r)) return 0;
                        var i = e.relativeSign(n.x, r.x), o = e.relativeSign(n.y, r.y);
                        switch (t) {
                            case 0:
                                return e.compareValue(i, o);
                            case 1:
                                return e.compareValue(o, i);
                            case 2:
                                return e.compareValue(o, -i);
                            case 3:
                                return e.compareValue(-i, o);
                            case 4:
                                return e.compareValue(-i, -o);
                            case 5:
                                return e.compareValue(-o, -i);
                            case 6:
                                return e.compareValue(-o, i);
                            case 7:
                                return e.compareValue(i, -o)
                        }
                        return G.shouldNeverReachHere("invalid octant value"), 0
                    }
                }, {
                    key: "compareValue", value: function (t, e) {
                        return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0
                    }
                }]), e
            }(), yn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getCoordinate", value: function () {
                        return this.coord
                    }
                }, {
                    key: "print", value: function (t) {
                        t.print(this.coord), t.print(" seg # = " + this.segmentIndex)
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? dn.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1
                    }
                }, {
                    key: "isEndPoint", value: function (t) {
                        return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t
                    }
                }, {
                    key: "toString", value: function () {
                        return this.segmentIndex + ":" + this.coord.toString()
                    }
                }, {
                    key: "isInterior", value: function () {
                        return this._isInterior
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
                        this._segString = t, this.coord = new X(e), this.segmentIndex = n, this._segmentOctant = r, this._isInterior = !e.equals2D(t.getCoordinate(n))
                    }
                }]), e
            }(), mn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "hasNext", value: function () {
                    }
                }, {
                    key: "next", value: function () {
                    }
                }, {
                    key: "remove", value: function () {
                    }
                }]), e
            }(), _n = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getSplitCoordinates", value: function () {
                        var t = new Ht;
                        this.addEndpoints();
                        for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                            var r = e.next();
                            this.addEdgeCoordinates(n, r, t), n = r
                        }
                        return t.toCoordinateArray()
                    }
                }, {
                    key: "addCollapsedNodes", value: function () {
                        var t = new dt;
                        this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
                        for (var e = t.iterator(); e.hasNext();) {
                            var n = e.next().intValue();
                            this.add(this._edge.getCoordinate(n), n)
                        }
                    }
                }, {
                    key: "createSplitEdgePts", value: function (t, e) {
                        var n = e.segmentIndex - t.segmentIndex + 2;
                        if (2 === n) return [new X(t.coord), new X(e.coord)];
                        var r = this._edge.getCoordinate(e.segmentIndex), i = e.isInterior() || !e.coord.equals2D(r);
                        i || n--;
                        var o = new Array(n).fill(null), s = 0;
                        o[s++] = new X(t.coord);
                        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this._edge.getCoordinate(a);
                        return i && (o[s] = new X(e.coord)), o
                    }
                }, {
                    key: "print", value: function (t) {
                        t.println("Intersections:");
                        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                    }
                }, {
                    key: "findCollapsesFromExistingVertices", value: function (t) {
                        for (var e = 0; e < this._edge.size() - 2; e++) {
                            var n = this._edge.getCoordinate(e);
                            this._edge.getCoordinate(e + 1);
                            var r = this._edge.getCoordinate(e + 2);
                            n.equals2D(r) && t.add(at.valueOf(e + 1))
                        }
                    }
                }, {
                    key: "addEdgeCoordinates", value: function (t, e, n) {
                        var r = this.createSplitEdgePts(t, e);
                        n.add(r, !1)
                    }
                }, {
                    key: "iterator", value: function () {
                        return this._nodeMap.values().iterator()
                    }
                }, {
                    key: "addSplitEdges", value: function (t) {
                        this.addEndpoints(), this.addCollapsedNodes();
                        for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                            var r = e.next(), i = this.createSplitEdge(n, r);
                            t.add(i), n = r
                        }
                    }
                }, {
                    key: "findCollapseIndex", value: function (t, e, n) {
                        if (!t.coord.equals2D(e.coord)) return !1;
                        var r = e.segmentIndex - t.segmentIndex;
                        return e.isInterior() || r--, 1 === r && (n[0] = t.segmentIndex + 1, !0)
                    }
                }, {
                    key: "findCollapsesFromInsertedNodes", value: function (t) {
                        for (var e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext();) {
                            var i = n.next();
                            this.findCollapseIndex(r, i, e) && t.add(at.valueOf(e[0])), r = i
                        }
                    }
                }, {
                    key: "getEdge", value: function () {
                        return this._edge
                    }
                }, {
                    key: "addEndpoints", value: function () {
                        var t = this._edge.size() - 1;
                        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t)
                    }
                }, {
                    key: "createSplitEdge", value: function (t, e) {
                        var n = this.createSplitEdgePts(t, e);
                        return new wn(n, this._edge.getData())
                    }
                }, {
                    key: "add", value: function (t, e) {
                        var n = new yn(this._edge, t, e, this._edge.getSegmentOctant(e)), r = this._nodeMap.get(n);
                        return null !== r ? (G.isTrue(r.coord.equals2D(t), "Found equal nodes with different coordinates"), r) : (this._nodeMap.put(n, n), n)
                    }
                }, {
                    key: "checkSplitEdgesCorrectness", value: function (t) {
                        var e = this._edge.getCoordinates(), n = t.get(0).getCoordinate(0);
                        if (!n.equals2D(e[0])) throw new F("bad split edge start point at " + n);
                        var r = t.get(t.size() - 1).getCoordinates(), i = r[r.length - 1];
                        if (!i.equals2D(e[e.length - 1])) throw new F("bad split edge end point at " + i)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._nodeMap = new He, this._edge = null;
                        var t = arguments[0];
                        this._edge = t
                    }
                }]), e
            }(), xn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "octant", value: function () {
                        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var t = arguments[0], n = arguments[1];
                            if (0 === t && 0 === n) throw new x("Cannot compute the octant for point ( " + t + ", " + n + " )");
                            var r = Math.abs(t), i = Math.abs(n);
                            return t >= 0 ? n >= 0 ? r >= i ? 0 : 1 : r >= i ? 7 : 6 : n >= 0 ? r >= i ? 3 : 2 : r >= i ? 4 : 5
                        }
                        if (arguments[0] instanceof X && arguments[1] instanceof X) {
                            var o = arguments[0], s = arguments[1], a = s.x - o.x, u = s.y - o.y;
                            if (0 === a && 0 === u) throw new x("Cannot compute the octant for two identical points " + o);
                            return e.octant(a, u)
                        }
                    }
                }]), e
            }(), En = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "getCoordinates", value: function () {
                    }
                }, {
                    key: "size", value: function () {
                    }
                }, {
                    key: "getCoordinate", value: function (t) {
                    }
                }, {
                    key: "isClosed", value: function () {
                    }
                }, {
                    key: "setData", value: function (t) {
                    }
                }, {
                    key: "getData", value: function () {
                    }
                }]), e
            }(), kn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "addIntersection", value: function (t, e) {
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [En]
                    }
                }]), e
            }(), wn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getCoordinates", value: function () {
                        return this._pts
                    }
                }, {
                    key: "size", value: function () {
                        return this._pts.length
                    }
                }, {
                    key: "getCoordinate", value: function (t) {
                        return this._pts[t]
                    }
                }, {
                    key: "isClosed", value: function () {
                        return this._pts[0].equals(this._pts[this._pts.length - 1])
                    }
                }, {
                    key: "getSegmentOctant", value: function (t) {
                        return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
                    }
                }, {
                    key: "setData", value: function (t) {
                        this._data = t
                    }
                }, {
                    key: "safeOctant", value: function (t, e) {
                        return t.equals2D(e) ? 0 : xn.octant(t, e)
                    }
                }, {
                    key: "getData", value: function () {
                        return this._data
                    }
                }, {
                    key: "addIntersection", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            this.addIntersectionNode(t, e)
                        } else if (4 === arguments.length) {
                            var n = arguments[1], r = arguments[3], i = new X(arguments[0].getIntersection(r));
                            this.addIntersection(i, n)
                        }
                    }
                }, {
                    key: "toString", value: function () {
                        return Le.toLineString(new $t(this._pts))
                    }
                }, {
                    key: "getNodeList", value: function () {
                        return this._nodeList
                    }
                }, {
                    key: "addIntersectionNode", value: function (t, e) {
                        var n = e, r = n + 1;
                        if (r < this._pts.length) {
                            var i = this._pts[r];
                            t.equals2D(i) && (n = r)
                        }
                        return this._nodeList.add(t, n)
                    }
                }, {
                    key: "addIntersections", value: function (t, e, n) {
                        for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [kn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._nodeList = new _n(this), this._pts = null, this._data = null;
                        var t = arguments[0], e = arguments[1];
                        this._pts = t, this._data = e
                    }
                }, {
                    key: "getNodedSubstrings", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0], n = new dt;
                            return e.getNodedSubstrings(t, n), n
                        }
                        if (2 === arguments.length) for (var r = arguments[1], i = arguments[0].iterator(); i.hasNext();) i.next().getNodeList().addSplitEdges(r)
                    }
                }]), e
            }(), bn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "minX", value: function () {
                        return Math.min(this.p0.x, this.p1.x)
                    }
                }, {
                    key: "orientationIndex", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0], n = ft.index(this.p0, this.p1, t.p0),
                                r = ft.index(this.p0, this.p1, t.p1);
                            return n >= 0 && r >= 0 || n <= 0 && r <= 0 ? Math.max(n, r) : 0
                        }
                        if (arguments[0] instanceof X) {
                            var i = arguments[0];
                            return ft.index(this.p0, this.p1, i)
                        }
                    }
                }, {
                    key: "toGeometry", value: function (t) {
                        return t.createLineString([this.p0, this.p1])
                    }
                }, {
                    key: "isVertical", value: function () {
                        return this.p0.x === this.p1.x
                    }
                }, {
                    key: "equals", value: function (t) {
                        if (!(t instanceof e)) return !1;
                        var n = t;
                        return this.p0.equals(n.p0) && this.p1.equals(n.p1)
                    }
                }, {
                    key: "intersection", value: function (t) {
                        var e = new Re;
                        return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
                    }
                }, {
                    key: "project", value: function () {
                        if (arguments[0] instanceof X) {
                            var t = arguments[0];
                            if (t.equals(this.p0) || t.equals(this.p1)) return new X(t);
                            var n = this.projectionFactor(t), r = new X;
                            return r.x = this.p0.x + n * (this.p1.x - this.p0.x), r.y = this.p0.y + n * (this.p1.y - this.p0.y), r
                        }
                        if (arguments[0] instanceof e) {
                            var i = arguments[0], o = this.projectionFactor(i.p0), s = this.projectionFactor(i.p1);
                            if (o >= 1 && s >= 1) return null;
                            if (o <= 0 && s <= 0) return null;
                            var a = this.project(i.p0);
                            o < 0 && (a = this.p0), o > 1 && (a = this.p1);
                            var u = this.project(i.p1);
                            return s < 0 && (u = this.p0), s > 1 && (u = this.p1), new e(a, u)
                        }
                    }
                }, {
                    key: "normalize", value: function () {
                        this.p1.compareTo(this.p0) < 0 && this.reverse()
                    }
                }, {
                    key: "angle", value: function () {
                        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
                    }
                }, {
                    key: "getCoordinate", value: function (t) {
                        return 0 === t ? this.p0 : this.p1
                    }
                }, {
                    key: "distancePerpendicular", value: function (t) {
                        return kt.pointToLinePerpendicular(t, this.p0, this.p1)
                    }
                }, {
                    key: "minY", value: function () {
                        return Math.min(this.p0.y, this.p1.y)
                    }
                }, {
                    key: "midPoint", value: function () {
                        return e.midPoint(this.p0, this.p1)
                    }
                }, {
                    key: "projectionFactor", value: function (t) {
                        if (t.equals(this.p0)) return 0;
                        if (t.equals(this.p1)) return 1;
                        var e = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, r = e * e + n * n;
                        return r <= 0 ? A.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r
                    }
                }, {
                    key: "closestPoints", value: function (t) {
                        var e = this.intersection(t);
                        if (null !== e) return [e, e];
                        var n = new Array(2).fill(null), r = A.MAX_VALUE, i = null, o = this.closestPoint(t.p0);
                        r = o.distance(t.p0), n[0] = o, n[1] = t.p0;
                        var s = this.closestPoint(t.p1);
                        (i = s.distance(t.p1)) < r && (r = i, n[0] = s, n[1] = t.p1);
                        var a = t.closestPoint(this.p0);
                        (i = a.distance(this.p0)) < r && (r = i, n[0] = this.p0, n[1] = a);
                        var u = t.closestPoint(this.p1);
                        return (i = u.distance(this.p1)) < r && (r = i, n[0] = this.p1, n[1] = u), n
                    }
                }, {
                    key: "closestPoint", value: function (t) {
                        var e = this.projectionFactor(t);
                        return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1
                    }
                }, {
                    key: "maxX", value: function () {
                        return Math.max(this.p0.x, this.p1.x)
                    }
                }, {
                    key: "getLength", value: function () {
                        return this.p0.distance(this.p1)
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t, n = this.p0.compareTo(e.p0);
                        return 0 !== n ? n : this.p1.compareTo(e.p1)
                    }
                }, {
                    key: "reverse", value: function () {
                        var t = this.p0;
                        this.p0 = this.p1, this.p1 = t
                    }
                }, {
                    key: "equalsTopo", value: function (t) {
                        return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0)
                    }
                }, {
                    key: "lineIntersection", value: function (t) {
                        return _t.intersection(this.p0, this.p1, t.p0, t.p1)
                    }
                }, {
                    key: "maxY", value: function () {
                        return Math.max(this.p0.y, this.p1.y)
                    }
                }, {
                    key: "pointAlongOffset", value: function (t, e) {
                        var n = this.p0.x + t * (this.p1.x - this.p0.x), r = this.p0.y + t * (this.p1.y - this.p0.y),
                            i = this.p1.x - this.p0.x, o = this.p1.y - this.p0.y, s = Math.sqrt(i * i + o * o), a = 0,
                            u = 0;
                        if (0 !== e) {
                            if (s <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
                            a = e * i / s, u = e * o / s
                        }
                        return new X(n - u, r + a)
                    }
                }, {
                    key: "setCoordinates", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setCoordinates(t.p0, t.p1)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y
                        }
                    }
                }, {
                    key: "segmentFraction", value: function (t) {
                        var e = this.projectionFactor(t);
                        return e < 0 ? e = 0 : (e > 1 || A.isNaN(e)) && (e = 1), e
                    }
                }, {
                    key: "toString", value: function () {
                        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
                    }
                }, {
                    key: "isHorizontal", value: function () {
                        return this.p0.y === this.p1.y
                    }
                }, {
                    key: "reflect", value: function (t) {
                        var e = this.p1.getY() - this.p0.getY(), n = this.p0.getX() - this.p1.getX(),
                            r = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()),
                            i = e * e + n * n, o = e * e - n * n, s = t.getX(), a = t.getY();
                        return new X((-o * s - 2 * e * n * a - 2 * e * r) / i, (o * a - 2 * e * n * s - 2 * n * r) / i)
                    }
                }, {
                    key: "distance", value: function () {
                        if (arguments[0] instanceof e) {
                            var t = arguments[0];
                            return kt.segmentToSegment(this.p0, this.p1, t.p0, t.p1)
                        }
                        if (arguments[0] instanceof X) {
                            var n = arguments[0];
                            return kt.pointToSegment(n, this.p0, this.p1)
                        }
                    }
                }, {
                    key: "pointAlong", value: function (t) {
                        var e = new X;
                        return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
                    }
                }, {
                    key: "hashCode", value: function () {
                        var t = A.doubleToLongBits(this.p0.x);
                        t ^= 31 * A.doubleToLongBits(this.p0.y);
                        var e = Math.trunc(t) ^ Math.trunc(t >> 32), n = A.doubleToLongBits(this.p1.x);
                        return n ^= 31 * A.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k, b]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this.p0 = null, this.p1 = null, 0 === arguments.length) e.constructor_.call(this, new X, new X); else if (1 === arguments.length) {
                            var t = arguments[0];
                            e.constructor_.call(this, t.p0, t.p1)
                        } else if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1];
                            this.p0 = n, this.p1 = r
                        } else if (4 === arguments.length) {
                            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3];
                            e.constructor_.call(this, new X(i, o), new X(s, a))
                        }
                    }
                }, {
                    key: "midPoint", value: function (t, e) {
                        return new X((t.x + e.x) / 2, (t.y + e.y) / 2)
                    }
                }]), e
            }(), In = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "overlap", value: function () {
                        if (2 === arguments.length) ; else if (4 === arguments.length) {
                            var t = arguments[1], e = arguments[2], n = arguments[3];
                            arguments[0].getLineSegment(t, this._overlapSeg1), e.getLineSegment(n, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2)
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._overlapSeg1 = new bn, this._overlapSeg2 = new bn
                    }
                }]), e
            }(), Sn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getLineSegment", value: function (t, e) {
                        e.p0 = this._pts[t], e.p1 = this._pts[t + 1]
                    }
                }, {
                    key: "computeSelect", value: function (t, e, n, r) {
                        var i = this._pts[e], o = this._pts[n];
                        if (n - e == 1) return r.select(this, e), null;
                        if (!t.intersects(i, o)) return null;
                        var s = Math.trunc((e + n) / 2);
                        e < s && this.computeSelect(t, e, s, r), s < n && this.computeSelect(t, s, n, r)
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];
                        return t
                    }
                }, {
                    key: "computeOverlaps", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[0], e = arguments[1];
                            this.computeOverlaps(this._start, this._end, t, t._start, t._end, e)
                        } else if (6 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = arguments[2], o = arguments[3],
                                s = arguments[4], a = arguments[5];
                            if (r - n == 1 && s - o == 1) return a.overlap(this, n, i, o), null;
                            if (!this.overlaps(n, r, i, o, s)) return null;
                            var u = Math.trunc((n + r) / 2), l = Math.trunc((o + s) / 2);
                            n < u && (o < l && this.computeOverlaps(n, u, i, o, l, a), l < s && this.computeOverlaps(n, u, i, l, s, a)), u < r && (o < l && this.computeOverlaps(u, r, i, o, l, a), l < s && this.computeOverlaps(u, r, i, l, s, a))
                        }
                    }
                }, {
                    key: "setId", value: function (t) {
                        this._id = t
                    }
                }, {
                    key: "select", value: function (t, e) {
                        this.computeSelect(t, this._start, this._end, e)
                    }
                }, {
                    key: "getEnvelope", value: function () {
                        if (null === this._env) {
                            var t = this._pts[this._start], e = this._pts[this._end];
                            this._env = new U(t, e)
                        }
                        return this._env
                    }
                }, {
                    key: "overlaps", value: function (t, e, n, r, i) {
                        return U.intersects(this._pts[t], this._pts[e], n._pts[r], n._pts[i])
                    }
                }, {
                    key: "getEndIndex", value: function () {
                        return this._end
                    }
                }, {
                    key: "getStartIndex", value: function () {
                        return this._start
                    }
                }, {
                    key: "getContext", value: function () {
                        return this._context
                    }
                }, {
                    key: "getId", value: function () {
                        return this._id
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
                        this._pts = t, this._start = e, this._end = n, this._context = r
                    }
                }]), e
            }(), Nn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "findChainEnd", value: function (t, e) {
                        for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;
                        if (n >= t.length - 1) return t.length - 1;
                        for (var r = Je.quadrant(t[n], t[n + 1]), i = e + 1; i < t.length && (t[i - 1].equals2D(t[i]) || Je.quadrant(t[i - 1], t[i]) === r);) i++;
                        return i - 1
                    }
                }, {
                    key: "getChains", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return e.getChains(t, null)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0], r = arguments[1], i = new dt, o = 0;
                            do {
                                var s = e.findChainEnd(n, o), a = new Sn(n, o, s, r);
                                i.add(a), o = s
                            } while (o < n.length - 1);
                            return i
                        }
                    }
                }]), e
            }(), Mn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "computeNodes", value: function (t) {
                    }
                }, {
                    key: "getNodedSubstrings", value: function () {
                    }
                }]), e
            }(), Pn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "setSegmentIntersector", value: function (t) {
                        this._segInt = t
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Mn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._segInt = null, 0 === arguments.length) ; else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setSegmentIntersector(t)
                        }
                    }
                }]), e
            }(), Ln = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, [{
                    key: "getMonotoneChains", value: function () {
                        return this._monoChains
                    }
                }, {
                    key: "getNodedSubstrings", value: function () {
                        return wn.getNodedSubstrings(this._nodedSegStrings)
                    }
                }, {
                    key: "getIndex", value: function () {
                        return this._index
                    }
                }, {
                    key: "add", value: function (t) {
                        for (var e = Nn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {
                            var n = e.next();
                            n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n)
                        }
                    }
                }, {
                    key: "computeNodes", value: function (t) {
                        this._nodedSegStrings = t;
                        for (var e = t.iterator(); e.hasNext();) this.add(e.next());
                        this.intersectChains()
                    }
                }, {
                    key: "intersectChains", value: function () {
                        for (var t = new Cn(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (var n = e.next(), r = this._index.query(n.getEnvelope()).iterator(); r.hasNext();) {
                            var i = r.next();
                            if (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++), this._segInt.isDone()) return null
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._monoChains = new dt, this._index = new pn, this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length) ; else if (1 === arguments.length) {
                            var t = arguments[0];
                            Pn.constructor_.call(this, t)
                        }
                    }
                }]), o
            }(Pn), Cn = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "overlap", value: function () {
                        if (4 !== arguments.length) return g(o(s.prototype), "overlap", this).apply(this, arguments);
                        var t = arguments[1], e = arguments[2], n = arguments[3], r = arguments[0].getContext(),
                            i = e.getContext();
                        this._si.processIntersections(r, t, i, n)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._si = null;
                        var t = arguments[0];
                        this._si = t
                    }
                }]), s
            }(In);
            Ln.SegmentOverlapAction = Cn;
            var Rn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "isDeletable", value: function (t, e, n, r) {
                        var i = this._inputLine[t], o = this._inputLine[e], s = this._inputLine[n];
                        return !!this.isConcave(i, o, s) && !!this.isShallow(i, o, s, r) && this.isShallowSampled(i, o, t, n, r)
                    }
                }, {
                    key: "deleteShallowConcavities", value: function () {
                        for (var t = 1, n = this.findNextNonDeletedIndex(t), r = this.findNextNonDeletedIndex(n), i = !1; r < this._inputLine.length;) {
                            var o = !1;
                            this.isDeletable(t, n, r, this._distanceTol) && (this._isDeleted[n] = e.DELETE, o = !0, i = !0), t = o ? r : n, n = this.findNextNonDeletedIndex(t), r = this.findNextNonDeletedIndex(n)
                        }
                        return i
                    }
                }, {
                    key: "isShallowConcavity", value: function (t, e, n, r) {
                        return ft.index(t, e, n) === this._angleOrientation && kt.pointToSegment(e, t, n) < r
                    }
                }, {
                    key: "isShallowSampled", value: function (t, n, r, i, o) {
                        var s = Math.trunc((i - r) / e.NUM_PTS_TO_CHECK);
                        s <= 0 && (s = 1);
                        for (var a = r; a < i; a += s) if (!this.isShallow(t, n, this._inputLine[a], o)) return !1;
                        return !0
                    }
                }, {
                    key: "isConcave", value: function (t, e, n) {
                        return ft.index(t, e, n) === this._angleOrientation
                    }
                }, {
                    key: "simplify", value: function (t) {
                        this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = ft.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
                        var e = !1;
                        do {
                            e = this.deleteShallowConcavities()
                        } while (e);
                        return this.collapseLine()
                    }
                }, {
                    key: "findNextNonDeletedIndex", value: function (t) {
                        for (var n = t + 1; n < this._inputLine.length && this._isDeleted[n] === e.DELETE;) n++;
                        return n
                    }
                }, {
                    key: "isShallow", value: function (t, e, n, r) {
                        return kt.pointToSegment(e, t, n) < r
                    }
                }, {
                    key: "collapseLine", value: function () {
                        for (var t = new Ht, n = 0; n < this._inputLine.length; n++) this._isDeleted[n] !== e.DELETE && t.add(this._inputLine[n]);
                        return t.toCoordinateArray()
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ft.COUNTERCLOCKWISE;
                        var t = arguments[0];
                        this._inputLine = t
                    }
                }, {
                    key: "simplify", value: function (t, n) {
                        return new e(t).simplify(n)
                    }
                }]), e
            }();
            Rn.INIT = 0, Rn.DELETE = 1, Rn.KEEP = 1, Rn.NUM_PTS_TO_CHECK = 10;
            var Tn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getCoordinates", value: function () {
                        return this._ptList.toArray(e.COORDINATE_ARRAY_TYPE)
                    }
                }, {
                    key: "setPrecisionModel", value: function (t) {
                        this._precisionModel = t
                    }
                }, {
                    key: "addPt", value: function (t) {
                        var e = new X(t);
                        if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;
                        this._ptList.add(e)
                    }
                }, {
                    key: "reverse", value: function () {
                    }
                }, {
                    key: "addPts", value: function (t, e) {
                        if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]); else for (var r = t.length - 1; r >= 0; r--) this.addPt(t[r])
                    }
                }, {
                    key: "isRedundant", value: function (t) {
                        if (this._ptList.size() < 1) return !1;
                        var e = this._ptList.get(this._ptList.size() - 1);
                        return t.distance(e) < this._minimimVertexDistance
                    }
                }, {
                    key: "toString", value: function () {
                        return (new ae).createLineString(this.getCoordinates()).toString()
                    }
                }, {
                    key: "closeRing", value: function () {
                        if (this._ptList.size() < 1) return null;
                        var t = new X(this._ptList.get(0)), e = this._ptList.get(this._ptList.size() - 1);
                        if (t.equals(e)) return null;
                        this._ptList.add(t)
                    }
                }, {
                    key: "setMinimumVertexDistance", value: function (t) {
                        this._minimimVertexDistance = t
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new dt
                    }
                }]), e
            }();
            Tn.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
            var On = function () {
                function e() {
                    t(this, e)
                }

                return r(e, null, [{
                    key: "toDegrees", value: function (t) {
                        return 180 * t / Math.PI
                    }
                }, {
                    key: "normalize", value: function (t) {
                        for (; t > Math.PI;) t -= e.PI_TIMES_2;
                        for (; t <= -Math.PI;) t += e.PI_TIMES_2;
                        return t
                    }
                }, {
                    key: "angle", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return Math.atan2(t.y, t.x)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1], r = n.x - e.x, i = n.y - e.y;
                            return Math.atan2(i, r)
                        }
                    }
                }, {
                    key: "isAcute", value: function (t, e, n) {
                        var r = t.x - e.x, i = t.y - e.y;
                        return r * (n.x - e.x) + i * (n.y - e.y) > 0
                    }
                }, {
                    key: "isObtuse", value: function (t, e, n) {
                        var r = t.x - e.x, i = t.y - e.y;
                        return r * (n.x - e.x) + i * (n.y - e.y) < 0
                    }
                }, {
                    key: "interiorAngle", value: function (t, n, r) {
                        var i = e.angle(n, t), o = e.angle(n, r);
                        return Math.abs(o - i)
                    }
                }, {
                    key: "normalizePositive", value: function (t) {
                        if (t < 0) {
                            for (; t < 0;) t += e.PI_TIMES_2;
                            t >= e.PI_TIMES_2 && (t = 0)
                        } else {
                            for (; t >= e.PI_TIMES_2;) t -= e.PI_TIMES_2;
                            t < 0 && (t = 0)
                        }
                        return t
                    }
                }, {
                    key: "angleBetween", value: function (t, n, r) {
                        var i = e.angle(n, t), o = e.angle(n, r);
                        return e.diff(i, o)
                    }
                }, {
                    key: "diff", value: function (t, e) {
                        var n = null;
                        return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n
                    }
                }, {
                    key: "toRadians", value: function (t) {
                        return t * Math.PI / 180
                    }
                }, {
                    key: "getTurn", value: function (t, n) {
                        var r = Math.sin(n - t);
                        return r > 0 ? e.COUNTERCLOCKWISE : r < 0 ? e.CLOCKWISE : e.NONE
                    }
                }, {
                    key: "angleBetweenOriented", value: function (t, n, r) {
                        var i = e.angle(n, t), o = e.angle(n, r) - i;
                        return o <= -Math.PI ? o + e.PI_TIMES_2 : o > Math.PI ? o - e.PI_TIMES_2 : o
                    }
                }]), e
            }();
            On.PI_TIMES_2 = 2 * Math.PI, On.PI_OVER_2 = Math.PI / 2, On.PI_OVER_4 = Math.PI / 4, On.COUNTERCLOCKWISE = ft.COUNTERCLOCKWISE, On.CLOCKWISE = ft.CLOCKWISE, On.NONE = ft.COLLINEAR;
            var An = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "addNextSegment", value: function (t, e) {
                        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
                        var n = ft.index(this._s0, this._s1, this._s2),
                            r = n === ft.CLOCKWISE && this._side === tt.LEFT || n === ft.COUNTERCLOCKWISE && this._side === tt.RIGHT;
                        0 === n ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
                    }
                }, {
                    key: "addLineEndCap", value: function (t, e) {
                        var n = new bn(t, e), r = new bn;
                        this.computeOffsetSegment(n, tt.LEFT, this._distance, r);
                        var i = new bn;
                        this.computeOffsetSegment(n, tt.RIGHT, this._distance, i);
                        var o = e.x - t.x, s = e.y - t.y, a = Math.atan2(s, o);
                        switch (this._bufParams.getEndCapStyle()) {
                            case m.CAP_ROUND:
                                this._segList.addPt(r.p1), this.addDirectedFillet(e, a + Math.PI / 2, a - Math.PI / 2, ft.CLOCKWISE, this._distance), this._segList.addPt(i.p1);
                                break;
                            case m.CAP_FLAT:
                                this._segList.addPt(r.p1), this._segList.addPt(i.p1);
                                break;
                            case m.CAP_SQUARE:
                                var u = new X;
                                u.x = Math.abs(this._distance) * Math.cos(a), u.y = Math.abs(this._distance) * Math.sin(a);
                                var l = new X(r.p1.x + u.x, r.p1.y + u.y), h = new X(i.p1.x + u.x, i.p1.y + u.y);
                                this._segList.addPt(l), this._segList.addPt(h)
                        }
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        return this._segList.getCoordinates()
                    }
                }, {
                    key: "addMitreJoin", value: function (t, e, n, r) {
                        var i = _t.intersection(e.p0, e.p1, n.p0, n.p1);
                        if (null !== i && (r <= 0 ? 1 : i.distance(t) / Math.abs(r)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(i), null;
                        this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit())
                    }
                }, {
                    key: "addOutsideTurn", value: function (t, n) {
                        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * e.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
                        this._bufParams.getJoinStyle() === m.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === m.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (n && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0))
                    }
                }, {
                    key: "createSquare", value: function (t) {
                        this._segList.addPt(new X(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new X(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new X(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new X(t.x - this._distance, t.y + this._distance)), this._segList.closeRing()
                    }
                }, {
                    key: "addSegments", value: function (t, e) {
                        this._segList.addPts(t, e)
                    }
                }, {
                    key: "addFirstSegment", value: function () {
                        this._segList.addPt(this._offset1.p0)
                    }
                }, {
                    key: "addCornerFillet", value: function (t, e, n, r, i) {
                        var o = e.x - t.x, s = e.y - t.y, a = Math.atan2(s, o), u = n.x - t.x, l = n.y - t.y,
                            h = Math.atan2(l, u);
                        r === ft.CLOCKWISE ? a <= h && (a += 2 * Math.PI) : a >= h && (a -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, a, h, r, i), this._segList.addPt(n)
                    }
                }, {
                    key: "addLastSegment", value: function () {
                        this._segList.addPt(this._offset1.p1)
                    }
                }, {
                    key: "initSideSegments", value: function (t, e, n) {
                        this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1)
                    }
                }, {
                    key: "addLimitedMitreJoin", value: function (t, e, n, r) {
                        var i = this._seg0.p1, o = On.angle(i, this._seg0.p0),
                            s = On.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2, a = On.normalize(o + s),
                            u = On.normalize(a + Math.PI), l = r * n, h = n - l * Math.abs(Math.sin(s)),
                            c = i.x + l * Math.cos(u), f = i.y + l * Math.sin(u), g = new X(c, f), p = new bn(i, g),
                            v = p.pointAlongOffset(1, h), d = p.pointAlongOffset(1, -h);
                        this._side === tt.LEFT ? (this._segList.addPt(v), this._segList.addPt(d)) : (this._segList.addPt(d), this._segList.addPt(v))
                    }
                }, {
                    key: "addDirectedFillet", value: function (t, e, n, r, i) {
                        var o = r === ft.CLOCKWISE ? -1 : 1, s = Math.abs(e - n),
                            a = Math.trunc(s / this._filletAngleQuantum + .5);
                        if (a < 1) return null;
                        for (var u = s / a, l = new X, h = 0; h < a; h++) {
                            var c = e + o * h * u;
                            l.x = t.x + i * Math.cos(c), l.y = t.y + i * Math.sin(c), this._segList.addPt(l)
                        }
                    }
                }, {
                    key: "computeOffsetSegment", value: function (t, e, n, r) {
                        var i = e === tt.LEFT ? 1 : -1, o = t.p1.x - t.p0.x, s = t.p1.y - t.p0.y,
                            a = Math.sqrt(o * o + s * s), u = i * n * o / a, l = i * n * s / a;
                        r.p0.x = t.p0.x - l, r.p0.y = t.p0.y + u, r.p1.x = t.p1.x - l, r.p1.y = t.p1.y + u
                    }
                }, {
                    key: "addInsideTurn", value: function (t, n) {
                        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0)); else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * e.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1); else {
                            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
                                var r = new X((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                                this._segList.addPt(r);
                                var i = new X((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                                this._segList.addPt(i)
                            } else this._segList.addPt(this._s1);
                            this._segList.addPt(this._offset1.p0)
                        }
                    }
                }, {
                    key: "createCircle", value: function (t) {
                        var e = new X(t.x + this._distance, t.y);
                        this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing()
                    }
                }, {
                    key: "addBevelJoin", value: function (t, e) {
                        this._segList.addPt(t.p1), this._segList.addPt(e.p0)
                    }
                }, {
                    key: "init", value: function (t) {
                        this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Tn, this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * e.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
                    }
                }, {
                    key: "addCollinear", value: function (t) {
                        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === m.JOIN_BEVEL || this._bufParams.getJoinStyle() === m.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ft.CLOCKWISE, this._distance))
                    }
                }, {
                    key: "closeRing", value: function () {
                        this._segList.closeRing()
                    }
                }, {
                    key: "hasNarrowConcaveAngle", value: function () {
                        return this._hasNarrowConcaveAngle
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new bn, this._seg1 = new bn, this._offset0 = new bn, this._offset1 = new bn, this._side = 0, this._hasNarrowConcaveAngle = !1;
                        var t = arguments[0], n = arguments[1], r = arguments[2];
                        this._precisionModel = t, this._bufParams = n, this._li = new Re, this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === m.JOIN_ROUND && (this._closingSegLengthFactor = e.MAX_CLOSING_SEG_LEN_FACTOR), this.init(r)
                    }
                }]), e
            }();
            An.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, An.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, An.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, An.MAX_CLOSING_SEG_LEN_FACTOR = 80;
            var Dn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getOffsetCurve", value: function (t, e) {
                        if (this._distance = e, 0 === e) return null;
                        var n = e < 0, r = Math.abs(e), i = this.getSegGen(r);
                        t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i);
                        var o = i.getCoordinates();
                        return n && Wt.reverse(o), o
                    }
                }, {
                    key: "computeSingleSidedBufferCurve", value: function (t, e, n) {
                        var r = this.simplifyTolerance(this._distance);
                        if (e) {
                            n.addSegments(t, !0);
                            var i = Rn.simplify(t, -r), o = i.length - 1;
                            n.initSideSegments(i[o], i[o - 1], tt.LEFT), n.addFirstSegment();
                            for (var s = o - 2; s >= 0; s--) n.addNextSegment(i[s], !0)
                        } else {
                            n.addSegments(t, !1);
                            var a = Rn.simplify(t, r), u = a.length - 1;
                            n.initSideSegments(a[0], a[1], tt.LEFT), n.addFirstSegment();
                            for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0)
                        }
                        n.addLastSegment(), n.closeRing()
                    }
                }, {
                    key: "computeRingBufferCurve", value: function (t, e, n) {
                        var r = this.simplifyTolerance(this._distance);
                        e === tt.RIGHT && (r = -r);
                        var i = Rn.simplify(t, r), o = i.length - 1;
                        n.initSideSegments(i[o - 1], i[0], e);
                        for (var s = 1; s <= o; s++) {
                            var a = 1 !== s;
                            n.addNextSegment(i[s], a)
                        }
                        n.closeRing()
                    }
                }, {
                    key: "computeLineBufferCurve", value: function (t, e) {
                        var n = this.simplifyTolerance(this._distance), r = Rn.simplify(t, n), i = r.length - 1;
                        e.initSideSegments(r[0], r[1], tt.LEFT);
                        for (var o = 2; o <= i; o++) e.addNextSegment(r[o], !0);
                        e.addLastSegment(), e.addLineEndCap(r[i - 1], r[i]);
                        var s = Rn.simplify(t, -n), a = s.length - 1;
                        e.initSideSegments(s[a], s[a - 1], tt.LEFT);
                        for (var u = a - 2; u >= 0; u--) e.addNextSegment(s[u], !0);
                        e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing()
                    }
                }, {
                    key: "computePointCurve", value: function (t, e) {
                        switch (this._bufParams.getEndCapStyle()) {
                            case m.CAP_ROUND:
                                e.createCircle(t);
                                break;
                            case m.CAP_SQUARE:
                                e.createSquare(t)
                        }
                    }
                }, {
                    key: "getLineCurve", value: function (t, e) {
                        if (this._distance = e, this.isLineOffsetEmpty(e)) return null;
                        var n = Math.abs(e), r = this.getSegGen(n);
                        if (t.length <= 1) this.computePointCurve(t[0], r); else if (this._bufParams.isSingleSided()) {
                            var i = e < 0;
                            this.computeSingleSidedBufferCurve(t, i, r)
                        } else this.computeLineBufferCurve(t, r);
                        return r.getCoordinates()
                    }
                }, {
                    key: "getBufferParameters", value: function () {
                        return this._bufParams
                    }
                }, {
                    key: "simplifyTolerance", value: function (t) {
                        return t * this._bufParams.getSimplifyFactor()
                    }
                }, {
                    key: "getRingCurve", value: function (t, n, r) {
                        if (this._distance = r, t.length <= 2) return this.getLineCurve(t, r);
                        if (0 === r) return e.copyCoordinates(t);
                        var i = this.getSegGen(r);
                        return this.computeRingBufferCurve(t, n, i), i.getCoordinates()
                    }
                }, {
                    key: "computeOffsetCurve", value: function (t, e, n) {
                        var r = this.simplifyTolerance(this._distance);
                        if (e) {
                            var i = Rn.simplify(t, -r), o = i.length - 1;
                            n.initSideSegments(i[o], i[o - 1], tt.LEFT), n.addFirstSegment();
                            for (var s = o - 2; s >= 0; s--) n.addNextSegment(i[s], !0)
                        } else {
                            var a = Rn.simplify(t, r), u = a.length - 1;
                            n.initSideSegments(a[0], a[1], tt.LEFT), n.addFirstSegment();
                            for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0)
                        }
                        n.addLastSegment()
                    }
                }, {
                    key: "isLineOffsetEmpty", value: function (t) {
                        return 0 === t || t < 0 && !this._bufParams.isSingleSided()
                    }
                }, {
                    key: "getSegGen", value: function (t) {
                        return new An(this._precisionModel, this._bufParams, t)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._distance = 0, this._precisionModel = null, this._bufParams = null;
                        var t = arguments[0], e = arguments[1];
                        this._precisionModel = t, this._bufParams = e
                    }
                }, {
                    key: "copyCoordinates", value: function (t) {
                        for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new X(t[n]);
                        return e
                    }
                }]), e
            }(), Fn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "findStabbedSegments", value: function () {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = new dt, n = this._subgraphs.iterator(); n.hasNext();) {
                                var r = n.next(), i = r.getEnvelope();
                                t.y < i.getMinY() || t.y > i.getMaxY() || this.findStabbedSegments(t, r.getDirectedEdges(), e)
                            }
                            return e
                        }
                        if (3 === arguments.length) if (ot(arguments[2], rt) && arguments[0] instanceof X && arguments[1] instanceof Ke) {
                            for (var o = arguments[0], s = arguments[1], a = arguments[2], u = s.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++) if (this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < o.x || this._seg.isHorizontal() || o.y < this._seg.p0.y || o.y > this._seg.p1.y || ft.index(this._seg.p0, this._seg.p1, o) === ft.RIGHT)) {
                                var h = s.getDepth(tt.LEFT);
                                this._seg.p0.equals(u[l]) || (h = s.getDepth(tt.RIGHT));
                                var c = new qn(this._seg, h);
                                a.add(c)
                            }
                        } else if (ot(arguments[2], rt) && arguments[0] instanceof X && ot(arguments[1], rt)) for (var f = arguments[0], g = arguments[2], p = arguments[1].iterator(); p.hasNext();) {
                            var v = p.next();
                            v.isForward() && this.findStabbedSegments(f, v, g)
                        }
                    }
                }, {
                    key: "getDepth", value: function (t) {
                        var e = this.findStabbedSegments(t);
                        return 0 === e.size() ? 0 : un.min(e)._leftDepth
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._subgraphs = null, this._seg = new bn;
                        var t = arguments[0];
                        this._subgraphs = t
                    }
                }]), e
            }(), qn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "compareTo", value: function (t) {
                        var e = t;
                        if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
                        if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;
                        var n = this._upwardSeg.orientationIndex(e._upwardSeg);
                        return 0 !== n || 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg)
                    }
                }, {
                    key: "compareX", value: function (t, e) {
                        var n = t.p0.compareTo(e.p0);
                        return 0 !== n ? n : t.p1.compareTo(e.p1)
                    }
                }, {
                    key: "toString", value: function () {
                        return this._upwardSeg.toString()
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._upwardSeg = null, this._leftDepth = null;
                        var t = arguments[0], e = arguments[1];
                        this._upwardSeg = new bn(t), this._leftDepth = e
                    }
                }]), e
            }();
            Fn.DepthSegment = qn;
            var Gn = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    var e;
                    return t(this, o), e = n.call(this), o.constructor_.apply(h(e), arguments), e
                }

                return r(o, null, [{
                    key: "constructor_", value: function () {
                        _.constructor_.call(this, "Projective point not representable on the Cartesian plane.")
                    }
                }]), o
            }(_), Yn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getY", value: function () {
                        var t = this.y / this.w;
                        if (A.isNaN(t) || A.isInfinite(t)) throw new Gn;
                        return t
                    }
                }, {
                    key: "getX", value: function () {
                        var t = this.x / this.w;
                        if (A.isNaN(t) || A.isInfinite(t)) throw new Gn;
                        return t
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        var t = new X;
                        return t.x = this.getX(), t.y = this.getY(), t
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1; else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.x = t.x, this.y = t.y, this.w = 1
                        } else if (2 === arguments.length) {
                            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                                var n = arguments[0], r = arguments[1];
                                this.x = n, this.y = r, this.w = 1
                            } else if (arguments[0] instanceof e && arguments[1] instanceof e) {
                                var i = arguments[0], o = arguments[1];
                                this.x = i.y * o.w - o.y * i.w, this.y = o.x * i.w - i.x * o.w, this.w = i.x * o.y - o.x * i.y
                            } else if (arguments[0] instanceof X && arguments[1] instanceof X) {
                                var s = arguments[0], a = arguments[1];
                                this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y
                            }
                        } else if (3 === arguments.length) {
                            var u = arguments[0], l = arguments[1], h = arguments[2];
                            this.x = u, this.y = l, this.w = h
                        } else if (4 === arguments.length) {
                            var c = arguments[0], f = arguments[1], g = arguments[2], p = arguments[3], v = c.y - f.y,
                                d = f.x - c.x, y = c.x * f.y - f.x * c.y, m = g.y - p.y, _ = p.x - g.x,
                                x = g.x * p.y - p.x * g.y;
                            this.x = d * x - _ * y, this.y = m * y - v * x, this.w = v * _ - m * d
                        }
                    }
                }]), e
            }(), Bn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "area", value: function () {
                        return e.area(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "signedArea", value: function () {
                        return e.signedArea(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "interpolateZ", value: function (t) {
                        if (null === t) throw new x("Supplied point is null.");
                        return e.interpolateZ(t, this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "longestSideLength", value: function () {
                        return e.longestSideLength(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "isAcute", value: function () {
                        return e.isAcute(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "circumcentre", value: function () {
                        return e.circumcentre(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "area3D", value: function () {
                        return e.area3D(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "centroid", value: function () {
                        return e.centroid(this.p0, this.p1, this.p2)
                    }
                }, {
                    key: "inCentre", value: function () {
                        return e.inCentre(this.p0, this.p1, this.p2)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this.p0 = null, this.p1 = null, this.p2 = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        this.p0 = t, this.p1 = e, this.p2 = n
                    }
                }, {
                    key: "area", value: function (t, e, n) {
                        return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
                    }
                }, {
                    key: "signedArea", value: function (t, e, n) {
                        return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
                    }
                }, {
                    key: "det", value: function (t, e, n, r) {
                        return t * r - e * n
                    }
                }, {
                    key: "interpolateZ", value: function (t, e, n, r) {
                        var i = e.x, o = e.y, s = n.x - i, a = r.x - i, u = n.y - o, l = r.y - o, h = s * l - a * u,
                            c = t.x - i, f = t.y - o, g = (l * c - a * f) / h, p = (-u * c + s * f) / h;
                        return e.getZ() + g * (n.getZ() - e.getZ()) + p * (r.getZ() - e.getZ())
                    }
                }, {
                    key: "longestSideLength", value: function (t, e, n) {
                        var r = t.distance(e), i = e.distance(n), o = n.distance(t), s = r;
                        return i > s && (s = i), o > s && (s = o), s
                    }
                }, {
                    key: "circumcentreDD", value: function (t, e, n) {
                        var r = lt.valueOf(t.x).subtract(n.x), i = lt.valueOf(t.y).subtract(n.y),
                            o = lt.valueOf(e.x).subtract(n.x), s = lt.valueOf(e.y).subtract(n.y),
                            a = lt.determinant(r, i, o, s).multiply(2), u = r.sqr().add(i.sqr()),
                            l = o.sqr().add(s.sqr()), h = lt.determinant(i, u, s, l), c = lt.determinant(r, u, o, l),
                            f = lt.valueOf(n.x).subtract(h.divide(a)).doubleValue(),
                            g = lt.valueOf(n.y).add(c.divide(a)).doubleValue();
                        return new X(f, g)
                    }
                }, {
                    key: "isAcute", value: function (t, e, n) {
                        return !!On.isAcute(t, e, n) && !!On.isAcute(e, n, t) && !!On.isAcute(n, t, e)
                    }
                }, {
                    key: "circumcentre", value: function (t, n, r) {
                        var i = r.x, o = r.y, s = t.x - i, a = t.y - o, u = n.x - i, l = n.y - o,
                            h = 2 * e.det(s, a, u, l), c = e.det(a, s * s + a * a, l, u * u + l * l),
                            f = e.det(s, s * s + a * a, u, u * u + l * l);
                        return new X(i - c / h, o + f / h)
                    }
                }, {
                    key: "perpendicularBisector", value: function (t, e) {
                        var n = e.x - t.x, r = e.y - t.y, i = new Yn(t.x + n / 2, t.y + r / 2, 1),
                            o = new Yn(t.x - r + n / 2, t.y + n + r / 2, 1);
                        return new Yn(i, o)
                    }
                }, {
                    key: "angleBisector", value: function (t, e, n) {
                        var r = e.distance(t), i = r / (r + e.distance(n)), o = n.x - t.x, s = n.y - t.y;
                        return new X(t.x + i * o, t.y + i * s)
                    }
                }, {
                    key: "area3D", value: function (t, e, n) {
                        var r = e.x - t.x, i = e.y - t.y, o = e.getZ() - t.getZ(), s = n.x - t.x, a = n.y - t.y,
                            u = n.getZ() - t.getZ(), l = i * u - o * a, h = o * s - r * u, c = r * a - i * s,
                            f = l * l + h * h + c * c;
                        return Math.sqrt(f) / 2
                    }
                }, {
                    key: "centroid", value: function (t, e, n) {
                        var r = (t.x + e.x + n.x) / 3, i = (t.y + e.y + n.y) / 3;
                        return new X(r, i)
                    }
                }, {
                    key: "inCentre", value: function (t, e, n) {
                        var r = e.distance(n), i = t.distance(n), o = t.distance(e), s = r + i + o,
                            a = (r * t.x + i * e.x + o * n.x) / s, u = (r * t.y + i * e.y + o * n.y) / s;
                        return new X(a, u)
                    }
                }]), e
            }(), zn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "addRingSide", value: function (t, e, n, r, i) {
                        if (0 === e && t.length < Xt.MINIMUM_VALID_SIZE) return null;
                        var o = r, s = i;
                        t.length >= Xt.MINIMUM_VALID_SIZE && ft.isCCW(t) && (o = i, s = r, n = tt.opposite(n));
                        var a = this._curveBuilder.getRingCurve(t, n, e);
                        this.addCurve(a, o, s)
                    }
                }, {
                    key: "addRingBothSides", value: function (t, e) {
                        this.addRingSide(t, e, tt.LEFT, Z.EXTERIOR, Z.INTERIOR), this.addRingSide(t, e, tt.RIGHT, Z.INTERIOR, Z.EXTERIOR)
                    }
                }, {
                    key: "addPoint", value: function (t) {
                        if (this._distance <= 0) return null;
                        var e = t.getCoordinates(), n = this._curveBuilder.getLineCurve(e, this._distance);
                        this.addCurve(n, Z.EXTERIOR, Z.INTERIOR)
                    }
                }, {
                    key: "addPolygon", value: function (t) {
                        var e = this._distance, n = tt.LEFT;
                        this._distance < 0 && (e = -this._distance, n = tt.RIGHT);
                        var r = t.getExteriorRing(), i = Wt.removeRepeatedPoints(r.getCoordinates());
                        if (this._distance < 0 && this.isErodedCompletely(r, this._distance)) return null;
                        if (this._distance <= 0 && i.length < 3) return null;
                        this.addRingSide(i, e, n, Z.EXTERIOR, Z.INTERIOR);
                        for (var o = 0; o < t.getNumInteriorRing(); o++) {
                            var s = t.getInteriorRingN(o), a = Wt.removeRepeatedPoints(s.getCoordinates());
                            this._distance > 0 && this.isErodedCompletely(s, -this._distance) || this.addRingSide(a, e, tt.opposite(n), Z.INTERIOR, Z.EXTERIOR)
                        }
                    }
                }, {
                    key: "isTriangleErodedCompletely", value: function (t, e) {
                        var n = new Bn(t[0], t[1], t[2]), r = n.inCentre();
                        return kt.pointToSegment(r, n.p0, n.p1) < Math.abs(e)
                    }
                }, {
                    key: "addLineString", value: function (t) {
                        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
                        var e = Wt.removeRepeatedPoints(t.getCoordinates());
                        if (Wt.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance); else {
                            var n = this._curveBuilder.getLineCurve(e, this._distance);
                            this.addCurve(n, Z.EXTERIOR, Z.INTERIOR)
                        }
                    }
                }, {
                    key: "addCurve", value: function (t, e, n) {
                        if (null === t || t.length < 2) return null;
                        var r = new wn(t, new De(0, Z.BOUNDARY, e, n));
                        this._curveList.add(r)
                    }
                }, {
                    key: "getCurves", value: function () {
                        return this.add(this._inputGeom), this._curveList
                    }
                }, {
                    key: "add", value: function (t) {
                        if (t.isEmpty()) return null;
                        if (t instanceof Ft) this.addPolygon(t); else if (t instanceof Ct) this.addLineString(t); else if (t instanceof Tt) this.addPoint(t); else if (t instanceof zt) this.addCollection(t); else if (t instanceof se) this.addCollection(t); else if (t instanceof ee) this.addCollection(t); else {
                            if (!(t instanceof Bt)) throw new J(t.getGeometryType());
                            this.addCollection(t)
                        }
                    }
                }, {
                    key: "isErodedCompletely", value: function (t, e) {
                        var n = t.getCoordinates();
                        if (n.length < 4) return e < 0;
                        if (4 === n.length) return this.isTriangleErodedCompletely(n, e);
                        var r = t.getEnvelopeInternal(), i = Math.min(r.getHeight(), r.getWidth());
                        return e < 0 && 2 * Math.abs(e) > i
                    }
                }, {
                    key: "addCollection", value: function (t) {
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var n = t.getGeometryN(e);
                            this.add(n)
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new dt;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        this._inputGeom = t, this._distance = e, this._curveBuilder = n
                    }
                }]), e
            }(), Xn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "locate", value: function (t) {
                    }
                }]), e
            }(), jn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "next", value: function () {
                        if (this._atStart) return this._atStart = !1, e.isAtomic(this._parent) && this._index++, this._parent;
                        if (null !== this._subcollectionIterator) {
                            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
                            this._subcollectionIterator = null
                        }
                        if (this._index >= this._max) throw new W;
                        var t = this._parent.getGeometryN(this._index++);
                        return t instanceof Bt ? (this._subcollectionIterator = new e(t), this._subcollectionIterator.next()) : t
                    }
                }, {
                    key: "remove", value: function () {
                        throw new J(this.getClass().getName())
                    }
                }, {
                    key: "hasNext", value: function () {
                        if (this._atStart) return !0;
                        if (null !== this._subcollectionIterator) {
                            if (this._subcollectionIterator.hasNext()) return !0;
                            this._subcollectionIterator = null
                        }
                        return !(this._index >= this._max)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [mn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
                        var t = arguments[0];
                        this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries()
                    }
                }, {
                    key: "isAtomic", value: function (t) {
                        return !(t instanceof Bt)
                    }
                }]), e
            }(), Un = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "locate", value: function (t) {
                        return e.locate(t, this._geom)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Xn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._geom = null;
                        var t = arguments[0];
                        this._geom = t
                    }
                }, {
                    key: "locatePointInPolygon", value: function (t, n) {
                        if (n.isEmpty()) return Z.EXTERIOR;
                        var r = n.getExteriorRing(), i = e.locatePointInRing(t, r);
                        if (i !== Z.INTERIOR) return i;
                        for (var o = 0; o < n.getNumInteriorRing(); o++) {
                            var s = n.getInteriorRingN(o), a = e.locatePointInRing(t, s);
                            if (a === Z.BOUNDARY) return Z.BOUNDARY;
                            if (a === Z.INTERIOR) return Z.EXTERIOR
                        }
                        return Z.INTERIOR
                    }
                }, {
                    key: "locatePointInRing", value: function (t, e) {
                        return e.getEnvelopeInternal().intersects(t) ? Oe.locateInRing(t, e.getCoordinates()) : Z.EXTERIOR
                    }
                }, {
                    key: "containsPointInPolygon", value: function (t, n) {
                        return Z.EXTERIOR !== e.locatePointInPolygon(t, n)
                    }
                }, {
                    key: "locateInGeometry", value: function (t, n) {
                        if (n instanceof Ft) return e.locatePointInPolygon(t, n);
                        if (n instanceof Bt) for (var r = new jn(n); r.hasNext();) {
                            var i = r.next();
                            if (i !== n) {
                                var o = e.locateInGeometry(t, i);
                                if (o !== Z.EXTERIOR) return o
                            }
                        }
                        return Z.EXTERIOR
                    }
                }, {
                    key: "isContained", value: function (t, n) {
                        return Z.EXTERIOR !== e.locate(t, n)
                    }
                }, {
                    key: "locate", value: function (t, n) {
                        return n.isEmpty() ? Z.EXTERIOR : n.getEnvelopeInternal().intersects(t) ? e.locateInGeometry(t, n) : Z.EXTERIOR
                    }
                }]), e
            }(), Vn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getNextCW", value: function (t) {
                        this.getEdges();
                        var e = this._edgeList.indexOf(t), n = e - 1;
                        return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n)
                    }
                }, {
                    key: "propagateSideLabels", value: function (t) {
                        for (var e = Z.NONE, n = this.iterator(); n.hasNext();) {
                            var r = n.next().getLabel();
                            r.isArea(t) && r.getLocation(t, tt.LEFT) !== Z.NONE && (e = r.getLocation(t, tt.LEFT))
                        }
                        if (e === Z.NONE) return null;
                        for (var i = e, o = this.iterator(); o.hasNext();) {
                            var s = o.next(), a = s.getLabel();
                            if (a.getLocation(t, tt.ON) === Z.NONE && a.setLocation(t, tt.ON, i), a.isArea(t)) {
                                var u = a.getLocation(t, tt.LEFT), l = a.getLocation(t, tt.RIGHT);
                                if (l !== Z.NONE) {
                                    if (l !== i) throw new pt("side location conflict", s.getCoordinate());
                                    u === Z.NONE && G.shouldNeverReachHere("found single null side (at " + s.getCoordinate() + ")"), i = u
                                } else G.isTrue(a.getLocation(t, tt.LEFT) === Z.NONE, "found single null side"), a.setLocation(t, tt.RIGHT, i), a.setLocation(t, tt.LEFT, i)
                            }
                        }
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        var t = this.iterator();
                        return t.hasNext() ? t.next().getCoordinate() : null
                    }
                }, {
                    key: "print", value: function (t) {
                        xt.out.println("EdgeEndStar:   " + this.getCoordinate());
                        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                    }
                }, {
                    key: "isAreaLabelsConsistent", value: function (t) {
                        return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
                    }
                }, {
                    key: "checkAreaLabelsConsistent", value: function (t) {
                        var e = this.getEdges();
                        if (e.size() <= 0) return !0;
                        var n = e.size() - 1, r = e.get(n).getLabel().getLocation(t, tt.LEFT);
                        G.isTrue(r !== Z.NONE, "Found unlabelled area edge");
                        for (var i = r, o = this.iterator(); o.hasNext();) {
                            var s = o.next().getLabel();
                            G.isTrue(s.isArea(t), "Found non-area edge");
                            var a = s.getLocation(t, tt.LEFT), u = s.getLocation(t, tt.RIGHT);
                            if (a === u) return !1;
                            if (u !== i) return !1;
                            i = a
                        }
                        return !0
                    }
                }, {
                    key: "findIndex", value: function (t) {
                        this.iterator();
                        for (var e = 0; e < this._edgeList.size(); e++) if (this._edgeList.get(e) === t) return e;
                        return -1
                    }
                }, {
                    key: "iterator", value: function () {
                        return this.getEdges().iterator()
                    }
                }, {
                    key: "getEdges", value: function () {
                        return null === this._edgeList && (this._edgeList = new dt(this._edgeMap.values())), this._edgeList
                    }
                }, {
                    key: "getLocation", value: function (t, e, n) {
                        return this._ptInAreaLocation[t] === Z.NONE && (this._ptInAreaLocation[t] = Un.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t]
                    }
                }, {
                    key: "toString", value: function () {
                        var t = new st;
                        t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");
                        for (var e = this.iterator(); e.hasNext();) {
                            var n = e.next();
                            t.append(n), t.append("\n")
                        }
                        return t.toString()
                    }
                }, {
                    key: "computeEdgeEndLabels", value: function (t) {
                        for (var e = this.iterator(); e.hasNext();) e.next().computeLabel(t)
                    }
                }, {
                    key: "computeLabelling", value: function (t) {
                        this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
                        for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var r = n.next().getLabel(), i = 0; i < 2; i++) r.isLine(i) && r.getLocation(i) === Z.BOUNDARY && (e[i] = !0);
                        for (var o = this.iterator(); o.hasNext();) for (var s = o.next(), a = s.getLabel(), u = 0; u < 2; u++) if (a.isAnyNull(u)) {
                            var l = Z.NONE;
                            if (e[u]) l = Z.EXTERIOR; else {
                                var h = s.getCoordinate();
                                l = this.getLocation(u, h, t)
                            }
                            a.setAllLocationsIfNull(u, l)
                        }
                    }
                }, {
                    key: "getDegree", value: function () {
                        return this._edgeMap.size()
                    }
                }, {
                    key: "insertEdgeEnd", value: function (t, e) {
                        this._edgeMap.put(t, e), this._edgeList = null
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._edgeMap = new He, this._edgeList = null, this._ptInAreaLocation = [Z.NONE, Z.NONE]
                    }
                }]), e
            }(), Zn = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "linkResultDirectedEdges", value: function () {
                        this.getResultAreaEdges();
                        for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, r = 0; r < this._resultAreaEdgeList.size(); r++) {
                            var i = this._resultAreaEdgeList.get(r), o = i.getSym();
                            if (i.getLabel().isArea()) switch (null === t && i.isInResult() && (t = i), n) {
                                case this._SCANNING_FOR_INCOMING:
                                    if (!o.isInResult()) continue;
                                    e = o, n = this._LINKING_TO_OUTGOING;
                                    break;
                                case this._LINKING_TO_OUTGOING:
                                    if (!i.isInResult()) continue;
                                    e.setNext(i), n = this._SCANNING_FOR_INCOMING
                            }
                        }
                        if (n === this._LINKING_TO_OUTGOING) {
                            if (null === t) throw new pt("no outgoing dirEdge found", this.getCoordinate());
                            G.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
                        }
                    }
                }, {
                    key: "insert", value: function (t) {
                        var e = t;
                        this.insertEdgeEnd(e, e)
                    }
                }, {
                    key: "getRightmostEdge", value: function () {
                        var t = this.getEdges(), e = t.size();
                        if (e < 1) return null;
                        var n = t.get(0);
                        if (1 === e) return n;
                        var r = t.get(e - 1), i = n.getQuadrant(), o = r.getQuadrant();
                        return Je.isNorthern(i) && Je.isNorthern(o) ? n : Je.isNorthern(i) || Je.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== r.getDy() ? r : (G.shouldNeverReachHere("found two horizontal edges incident on node"), null) : r
                    }
                }, {
                    key: "print", value: function (t) {
                        xt.out.println("DirectedEdgeStar: " + this.getCoordinate());
                        for (var e = this.iterator(); e.hasNext();) {
                            var n = e.next();
                            t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println()
                        }
                    }
                }, {
                    key: "getResultAreaEdges", value: function () {
                        if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
                        this._resultAreaEdgeList = new dt;
                        for (var t = this.iterator(); t.hasNext();) {
                            var e = t.next();
                            (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e)
                        }
                        return this._resultAreaEdgeList
                    }
                }, {
                    key: "updateLabelling", value: function (t) {
                        for (var e = this.iterator(); e.hasNext();) {
                            var n = e.next().getLabel();
                            n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1))
                        }
                    }
                }, {
                    key: "linkAllDirectedEdges", value: function () {
                        this.getEdges();
                        for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {
                            var r = this._edgeList.get(n), i = r.getSym();
                            null === e && (e = i), null !== t && i.setNext(t), t = r
                        }
                        e.setNext(t)
                    }
                }, {
                    key: "computeDepths", value: function () {
                        if (1 === arguments.length) {
                            var t = arguments[0], e = this.findIndex(t), n = t.getDepth(tt.LEFT),
                                r = t.getDepth(tt.RIGHT), i = this.computeDepths(e + 1, this._edgeList.size(), n);
                            if (this.computeDepths(0, e, i) !== r) throw new pt("depth mismatch at " + t.getCoordinate())
                        } else if (3 === arguments.length) {
                            for (var o = arguments[1], s = arguments[2], a = arguments[0]; a < o; a++) {
                                var u = this._edgeList.get(a);
                                u.setEdgeDepths(tt.RIGHT, s), s = u.getDepth(tt.LEFT)
                            }
                            return s
                        }
                    }
                }, {
                    key: "mergeSymLabels", value: function () {
                        for (var t = this.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getLabel().merge(e.getSym().getLabel())
                        }
                    }
                }, {
                    key: "linkMinimalDirectedEdges", value: function (t) {
                        for (var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
                            var o = this._resultAreaEdgeList.get(i), s = o.getSym();
                            switch (null === e && o.getEdgeRing() === t && (e = o), r) {
                                case this._SCANNING_FOR_INCOMING:
                                    if (s.getEdgeRing() !== t) continue;
                                    n = s, r = this._LINKING_TO_OUTGOING;
                                    break;
                                case this._LINKING_TO_OUTGOING:
                                    if (o.getEdgeRing() !== t) continue;
                                    n.setNextMin(o), r = this._SCANNING_FOR_INCOMING
                            }
                        }
                        r === this._LINKING_TO_OUTGOING && (G.isTrue(null !== e, "found null for first outgoing dirEdge"), G.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e))
                    }
                }, {
                    key: "getOutgoingDegree", value: function () {
                        if (0 === arguments.length) {
                            for (var t = 0, e = this.iterator(); e.hasNext();) e.next().isInResult() && t++;
                            return t
                        }
                        if (1 === arguments.length) {
                            for (var n = arguments[0], r = 0, i = this.iterator(); i.hasNext();) i.next().getEdgeRing() === n && r++;
                            return r
                        }
                    }
                }, {
                    key: "getLabel", value: function () {
                        return this._label
                    }
                }, {
                    key: "findCoveredLineEdges", value: function () {
                        for (var t = Z.NONE, e = this.iterator(); e.hasNext();) {
                            var n = e.next(), r = n.getSym();
                            if (!n.isLineEdge()) {
                                if (n.isInResult()) {
                                    t = Z.INTERIOR;
                                    break
                                }
                                if (r.isInResult()) {
                                    t = Z.EXTERIOR;
                                    break
                                }
                            }
                        }
                        if (t === Z.NONE) return null;
                        for (var i = t, o = this.iterator(); o.hasNext();) {
                            var s = o.next(), a = s.getSym();
                            s.isLineEdge() ? s.getEdge().setCovered(i === Z.INTERIOR) : (s.isInResult() && (i = Z.EXTERIOR), a.isInResult() && (i = Z.INTERIOR))
                        }
                    }
                }, {
                    key: "computeLabelling", value: function (t) {
                        g(o(s.prototype), "computeLabelling", this).call(this, t), this._label = new De(Z.NONE);
                        for (var e = this.iterator(); e.hasNext();) for (var n = e.next().getEdge().getLabel(), r = 0; r < 2; r++) {
                            var i = n.getLocation(r);
                            i !== Z.INTERIOR && i !== Z.BOUNDARY || this._label.setLocation(r, Z.INTERIOR)
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2
                    }
                }]), s
            }(Vn), Hn = function (e) {
                i(o, e);
                var n = f(o);

                function o() {
                    return t(this, o), n.call(this)
                }

                return r(o, [{
                    key: "createNode", value: function (t) {
                        return new Be(t, new Zn)
                    }
                }]), o
            }($e), Wn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "compareTo", value: function (t) {
                        var n = t;
                        return e.compareOriented(this._pts, this._orientation, n._pts, n._orientation)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._pts = null, this._orientation = null;
                        var t = arguments[0];
                        this._pts = t, this._orientation = e.orientation(t)
                    }
                }, {
                    key: "orientation", value: function (t) {
                        return 1 === Wt.increasingDirection(t)
                    }
                }, {
                    key: "compareOriented", value: function (t, e, n, r) {
                        for (var i = e ? 1 : -1, o = r ? 1 : -1, s = e ? t.length : -1, a = r ? n.length : -1, u = e ? 0 : t.length - 1, l = r ? 0 : n.length - 1; ;) {
                            var h = t[u].compareTo(n[l]);
                            if (0 !== h) return h;
                            var c = (u += i) === s, f = (l += o) === a;
                            if (c && !f) return -1;
                            if (!c && f) return 1;
                            if (c && f) return 0
                        }
                    }
                }]), e
            }(), Jn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "print", value: function (t) {
                        t.print("MULTILINESTRING ( ");
                        for (var e = 0; e < this._edges.size(); e++) {
                            var n = this._edges.get(e);
                            e > 0 && t.print(","), t.print("(");
                            for (var r = n.getCoordinates(), i = 0; i < r.length; i++) i > 0 && t.print(","), t.print(r[i].x + " " + r[i].y);
                            t.println(")")
                        }
                        t.print(")  ")
                    }
                }, {
                    key: "addAll", value: function (t) {
                        for (var e = t.iterator(); e.hasNext();) this.add(e.next())
                    }
                }, {
                    key: "findEdgeIndex", value: function (t) {
                        for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;
                        return -1
                    }
                }, {
                    key: "iterator", value: function () {
                        return this._edges.iterator()
                    }
                }, {
                    key: "getEdges", value: function () {
                        return this._edges
                    }
                }, {
                    key: "get", value: function (t) {
                        return this._edges.get(t)
                    }
                }, {
                    key: "findEqualEdge", value: function (t) {
                        var e = new Wn(t.getCoordinates());
                        return this._ocaMap.get(e)
                    }
                }, {
                    key: "add", value: function (t) {
                        this._edges.add(t);
                        var e = new Wn(t.getCoordinates());
                        this._ocaMap.put(e, t)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._edges = new dt, this._ocaMap = new He
                    }
                }]), e
            }(), Qn = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "processIntersections", value: function (t, e, n, r) {
                    }
                }, {
                    key: "isDone", value: function () {
                    }
                }]), e
            }(), Kn = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "isTrivialIntersection", value: function (t, n, r, i) {
                        if (t === r && 1 === this._li.getIntersectionNum()) {
                            if (e.isAdjacentSegments(n, i)) return !0;
                            if (t.isClosed()) {
                                var o = t.size() - 1;
                                if (0 === n && i === o || 0 === i && n === o) return !0
                            }
                        }
                        return !1
                    }
                }, {
                    key: "getProperIntersectionPoint", value: function () {
                        return this._properIntersectionPoint
                    }
                }, {
                    key: "hasProperInteriorIntersection", value: function () {
                        return this._hasProperInterior
                    }
                }, {
                    key: "getLineIntersector", value: function () {
                        return this._li
                    }
                }, {
                    key: "hasProperIntersection", value: function () {
                        return this._hasProper
                    }
                }, {
                    key: "processIntersections", value: function (t, e, n, r) {
                        if (t === n && e === r) return null;
                        this.numTests++;
                        var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], s = n.getCoordinates()[r],
                            a = n.getCoordinates()[r + 1];
                        this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)))
                    }
                }, {
                    key: "hasIntersection", value: function () {
                        return this._hasIntersection
                    }
                }, {
                    key: "isDone", value: function () {
                        return !1
                    }
                }, {
                    key: "hasInteriorIntersection", value: function () {
                        return this._hasInterior
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Qn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
                        var t = arguments[0];
                        this._li = t
                    }
                }, {
                    key: "isAdjacentSegments", value: function (t, e) {
                        return 1 === Math.abs(t - e)
                    }
                }]), e
            }(), $n = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getSegmentIndex", value: function () {
                        return this.segmentIndex
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this.coord
                    }
                }, {
                    key: "print", value: function (t) {
                        t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist)
                    }
                }, {
                    key: "compareTo", value: function (t) {
                        var e = t;
                        return this.compare(e.segmentIndex, e.dist)
                    }
                }, {
                    key: "isEndPoint", value: function (t) {
                        return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
                    }
                }, {
                    key: "toString", value: function () {
                        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
                    }
                }, {
                    key: "getDistance", value: function () {
                        return this.dist
                    }
                }, {
                    key: "compare", value: function (t, e) {
                        return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [k]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this.coord = null, this.segmentIndex = null, this.dist = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        this.coord = new X(t), this.segmentIndex = e, this.dist = n
                    }
                }]), e
            }(), tr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "print", value: function (t) {
                        t.println("Intersections:");
                        for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                    }
                }, {
                    key: "iterator", value: function () {
                        return this._nodeMap.values().iterator()
                    }
                }, {
                    key: "addSplitEdges", value: function (t) {
                        this.addEndpoints();
                        for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                            var r = e.next(), i = this.createSplitEdge(n, r);
                            t.add(i), n = r
                        }
                    }
                }, {
                    key: "addEndpoints", value: function () {
                        var t = this.edge.pts.length - 1;
                        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
                    }
                }, {
                    key: "createSplitEdge", value: function (t, e) {
                        var n = e.segmentIndex - t.segmentIndex + 2, r = this.edge.pts[e.segmentIndex],
                            i = e.dist > 0 || !e.coord.equals2D(r);
                        i || n--;
                        var o = new Array(n).fill(null), s = 0;
                        o[s++] = new X(t.coord);
                        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];
                        return i && (o[s] = e.coord), new sr(o, new De(this.edge._label))
                    }
                }, {
                    key: "add", value: function (t, e, n) {
                        var r = new $n(t, e, n), i = this._nodeMap.get(r);
                        return null !== i ? i : (this._nodeMap.put(r, r), r)
                    }
                }, {
                    key: "isIntersection", value: function (t) {
                        for (var e = this.iterator(); e.hasNext();) if (e.next().coord.equals(t)) return !0;
                        return !1
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._nodeMap = new He, this.edge = null;
                        var t = arguments[0];
                        this.edge = t
                    }
                }]), e
            }(), er = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "isIntersects", value: function () {
                        return !this.isDisjoint()
                    }
                }, {
                    key: "isCovers", value: function () {
                        return (e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) || e.isTrue(this._matrix[Z.INTERIOR][Z.BOUNDARY]) || e.isTrue(this._matrix[Z.BOUNDARY][Z.INTERIOR]) || e.isTrue(this._matrix[Z.BOUNDARY][Z.BOUNDARY])) && this._matrix[Z.EXTERIOR][Z.INTERIOR] === Mt.FALSE && this._matrix[Z.EXTERIOR][Z.BOUNDARY] === Mt.FALSE
                    }
                }, {
                    key: "isCoveredBy", value: function () {
                        return (e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) || e.isTrue(this._matrix[Z.INTERIOR][Z.BOUNDARY]) || e.isTrue(this._matrix[Z.BOUNDARY][Z.INTERIOR]) || e.isTrue(this._matrix[Z.BOUNDARY][Z.BOUNDARY])) && this._matrix[Z.INTERIOR][Z.EXTERIOR] === Mt.FALSE && this._matrix[Z.BOUNDARY][Z.EXTERIOR] === Mt.FALSE
                    }
                }, {
                    key: "set", value: function () {
                        if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
                            var n = Math.trunc(e / 3), r = e % 3;
                            this._matrix[n][r] = Mt.toDimensionValue(t.charAt(e))
                        } else if (3 === arguments.length) {
                            var i = arguments[0], o = arguments[1], s = arguments[2];
                            this._matrix[i][o] = s
                        }
                    }
                }, {
                    key: "isContains", value: function () {
                        return e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) && this._matrix[Z.EXTERIOR][Z.INTERIOR] === Mt.FALSE && this._matrix[Z.EXTERIOR][Z.BOUNDARY] === Mt.FALSE
                    }
                }, {
                    key: "setAtLeast", value: function () {
                        if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
                            var n = Math.trunc(e / 3), r = e % 3;
                            this.setAtLeast(n, r, Mt.toDimensionValue(t.charAt(e)))
                        } else if (3 === arguments.length) {
                            var i = arguments[0], o = arguments[1], s = arguments[2];
                            this._matrix[i][o] < s && (this._matrix[i][o] = s)
                        }
                    }
                }, {
                    key: "setAtLeastIfValid", value: function (t, e, n) {
                        t >= 0 && e >= 0 && this.setAtLeast(t, e, n)
                    }
                }, {
                    key: "isWithin", value: function () {
                        return e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) && this._matrix[Z.INTERIOR][Z.EXTERIOR] === Mt.FALSE && this._matrix[Z.BOUNDARY][Z.EXTERIOR] === Mt.FALSE
                    }
                }, {
                    key: "isTouches", value: function (t, n) {
                        return t > n ? this.isTouches(n, t) : (t === Mt.A && n === Mt.A || t === Mt.L && n === Mt.L || t === Mt.L && n === Mt.A || t === Mt.P && n === Mt.A || t === Mt.P && n === Mt.L) && this._matrix[Z.INTERIOR][Z.INTERIOR] === Mt.FALSE && (e.isTrue(this._matrix[Z.INTERIOR][Z.BOUNDARY]) || e.isTrue(this._matrix[Z.BOUNDARY][Z.INTERIOR]) || e.isTrue(this._matrix[Z.BOUNDARY][Z.BOUNDARY]))
                    }
                }, {
                    key: "isOverlaps", value: function (t, n) {
                        return t === Mt.P && n === Mt.P || t === Mt.A && n === Mt.A ? e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) && e.isTrue(this._matrix[Z.INTERIOR][Z.EXTERIOR]) && e.isTrue(this._matrix[Z.EXTERIOR][Z.INTERIOR]) : t === Mt.L && n === Mt.L && 1 === this._matrix[Z.INTERIOR][Z.INTERIOR] && e.isTrue(this._matrix[Z.INTERIOR][Z.EXTERIOR]) && e.isTrue(this._matrix[Z.EXTERIOR][Z.INTERIOR])
                    }
                }, {
                    key: "isEquals", value: function (t, n) {
                        return t === n && e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) && this._matrix[Z.INTERIOR][Z.EXTERIOR] === Mt.FALSE && this._matrix[Z.BOUNDARY][Z.EXTERIOR] === Mt.FALSE && this._matrix[Z.EXTERIOR][Z.INTERIOR] === Mt.FALSE && this._matrix[Z.EXTERIOR][Z.BOUNDARY] === Mt.FALSE
                    }
                }, {
                    key: "toString", value: function () {
                        for (var t = new Kt("123456789"), e = 0; e < 3; e++) for (var n = 0; n < 3; n++) t.setCharAt(3 * e + n, Mt.toDimensionSymbol(this._matrix[e][n]));
                        return t.toString()
                    }
                }, {
                    key: "setAll", value: function (t) {
                        for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this._matrix[e][n] = t
                    }
                }, {
                    key: "get", value: function (t, e) {
                        return this._matrix[t][e]
                    }
                }, {
                    key: "transpose", value: function () {
                        var t = this._matrix[1][0];
                        return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this
                    }
                }, {
                    key: "matches", value: function (t) {
                        if (9 !== t.length) throw new x("Should be length 9: " + t);
                        for (var n = 0; n < 3; n++) for (var r = 0; r < 3; r++) if (!e.matches(this._matrix[n][r], t.charAt(3 * n + r))) return !1;
                        return !0
                    }
                }, {
                    key: "add", value: function (t) {
                        for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n))
                    }
                }, {
                    key: "isDisjoint", value: function () {
                        return this._matrix[Z.INTERIOR][Z.INTERIOR] === Mt.FALSE && this._matrix[Z.INTERIOR][Z.BOUNDARY] === Mt.FALSE && this._matrix[Z.BOUNDARY][Z.INTERIOR] === Mt.FALSE && this._matrix[Z.BOUNDARY][Z.BOUNDARY] === Mt.FALSE
                    }
                }, {
                    key: "isCrosses", value: function (t, n) {
                        return t === Mt.P && n === Mt.L || t === Mt.P && n === Mt.A || t === Mt.L && n === Mt.A ? e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) && e.isTrue(this._matrix[Z.INTERIOR][Z.EXTERIOR]) : t === Mt.L && n === Mt.P || t === Mt.A && n === Mt.P || t === Mt.A && n === Mt.L ? e.isTrue(this._matrix[Z.INTERIOR][Z.INTERIOR]) && e.isTrue(this._matrix[Z.EXTERIOR][Z.INTERIOR]) : t === Mt.L && n === Mt.L && 0 === this._matrix[Z.INTERIOR][Z.INTERIOR]
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [w]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map((function () {
                            return Array(3)
                        })), this.setAll(Mt.FALSE); else if (1 === arguments.length) if ("string" == typeof arguments[0]) {
                            var t = arguments[0];
                            e.constructor_.call(this), this.set(t)
                        } else if (arguments[0] instanceof e) {
                            var n = arguments[0];
                            e.constructor_.call(this), this._matrix[Z.INTERIOR][Z.INTERIOR] = n._matrix[Z.INTERIOR][Z.INTERIOR], this._matrix[Z.INTERIOR][Z.BOUNDARY] = n._matrix[Z.INTERIOR][Z.BOUNDARY], this._matrix[Z.INTERIOR][Z.EXTERIOR] = n._matrix[Z.INTERIOR][Z.EXTERIOR], this._matrix[Z.BOUNDARY][Z.INTERIOR] = n._matrix[Z.BOUNDARY][Z.INTERIOR], this._matrix[Z.BOUNDARY][Z.BOUNDARY] = n._matrix[Z.BOUNDARY][Z.BOUNDARY], this._matrix[Z.BOUNDARY][Z.EXTERIOR] = n._matrix[Z.BOUNDARY][Z.EXTERIOR], this._matrix[Z.EXTERIOR][Z.INTERIOR] = n._matrix[Z.EXTERIOR][Z.INTERIOR], this._matrix[Z.EXTERIOR][Z.BOUNDARY] = n._matrix[Z.EXTERIOR][Z.BOUNDARY], this._matrix[Z.EXTERIOR][Z.EXTERIOR] = n._matrix[Z.EXTERIOR][Z.EXTERIOR]
                        }
                    }
                }, {
                    key: "matches", value: function () {
                        if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
                            var t = arguments[0], n = arguments[1];
                            return n === Mt.SYM_DONTCARE || n === Mt.SYM_TRUE && (t >= 0 || t === Mt.TRUE) || n === Mt.SYM_FALSE && t === Mt.FALSE || n === Mt.SYM_P && t === Mt.P || n === Mt.SYM_L && t === Mt.L || n === Mt.SYM_A && t === Mt.A
                        }
                        if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
                            var r = arguments[1];
                            return new e(arguments[0]).matches(r)
                        }
                    }
                }, {
                    key: "isTrue", value: function (t) {
                        return t >= 0 || t === Mt.TRUE
                    }
                }]), e
            }(), nr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "size", value: function () {
                        return this._size
                    }
                }, {
                    key: "addAll", value: function (t) {
                        return null === t || 0 === t.length ? null : (this.ensureCapacity(this._size + t.length), xt.arraycopy(t, 0, this._data, this._size, t.length), void (this._size += t.length))
                    }
                }, {
                    key: "ensureCapacity", value: function (t) {
                        if (t <= this._data.length) return null;
                        var e = Math.max(t, 2 * this._data.length);
                        this._data = At.copyOf(this._data, e)
                    }
                }, {
                    key: "toArray", value: function () {
                        var t = new Array(this._size).fill(null);
                        return xt.arraycopy(this._data, 0, t, 0, this._size), t
                    }
                }, {
                    key: "add", value: function (t) {
                        this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._data = null, this._size = 0, 0 === arguments.length) e.constructor_.call(this, 10); else if (1 === arguments.length) {
                            var t = arguments[0];
                            this._data = new Array(t).fill(null)
                        }
                    }
                }]), e
            }(), rr = function () {
                function e() {
                    t(this, e)
                }

                return r(e, [{
                    key: "getChainStartIndices", value: function (t) {
                        var e = 0, n = new nr(Math.trunc(t.length / 2));
                        n.add(e);
                        do {
                            var r = this.findChainEnd(t, e);
                            n.add(r), e = r
                        } while (e < t.length - 1);
                        return n.toArray()
                    }
                }, {
                    key: "findChainEnd", value: function (t, e) {
                        for (var n = Je.quadrant(t[e], t[e + 1]), r = e + 1; r < t.length && Je.quadrant(t[r - 1], t[r]) === n;) r++;
                        return r - 1
                    }
                }, {
                    key: "OLDgetChainStartIndices", value: function (t) {
                        var n = 0, r = new dt;
                        r.add(n);
                        do {
                            var i = this.findChainEnd(t, n);
                            r.add(i), n = i
                        } while (n < t.length - 1);
                        return e.toIntArray(r)
                    }
                }], [{
                    key: "toIntArray", value: function (t) {
                        for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
                        return e
                    }
                }]), e
            }(), ir = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getCoordinates", value: function () {
                        return this.pts
                    }
                }, {
                    key: "getMaxX", value: function (t) {
                        var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
                        return e > n ? e : n
                    }
                }, {
                    key: "getMinX", value: function (t) {
                        var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
                        return e < n ? e : n
                    }
                }, {
                    key: "computeIntersectsForChain", value: function () {
                        if (4 === arguments.length) {
                            var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3];
                            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], r)
                        } else if (6 === arguments.length) {
                            var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3],
                                u = arguments[4], l = arguments[5];
                            if (o - i == 1 && u - a == 1) return l.addIntersections(this.e, i, s.e, a), null;
                            if (!this.overlaps(i, o, s, a, u)) return null;
                            var h = Math.trunc((i + o) / 2), c = Math.trunc((a + u) / 2);
                            i < h && (a < c && this.computeIntersectsForChain(i, h, s, a, c, l), c < u && this.computeIntersectsForChain(i, h, s, c, u, l)), h < o && (a < c && this.computeIntersectsForChain(h, o, s, a, c, l), c < u && this.computeIntersectsForChain(h, o, s, c, u, l))
                        }
                    }
                }, {
                    key: "overlaps", value: function (t, e, n, r, i) {
                        return U.intersects(this.pts[t], this.pts[e], n.pts[r], n.pts[i])
                    }
                }, {
                    key: "getStartIndexes", value: function () {
                        return this.startIndex
                    }
                }, {
                    key: "computeIntersects", value: function (t, e) {
                        for (var n = 0; n < this.startIndex.length - 1; n++) for (var r = 0; r < t.startIndex.length - 1; r++) this.computeIntersectsForChain(n, t, r, e)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this.e = null, this.pts = null, this.startIndex = null;
                        var t = arguments[0];
                        this.e = t, this.pts = t.getCoordinates();
                        var e = new rr;
                        this.startIndex = e.getChainStartIndices(this.pts)
                    }
                }]), e
            }(), or = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "getDepth", value: function (t, e) {
                        return this._depth[t][e]
                    }
                }, {
                    key: "setDepth", value: function (t, e, n) {
                        this._depth[t][e] = n
                    }
                }, {
                    key: "isNull", value: function () {
                        if (0 === arguments.length) {
                            for (var t = 0; t < 2; t++) for (var n = 0; n < 3; n++) if (this._depth[t][n] !== e.NULL_VALUE) return !1;
                            return !0
                        }
                        if (1 === arguments.length) {
                            var r = arguments[0];
                            return this._depth[r][1] === e.NULL_VALUE
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0], o = arguments[1];
                            return this._depth[i][o] === e.NULL_VALUE
                        }
                    }
                }, {
                    key: "normalize", value: function () {
                        for (var t = 0; t < 2; t++) if (!this.isNull(t)) {
                            var e = this._depth[t][1];
                            this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);
                            for (var n = 1; n < 3; n++) {
                                var r = 0;
                                this._depth[t][n] > e && (r = 1), this._depth[t][n] = r
                            }
                        }
                    }
                }, {
                    key: "getDelta", value: function (t) {
                        return this._depth[t][tt.RIGHT] - this._depth[t][tt.LEFT]
                    }
                }, {
                    key: "getLocation", value: function (t, e) {
                        return this._depth[t][e] <= 0 ? Z.EXTERIOR : Z.INTERIOR
                    }
                }, {
                    key: "toString", value: function () {
                        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2]
                    }
                }, {
                    key: "add", value: function () {
                        if (1 === arguments.length) for (var t = arguments[0], n = 0; n < 2; n++) for (var r = 1; r < 3; r++) {
                            var i = t.getLocation(n, r);
                            i !== Z.EXTERIOR && i !== Z.INTERIOR || (this.isNull(n, r) ? this._depth[n][r] = e.depthAtLocation(i) : this._depth[n][r] += e.depthAtLocation(i))
                        } else if (3 === arguments.length) {
                            var o = arguments[0], s = arguments[1];
                            arguments[2] === Z.INTERIOR && this._depth[o][s]++
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._depth = Array(2).fill().map((function () {
                            return Array(3)
                        }));
                        for (var t = 0; t < 2; t++) for (var n = 0; n < 3; n++) this._depth[t][n] = e.NULL_VALUE
                    }
                }, {
                    key: "depthAtLocation", value: function (t) {
                        return t === Z.EXTERIOR ? 0 : t === Z.INTERIOR ? 1 : e.NULL_VALUE
                    }
                }]), e
            }();
            or.NULL_VALUE = -1;
            var sr = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "getDepth", value: function () {
                        return this._depth
                    }
                }, {
                    key: "getCollapsedEdge", value: function () {
                        var t = new Array(2).fill(null);
                        return t[0] = this.pts[0], t[1] = this.pts[1], new s(t, De.toLineLabel(this._label))
                    }
                }, {
                    key: "isIsolated", value: function () {
                        return this._isIsolated
                    }
                }, {
                    key: "getCoordinates", value: function () {
                        return this.pts
                    }
                }, {
                    key: "setIsolated", value: function (t) {
                        this._isIsolated = t
                    }
                }, {
                    key: "setName", value: function (t) {
                        this._name = t
                    }
                }, {
                    key: "equals", value: function (t) {
                        if (!(t instanceof s)) return !1;
                        var e = t;
                        if (this.pts.length !== e.pts.length) return !1;
                        for (var n = !0, r = !0, i = this.pts.length, o = 0; o < this.pts.length; o++) if (this.pts[o].equals2D(e.pts[o]) || (n = !1), this.pts[o].equals2D(e.pts[--i]) || (r = !1), !n && !r) return !1;
                        return !0
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.pts[t]
                        }
                    }
                }, {
                    key: "print", value: function (t) {
                        t.print("edge " + this._name + ": "), t.print("LINESTRING (");
                        for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
                        t.print(")  " + this._label + " " + this._depthDelta)
                    }
                }, {
                    key: "computeIM", value: function (t) {
                        s.updateIM(this._label, t)
                    }
                }, {
                    key: "isCollapsed", value: function () {
                        return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
                    }
                }, {
                    key: "isClosed", value: function () {
                        return this.pts[0].equals(this.pts[this.pts.length - 1])
                    }
                }, {
                    key: "getMaximumSegmentIndex", value: function () {
                        return this.pts.length - 1
                    }
                }, {
                    key: "getDepthDelta", value: function () {
                        return this._depthDelta
                    }
                }, {
                    key: "getNumPoints", value: function () {
                        return this.pts.length
                    }
                }, {
                    key: "printReverse", value: function (t) {
                        t.print("edge " + this._name + ": ");
                        for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");
                        t.println("")
                    }
                }, {
                    key: "getMonotoneChainEdge", value: function () {
                        return null === this._mce && (this._mce = new ir(this)), this._mce
                    }
                }, {
                    key: "getEnvelope", value: function () {
                        if (null === this._env) {
                            this._env = new U;
                            for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t])
                        }
                        return this._env
                    }
                }, {
                    key: "addIntersection", value: function (t, e, n, r) {
                        var i = new X(t.getIntersection(r)), o = e, s = t.getEdgeDistance(n, r), a = o + 1;
                        if (a < this.pts.length) {
                            var u = this.pts[a];
                            i.equals2D(u) && (o = a, s = 0)
                        }
                        this.eiList.add(i, o, s)
                    }
                }, {
                    key: "toString", value: function () {
                        var t = new Kt;
                        t.append("edge " + this._name + ": "), t.append("LINESTRING (");
                        for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
                        return t.append(")  " + this._label + " " + this._depthDelta), t.toString()
                    }
                }, {
                    key: "isPointwiseEqual", value: function (t) {
                        if (this.pts.length !== t.pts.length) return !1;
                        for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;
                        return !0
                    }
                }, {
                    key: "setDepthDelta", value: function (t) {
                        this._depthDelta = t
                    }
                }, {
                    key: "getEdgeIntersectionList", value: function () {
                        return this.eiList
                    }
                }, {
                    key: "addIntersections", value: function (t, e, n) {
                        for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this.pts = null, this._env = null, this.eiList = new tr(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new or, this._depthDelta = 0, 1 === arguments.length) {
                            var t = arguments[0];
                            s.constructor_.call(this, t, null)
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            this.pts = e, this._label = n
                        }
                    }
                }, {
                    key: "updateIM", value: function () {
                        if (!(2 === arguments.length && arguments[1] instanceof er && arguments[0] instanceof De)) return g(o(s), "updateIM", this).apply(this, arguments);
                        var t = arguments[0], e = arguments[1];
                        e.setAtLeastIfValid(t.getLocation(0, tt.ON), t.getLocation(1, tt.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, tt.LEFT), t.getLocation(1, tt.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, tt.RIGHT), t.getLocation(1, tt.RIGHT), 2))
                    }
                }]), s
            }(Ye), ar = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "setWorkingPrecisionModel", value: function (t) {
                        this._workingPrecisionModel = t
                    }
                }, {
                    key: "insertUniqueEdge", value: function (t) {
                        var n = this._edgeList.findEqualEdge(t);
                        if (null !== n) {
                            var r = n.getLabel(), i = t.getLabel();
                            n.isPointwiseEqual(t) || (i = new De(t.getLabel())).flip(), r.merge(i);
                            var o = e.depthDelta(i), s = n.getDepthDelta() + o;
                            n.setDepthDelta(s)
                        } else this._edgeList.add(t), t.setDepthDelta(e.depthDelta(t.getLabel()))
                    }
                }, {
                    key: "buildSubgraphs", value: function (t, e) {
                        for (var n = new dt, r = t.iterator(); r.hasNext();) {
                            var i = r.next(), o = i.getRightmostCoordinate(), s = new Fn(n).getDepth(o);
                            i.computeDepth(s), i.findResultEdges(), n.add(i), e.add(i.getDirectedEdges(), i.getNodes())
                        }
                    }
                }, {
                    key: "createSubgraphs", value: function (t) {
                        for (var e = new dt, n = t.getNodes().iterator(); n.hasNext();) {
                            var r = n.next();
                            if (!r.isVisited()) {
                                var i = new mt;
                                i.create(r), e.add(i)
                            }
                        }
                        return un.sort(e, un.reverseOrder()), e
                    }
                }, {
                    key: "createEmptyResultGeometry", value: function () {
                        return this._geomFact.createPolygon()
                    }
                }, {
                    key: "getNoder", value: function (t) {
                        if (null !== this._workingNoder) return this._workingNoder;
                        var e = new Ln, n = new Re;
                        return n.setPrecisionModel(t), e.setSegmentIntersector(new Kn(n)), e
                    }
                }, {
                    key: "buffer", value: function (t, e) {
                        var n = this._workingPrecisionModel;
                        null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
                        var r = new Dn(n, this._bufParams), i = new zn(t, e, r).getCurves();
                        if (i.size() <= 0) return this.createEmptyResultGeometry();
                        this.computeNodedEdges(i, n), this._graph = new tn(new Hn), this._graph.addEdges(this._edgeList.getEdges());
                        var o = this.createSubgraphs(this._graph), s = new en(this._geomFact);
                        this.buildSubgraphs(o, s);
                        var a = s.getPolygons();
                        return a.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(a)
                    }
                }, {
                    key: "computeNodedEdges", value: function (t, e) {
                        var n = this.getNoder(e);
                        n.computeNodes(t);
                        for (var r = n.getNodedSubstrings().iterator(); r.hasNext();) {
                            var i = r.next(), o = i.getCoordinates();
                            if (2 !== o.length || !o[0].equals2D(o[1])) {
                                var s = i.getData(), a = new sr(i.getCoordinates(), new De(s));
                                this.insertUniqueEdge(a)
                            }
                        }
                    }
                }, {
                    key: "setNoder", value: function (t) {
                        this._workingNoder = t
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Jn;
                        var t = arguments[0];
                        this._bufParams = t
                    }
                }, {
                    key: "depthDelta", value: function (t) {
                        var e = t.getLocation(0, tt.LEFT), n = t.getLocation(0, tt.RIGHT);
                        return e === Z.INTERIOR && n === Z.EXTERIOR ? 1 : e === Z.EXTERIOR && n === Z.INTERIOR ? -1 : 0
                    }
                }, {
                    key: "convertSegStrings", value: function (t) {
                        for (var e = new ae, n = new dt; t.hasNext();) {
                            var r = t.next(), i = e.createLineString(r.getCoordinates());
                            n.add(i)
                        }
                        return e.buildGeometry(n)
                    }
                }]), e
            }(), ur = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "rescale", value: function () {
                        if (ot(arguments[0], H)) for (var t = arguments[0].iterator(); t.hasNext();) {
                            var e = t.next();
                            this.rescale(e.getCoordinates())
                        } else if (arguments[0] instanceof Array) {
                            for (var n = arguments[0], r = 0; r < n.length; r++) n[r].x = n[r].x / this._scaleFactor + this._offsetX, n[r].y = n[r].y / this._scaleFactor + this._offsetY;
                            2 === n.length && n[0].equals2D(n[1]) && xt.out.println(n)
                        }
                    }
                }, {
                    key: "scale", value: function () {
                        if (ot(arguments[0], H)) {
                            for (var t = arguments[0], e = new dt(t.size()), n = t.iterator(); n.hasNext();) {
                                var r = n.next();
                                e.add(new wn(this.scale(r.getCoordinates()), r.getData()))
                            }
                            return e
                        }
                        if (arguments[0] instanceof Array) {
                            for (var i = arguments[0], o = new Array(i.length).fill(null), s = 0; s < i.length; s++) o[s] = new X(Math.round((i[s].x - this._offsetX) * this._scaleFactor), Math.round((i[s].y - this._offsetY) * this._scaleFactor), i[s].getZ());
                            return Wt.removeRepeatedPoints(o)
                        }
                    }
                }, {
                    key: "isIntegerPrecision", value: function () {
                        return 1 === this._scaleFactor
                    }
                }, {
                    key: "getNodedSubstrings", value: function () {
                        var t = this._noder.getNodedSubstrings();
                        return this._isScaled && this.rescale(t), t
                    }
                }, {
                    key: "computeNodes", value: function (t) {
                        var e = t;
                        this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e)
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Mn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {
                            var t = arguments[0], n = arguments[1];
                            e.constructor_.call(this, t, n, 0, 0)
                        } else if (4 === arguments.length) {
                            var r = arguments[0], i = arguments[1];
                            this._noder = r, this._scaleFactor = i, this._isScaled = !this.isIntegerPrecision()
                        }
                    }
                }]), e
            }(), lr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "checkEndPtVertexIntersections", value: function () {
                        if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {
                            var e = t.next().getCoordinates();
                            this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings)
                        } else if (2 === arguments.length) for (var n = arguments[0], r = arguments[1].iterator(); r.hasNext();) for (var i = r.next().getCoordinates(), o = 1; o < i.length - 1; o++) if (i[o].equals(n)) throw new F("found endpt/interior pt intersection at index " + o + " :pt " + n)
                    }
                }, {
                    key: "checkInteriorIntersections", value: function () {
                        if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {
                            var r = n.next();
                            this.checkInteriorIntersections(e, r)
                        } else if (2 === arguments.length) for (var i = arguments[0], o = arguments[1], s = i.getCoordinates(), a = o.getCoordinates(), u = 0; u < s.length - 1; u++) for (var l = 0; l < a.length - 1; l++) this.checkInteriorIntersections(i, u, o, l); else if (4 === arguments.length) {
                            var h = arguments[0], c = arguments[1], f = arguments[2], g = arguments[3];
                            if (h === f && c === g) return null;
                            var p = h.getCoordinates()[c], v = h.getCoordinates()[c + 1], d = f.getCoordinates()[g],
                                y = f.getCoordinates()[g + 1];
                            if (this._li.computeIntersection(p, v, d, y), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, p, v) || this.hasInteriorIntersection(this._li, d, y))) throw new F("found non-noded intersection at " + p + "-" + v + " and " + d + "-" + y)
                        }
                    }
                }, {
                    key: "checkValid", value: function () {
                        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses()
                    }
                }, {
                    key: "checkCollapses", value: function () {
                        if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {
                            var e = t.next();
                            this.checkCollapses(e)
                        } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), r = 0; r < n.length - 2; r++) this.checkCollapse(n[r], n[r + 1], n[r + 2])
                    }
                }, {
                    key: "hasInteriorIntersection", value: function (t, e, n) {
                        for (var r = 0; r < t.getIntersectionNum(); r++) {
                            var i = t.getIntersection(r);
                            if (!i.equals(e) && !i.equals(n)) return !0
                        }
                        return !1
                    }
                }, {
                    key: "checkCollapse", value: function (t, n, r) {
                        if (t.equals(r)) throw new F("found non-noded collapse at " + e.fact.createLineString([t, n, r]))
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._li = new Re, this._segStrings = null;
                        var t = arguments[0];
                        this._segStrings = t
                    }
                }]), e
            }();
            lr.fact = new ae;
            var hr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "intersectsScaled", value: function (t, e) {
                        var n = Math.min(t.x, e.x), r = Math.max(t.x, e.x), i = Math.min(t.y, e.y),
                            o = Math.max(t.y, e.y),
                            s = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o;
                        if (s) return !1;
                        var a = this.intersectsToleranceSquare(t, e);
                        return G.isTrue(!(s && a), "Found bad envelope test"), a
                    }
                }, {
                    key: "initCorners", value: function (t) {
                        var e = .5;
                        this._minx = t.x - e, this._maxx = t.x + e, this._miny = t.y - e, this._maxy = t.y + e, this._corner[0] = new X(this._maxx, this._maxy), this._corner[1] = new X(this._minx, this._maxy), this._corner[2] = new X(this._minx, this._miny), this._corner[3] = new X(this._maxx, this._miny)
                    }
                }, {
                    key: "intersects", value: function (t, e) {
                        return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled))
                    }
                }, {
                    key: "scale", value: function (t) {
                        return Math.round(t * this._scaleFactor)
                    }
                }, {
                    key: "getCoordinate", value: function () {
                        return this._originalPt
                    }
                }, {
                    key: "copyScaled", value: function (t, e) {
                        e.x = this.scale(t.x), e.y = this.scale(t.y)
                    }
                }, {
                    key: "getSafeEnvelope", value: function () {
                        if (null === this._safeEnv) {
                            var t = e.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
                            this._safeEnv = new U(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t)
                        }
                        return this._safeEnv
                    }
                }, {
                    key: "intersectsPixelClosure", value: function (t, e) {
                        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection()))))
                    }
                }, {
                    key: "intersectsToleranceSquare", value: function (t, e) {
                        var n = !1, r = !1;
                        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper() || (this._li.hasIntersection() && (r = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper() || n && r || t.equals(this._pt) || e.equals(this._pt)))))
                    }
                }, {
                    key: "addSnappedNode", value: function (t, e) {
                        var n = t.getCoordinate(e), r = t.getCoordinate(e + 1);
                        return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new x("Scale factor must be non-zero");
                        1 !== e && (this._pt = new X(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new X, this._p1Scaled = new X), this.initCorners(this._pt)
                    }
                }]), e
            }();
            hr.SAFE_ENV_EXPANSION_FACTOR = .75;
            var cr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "select", value: function () {
                        if (1 === arguments.length) ; else if (2 === arguments.length) {
                            var t = arguments[1];
                            arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment)
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this.selectedSegment = new bn
                    }
                }]), e
            }(), fr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "snap", value: function () {
                        if (1 === arguments.length) {
                            var e = arguments[0];
                            return this.snap(e, null, -1)
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0], i = arguments[1], o = arguments[2], s = n.getSafeEnvelope(),
                                a = new gr(n, i, o);
                            return this._index.query(s, new (function () {
                                function e() {
                                    t(this, e)
                                }

                                return r(e, [{
                                    key: "interfaces_", get: function () {
                                        return [cn]
                                    }
                                }, {
                                    key: "visitItem", value: function (t) {
                                        t.select(s, a)
                                    }
                                }]), e
                            }())), a.isNodeAdded()
                        }
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._index = null;
                        var t = arguments[0];
                        this._index = t
                    }
                }]), e
            }(), gr = function (e) {
                i(s, e);
                var n = f(s);

                function s() {
                    var e;
                    return t(this, s), e = n.call(this), s.constructor_.apply(h(e), arguments), e
                }

                return r(s, [{
                    key: "isNodeAdded", value: function () {
                        return this._isNodeAdded
                    }
                }, {
                    key: "select", value: function () {
                        if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Sn)) return g(o(s.prototype), "select", this).apply(this, arguments);
                        var t = arguments[1], e = arguments[0].getContext();
                        if (this._parentEdge === e && (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)) return null;
                        this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
                        var t = arguments[0], e = arguments[1], n = arguments[2];
                        this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n
                    }
                }]), s
            }(cr);
            fr.HotPixelSnapAction = gr;
            var pr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "processIntersections", value: function (t, e, n, r) {
                        if (t === n && e === r) return null;
                        var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], s = n.getCoordinates()[r],
                            a = n.getCoordinates()[r + 1];
                        if (this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
                            for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));
                            t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1)
                        }
                    }
                }, {
                    key: "isDone", value: function () {
                        return !1
                    }
                }, {
                    key: "getInteriorIntersections", value: function () {
                        return this._interiorIntersections
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Qn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._li = null, this._interiorIntersections = null;
                        var t = arguments[0];
                        this._li = t, this._interiorIntersections = new dt
                    }
                }]), e
            }(), vr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "checkCorrectness", value: function (t) {
                        var e = wn.getNodedSubstrings(t), n = new lr(e);
                        try {
                            n.checkValid()
                        } catch (t) {
                            if (!(t instanceof _)) throw t;
                            t.printStackTrace()
                        }
                    }
                }, {
                    key: "getNodedSubstrings", value: function () {
                        return wn.getNodedSubstrings(this._nodedSegStrings)
                    }
                }, {
                    key: "snapRound", value: function (t, e) {
                        var n = this.findInteriorIntersections(t, e);
                        this.computeIntersectionSnaps(n), this.computeVertexSnaps(t)
                    }
                }, {
                    key: "findInteriorIntersections", value: function (t, e) {
                        var n = new pr(e);
                        return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections()
                    }
                }, {
                    key: "computeVertexSnaps", value: function () {
                        if (ot(arguments[0], H)) for (var t = arguments[0].iterator(); t.hasNext();) {
                            var e = t.next();
                            this.computeVertexSnaps(e)
                        } else if (arguments[0] instanceof wn) for (var n = arguments[0], r = n.getCoordinates(), i = 0; i < r.length; i++) {
                            var o = new hr(r[i], this._scaleFactor, this._li);
                            this._pointSnapper.snap(o, n, i) && n.addIntersection(r[i], i)
                        }
                    }
                }, {
                    key: "computeNodes", value: function (t) {
                        this._nodedSegStrings = t, this._noder = new Ln, this._pointSnapper = new fr(this._noder.getIndex()), this.snapRound(t, this._li)
                    }
                }, {
                    key: "computeIntersectionSnaps", value: function (t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var n = e.next(), r = new hr(n, this._scaleFactor, this._li);
                            this._pointSnapper.snap(r)
                        }
                    }
                }, {
                    key: "interfaces_", get: function () {
                        return [Mn]
                    }
                }], [{
                    key: "constructor_", value: function () {
                        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
                        var t = arguments[0];
                        this._pm = t, this._li = new Re, this._li.setPrecisionModel(t), this._scaleFactor = t.getScale()
                    }
                }]), e
            }(), dr = function () {
                function e() {
                    t(this, e), e.constructor_.apply(this, arguments)
                }

                return r(e, [{
                    key: "bufferFixedPrecision", value: function (t) {
                        var e = new ur(new vr(new ie(1)), t.getScale()), n = new ar(this._bufParams);
                        n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance)
                    }
                }, {
                    key: "bufferReducedPrecision", value: function () {
                        if (0 === arguments.length) {
                            for (var t = e.MAX_PRECISION_DIGITS; t >= 0; t--) {
                                try {
                                    this.bufferReducedPrecision(t)
                                } catch (t) {
                                    if (!(t instanceof pt)) throw t;
                                    this._saveException = t
                                }
                                if (null !== this._resultGeometry) return null
                            }
                            throw this._saveException
                        }
                        if (1 === arguments.length) {
                            var n = arguments[0], r = e.precisionScaleFactor(this._argGeom, this._distance, n),
                                i = new ie(r);
                            this.bufferFixedPrecision(i)
                        }
                    }
                }, {
                    key: "computeGeometry", value: function () {
                        if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;
                        var t = this._argGeom.getFactory().getPrecisionModel();
                        t.getType() === ie.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
                    }
                }, {
                    key: "setQuadrantSegments", value: function (t) {
                        this._bufParams.setQuadrantSegments(t)
                    }
                }, {
                    key: "bufferOriginalPrecision", value: function () {
                        try {
                            var t = new ar(this._bufParams);
                            this._resultGeometry = t.buffer(this._argGeom, this._distance)
                        } catch (t) {
                            if (!(t instanceof F)) throw t;
                            this._saveException = t
                        }
                    }
                }, {
                    key: "getResultGeometry", value: function (t) {
                        return this._distance = t, this.computeGeometry(), this._resultGeometry
                    }
                }, {
                    key: "setEndCapStyle", value: function (t) {
                        this._bufParams.setEndCapStyle(t)
                    }
                }], [{
                    key: "constructor_", value: function () {
                        if (this._argGeom = null, this._distance = null, this._bufParams = new m, this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
                            var t = arguments[0];
                            this._argGeom = t
                        } else if (2 === arguments.length) {
                            var e = arguments[0], n = arguments[1];
                            this._argGeom = e, this._bufParams = n
                        }
                    }
                }, {
                    key: "bufferOp", value: function () {
                        if (2 === arguments.length) {
                            var t = arguments[1];
                            return new e(arguments[0]).getResultGeometry(t)
                        }
                        if (3 === arguments.length) {
                            if (Number.isInteger(arguments[2]) && arguments[0] instanceof V && "number" == typeof arguments[1]) {
                                var n = arguments[1], r = arguments[2], i = new e(arguments[0]);
                                return i.setQuadrantSegments(r), i.getResultGeometry(n)
                            }
                            if (arguments[2] instanceof m && arguments[0] instanceof V && "number" == typeof arguments[1]) {
                                var o = arguments[1];
                                return new e(arguments[0], arguments[2]).getResultGeometry(o)
                            }
                        } else if (4 === arguments.length) {
                            var s = arguments[1], a = arguments[2], u = arguments[3], l = new e(arguments[0]);
                            return l.setQuadrantSegments(a), l.setEndCapStyle(u), l.getResultGeometry(s)
                        }
                    }
                }, {
                    key: "precisionScaleFactor", value: function (t, e, n) {
                        var r = t.getEnvelopeInternal(),
                            i = Et.max(Math.abs(r.getMaxX()), Math.abs(r.getMaxY()), Math.abs(r.getMinX()), Math.abs(r.getMinY())) + 2 * (e > 0 ? e : 0),
                            o = n - Math.trunc(Math.log(i) / Math.log(10) + 1);
                        return Math.pow(10, o)
                    }
                }]), e
            }();
            dr.CAP_ROUND = m.CAP_ROUND, dr.CAP_BUTT = m.CAP_FLAT, dr.CAP_FLAT = m.CAP_FLAT, dr.CAP_SQUARE = m.CAP_SQUARE, dr.MAX_PRECISION_DIGITS = 12;
            var yr = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"],
                mr = function () {
                    function e(n) {
                        t(this, e), this.geometryFactory = n || new ae
                    }

                    return r(e, [{
                        key: "read", value: function (t) {
                            var e, n = (e = "string" == typeof t ? JSON.parse(t) : t).type;
                            if (!_r[n]) throw new Error("Unknown GeoJSON type: " + e.type);
                            return -1 !== yr.indexOf(n) ? _r[n].call(this, e.coordinates) : "GeometryCollection" === n ? _r[n].call(this, e.geometries) : _r[n].call(this, e)
                        }
                    }, {
                        key: "write", value: function (t) {
                            var e = t.getGeometryType();
                            if (!xr[e]) throw new Error("Geometry is not supported");
                            return xr[e].call(this, t)
                        }
                    }]), e
                }(), _r = {
                    Feature: function (t) {
                        var e = {};
                        for (var n in t) e[n] = t[n];
                        if (t.geometry) {
                            var r = t.geometry.type;
                            if (!_r[r]) throw new Error("Unknown GeoJSON type: " + t.type);
                            e.geometry = this.read(t.geometry)
                        }
                        return t.bbox && (e.bbox = _r.bbox.call(this, t.bbox)), e
                    }, FeatureCollection: function (t) {
                        var e = {};
                        if (t.features) {
                            e.features = [];
                            for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]))
                        }
                        return t.bbox && (e.bbox = this.parse.bbox.call(this, t.bbox)), e
                    }, coordinates: function (t) {
                        for (var e = [], n = 0; n < t.length; ++n) {
                            var r = t[n];
                            e.push(u(X, p(r)))
                        }
                        return e
                    }, bbox: function (t) {
                        return this.geometryFactory.createLinearRing([new X(t[0], t[1]), new X(t[2], t[1]), new X(t[2], t[3]), new X(t[0], t[3]), new X(t[0], t[1])])
                    }, Point: function (t) {
                        var e = u(X, p(t));
                        return this.geometryFactory.createPoint(e)
                    }, MultiPoint: function (t) {
                        for (var e = [], n = 0; n < t.length; ++n) e.push(_r.Point.call(this, t[n]));
                        return this.geometryFactory.createMultiPoint(e)
                    }, LineString: function (t) {
                        var e = _r.coordinates.call(this, t);
                        return this.geometryFactory.createLineString(e)
                    }, MultiLineString: function (t) {
                        for (var e = [], n = 0; n < t.length; ++n) e.push(_r.LineString.call(this, t[n]));
                        return this.geometryFactory.createMultiLineString(e)
                    }, Polygon: function (t) {
                        for (var e = _r.coordinates.call(this, t[0]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1; i < t.length; ++i) {
                            var o = t[i], s = _r.coordinates.call(this, o), a = this.geometryFactory.createLinearRing(s);
                            r.push(a)
                        }
                        return this.geometryFactory.createPolygon(n, r)
                    }, MultiPolygon: function (t) {
                        for (var e = [], n = 0; n < t.length; ++n) {
                            var r = t[n];
                            e.push(_r.Polygon.call(this, r))
                        }
                        return this.geometryFactory.createMultiPolygon(e)
                    }, GeometryCollection: function (t) {
                        for (var e = [], n = 0; n < t.length; ++n) {
                            var r = t[n];
                            e.push(this.read(r))
                        }
                        return this.geometryFactory.createGeometryCollection(e)
                    }
                }, xr = {
                    coordinate: function (t) {
                        var e = [t.x, t.y];
                        return t.z && e.push(t.z), t.m && e.push(t.m), e
                    }, Point: function (t) {
                        return {type: "Point", coordinates: xr.coordinate.call(this, t.getCoordinate())}
                    }, MultiPoint: function (t) {
                        for (var e = [], n = 0; n < t._geometries.length; ++n) {
                            var r = t._geometries[n], i = xr.Point.call(this, r);
                            e.push(i.coordinates)
                        }
                        return {type: "MultiPoint", coordinates: e}
                    }, LineString: function (t) {
                        for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) {
                            var i = n[r];
                            e.push(xr.coordinate.call(this, i))
                        }
                        return {type: "LineString", coordinates: e}
                    }, MultiLineString: function (t) {
                        for (var e = [], n = 0; n < t._geometries.length; ++n) {
                            var r = t._geometries[n], i = xr.LineString.call(this, r);
                            e.push(i.coordinates)
                        }
                        return {type: "MultiLineString", coordinates: e}
                    }, Polygon: function (t) {
                        var e = [], n = xr.LineString.call(this, t._shell);
                        e.push(n.coordinates);
                        for (var r = 0; r < t._holes.length; ++r) {
                            var i = t._holes[r], o = xr.LineString.call(this, i);
                            e.push(o.coordinates)
                        }
                        return {type: "Polygon", coordinates: e}
                    }, MultiPolygon: function (t) {
                        for (var e = [], n = 0; n < t._geometries.length; ++n) {
                            var r = t._geometries[n], i = xr.Polygon.call(this, r);
                            e.push(i.coordinates)
                        }
                        return {type: "MultiPolygon", coordinates: e}
                    }, GeometryCollection: function (t) {
                        for (var e = [], n = 0; n < t._geometries.length; ++n) {
                            var r = t._geometries[n], i = r.getGeometryType();
                            e.push(xr[i].call(this, r))
                        }
                        return {type: "GeometryCollection", geometries: e}
                    }
                };
            return {
                BufferOp: dr, GeoJSONReader: function () {
                    function e(n) {
                        t(this, e), this.parser = new mr(n || new ae)
                    }

                    return r(e, [{
                        key: "read", value: function (t) {
                            return this.parser.read(t)
                        }
                    }]), e
                }(), GeoJSONWriter: function () {
                    function e() {
                        t(this, e), this.parser = new mr(this.geometryFactory)
                    }

                    return r(e, [{
                        key: "write", value: function (t) {
                            return this.parser.write(t)
                        }
                    }]), e
                }()
            }
        }()
    }));

    function Gl() {
        return new Yl
    }

    function Yl() {
        this.reset()
    }

    Yl.prototype = {
        constructor: Yl, reset: function () {
            this.s = this.t = 0
        }, add: function (t) {
            zl(Bl, t, this.t), zl(this, Bl.s, this.s), this.s ? this.t += Bl.t : this.s = Bl.t
        }, valueOf: function () {
            return this.s
        }
    };
    var Bl = new Yl;

    function zl(t, e, n) {
        var r = t.s = e + n, i = r - e, o = r - i;
        t.t = e - o + (n - i)
    }

    var Xl = 1e-6, jl = Math.PI, Ul = jl / 2, Vl = jl / 4, Zl = 2 * jl, Hl = 180 / jl, Wl = jl / 180, Jl = Math.abs,
        Ql = Math.atan, Kl = Math.atan2, $l = Math.cos, th = Math.sin, eh = Math.sqrt;

    function nh(t) {
        return t > 1 ? 0 : t < -1 ? jl : Math.acos(t)
    }

    function rh(t) {
        return t > 1 ? Ul : t < -1 ? -Ul : Math.asin(t)
    }

    function ih() {
    }

    function oh(t, e) {
        t && ah.hasOwnProperty(t.type) && ah[t.type](t, e)
    }

    var sh = {
        Feature: function (t, e) {
            oh(t.geometry, e)
        }, FeatureCollection: function (t, e) {
            for (var n = t.features, r = -1, i = n.length; ++r < i;) oh(n[r].geometry, e)
        }
    }, ah = {
        Sphere: function (t, e) {
            e.sphere()
        }, Point: function (t, e) {
            t = t.coordinates, e.point(t[0], t[1], t[2])
        }, MultiPoint: function (t, e) {
            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) t = n[r], e.point(t[0], t[1], t[2])
        }, LineString: function (t, e) {
            uh(t.coordinates, e, 0)
        }, MultiLineString: function (t, e) {
            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) uh(n[r], e, 0)
        }, Polygon: function (t, e) {
            lh(t.coordinates, e)
        }, MultiPolygon: function (t, e) {
            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) lh(n[r], e)
        }, GeometryCollection: function (t, e) {
            for (var n = t.geometries, r = -1, i = n.length; ++r < i;) oh(n[r], e)
        }
    };

    function uh(t, e, n) {
        var r, i = -1, o = t.length - n;
        for (e.lineStart(); ++i < o;) r = t[i], e.point(r[0], r[1], r[2]);
        e.lineEnd()
    }

    function lh(t, e) {
        var n = -1, r = t.length;
        for (e.polygonStart(); ++n < r;) uh(t[n], e, 1);
        e.polygonEnd()
    }

    Gl(), Gl();

    function hh(t) {
        return [Kl(t[1], t[0]), rh(t[2])]
    }

    function ch(t) {
        var e = t[0], n = t[1], r = $l(n);
        return [r * $l(e), r * th(e), th(n)]
    }

    function fh(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }

    function gh(t, e) {
        return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
    }

    function ph(t, e) {
        t[0] += e[0], t[1] += e[1], t[2] += e[2]
    }

    function vh(t, e) {
        return [t[0] * e, t[1] * e, t[2] * e]
    }

    function dh(t) {
        var e = eh(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
        t[0] /= e, t[1] /= e, t[2] /= e
    }

    Gl();

    function yh(t, e) {
        function n(n, r) {
            return n = t(n, r), e(n[0], n[1])
        }

        return t.invert && e.invert && (n.invert = function (n, r) {
            return (n = e.invert(n, r)) && t.invert(n[0], n[1])
        }), n
    }

    function mh(t, e) {
        return [t > jl ? t - Zl : t < -jl ? t + Zl : t, e]
    }

    function _h(t) {
        return function (e, n) {
            return [(e += t) > jl ? e - Zl : e < -jl ? e + Zl : e, n]
        }
    }

    function xh(t) {
        var e = _h(t);
        return e.invert = _h(-t), e
    }

    function Eh(t, e) {
        var n = $l(t), r = th(t), i = $l(e), o = th(e);

        function s(t, e) {
            var s = $l(e), a = $l(t) * s, u = th(t) * s, l = th(e), h = l * n + a * r;
            return [Kl(u * i - h * o, a * n - l * r), rh(h * i + u * o)]
        }

        return s.invert = function (t, e) {
            var s = $l(e), a = $l(t) * s, u = th(t) * s, l = th(e), h = l * i - u * o;
            return [Kl(u * i + l * o, a * n + h * r), rh(h * n - a * r)]
        }, s
    }

    function kh(t, e) {
        (e = ch(e))[0] -= t, dh(e);
        var n = nh(-e[1]);
        return ((-e[2] < 0 ? -n : n) + Zl - Xl) % Zl
    }

    function wh() {
        var t, e = [];
        return {
            point: function (e, n) {
                t.push([e, n])
            }, lineStart: function () {
                e.push(t = [])
            }, lineEnd: ih, rejoin: function () {
                e.length > 1 && e.push(e.pop().concat(e.shift()))
            }, result: function () {
                var n = e;
                return e = [], t = null, n
            }
        }
    }

    function bh(t, e) {
        return Jl(t[0] - e[0]) < Xl && Jl(t[1] - e[1]) < Xl
    }

    function Ih(t, e, n, r) {
        this.x = t, this.z = e, this.o = n, this.e = r, this.v = !1, this.n = this.p = null
    }

    function Sh(t, e, n, r, i) {
        var o, s, a = [], u = [];
        if (t.forEach((function (t) {
            if (!((e = t.length - 1) <= 0)) {
                var e, n, r = t[0], s = t[e];
                if (bh(r, s)) {
                    for (i.lineStart(), o = 0; o < e; ++o) i.point((r = t[o])[0], r[1]);
                    i.lineEnd()
                } else a.push(n = new Ih(r, t, null, !0)), u.push(n.o = new Ih(r, null, n, !1)), a.push(n = new Ih(s, t, null, !1)), u.push(n.o = new Ih(s, null, n, !0))
            }
        })), a.length) {
            for (u.sort(e), Nh(a), Nh(u), o = 0, s = u.length; o < s; ++o) u[o].e = n = !n;
            for (var l, h, c = a[0]; ;) {
                for (var f = c, g = !0; f.v;) if ((f = f.n) === c) return;
                l = f.z, i.lineStart();
                do {
                    if (f.v = f.o.v = !0, f.e) {
                        if (g) for (o = 0, s = l.length; o < s; ++o) i.point((h = l[o])[0], h[1]); else r(f.x, f.n.x, 1, i);
                        f = f.n
                    } else {
                        if (g) for (l = f.p.z, o = l.length - 1; o >= 0; --o) i.point((h = l[o])[0], h[1]); else r(f.x, f.p.x, -1, i);
                        f = f.p
                    }
                    l = (f = f.o).z, g = !g
                } while (!f.v);
                i.lineEnd()
            }
        }
    }

    function Nh(t) {
        if (e = t.length) {
            for (var e, n, r = 0, i = t[0]; ++r < e;) i.n = n = t[r], n.p = i, i = n;
            i.n = n = t[0], n.p = i
        }
    }

    function Mh(t, e) {
        return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
    }

    mh.invert = mh;
    var Ph, Lh;
    1 === (Ph = Mh).length && (Lh = Ph, Ph = function (t, e) {
        return Mh(Lh(t), e)
    });

    function Ch(t) {
        for (var e, n, r, i = t.length, o = -1, s = 0; ++o < i;) s += t[o].length;
        for (n = new Array(s); --i >= 0;) for (e = (r = t[i]).length; --e >= 0;) n[--s] = r[e];
        return n
    }

    var Rh = 1e9, Th = -Rh;

    function Oh(t, e, n, r) {
        function i(i, o) {
            return t <= i && i <= n && e <= o && o <= r
        }

        function o(i, o, a, l) {
            var h = 0, c = 0;
            if (null == i || (h = s(i, a)) !== (c = s(o, a)) || u(i, o) < 0 ^ a > 0) do {
                l.point(0 === h || 3 === h ? t : n, h > 1 ? r : e)
            } while ((h = (h + a + 4) % 4) !== c); else l.point(o[0], o[1])
        }

        function s(r, i) {
            return Jl(r[0] - t) < Xl ? i > 0 ? 0 : 3 : Jl(r[0] - n) < Xl ? i > 0 ? 2 : 1 : Jl(r[1] - e) < Xl ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2
        }

        function a(t, e) {
            return u(t.x, e.x)
        }

        function u(t, e) {
            var n = s(t, 1), r = s(e, 1);
            return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0]
        }

        return function (s) {
            var u, l, h, c, f, g, p, v, d, y, m, _ = s, x = wh(), E = {
                point: k, lineStart: function () {
                    E.point = w, l && l.push(h = []);
                    y = !0, d = !1, p = v = NaN
                }, lineEnd: function () {
                    u && (w(c, f), g && d && x.rejoin(), u.push(x.result()));
                    E.point = k, d && _.lineEnd()
                }, polygonStart: function () {
                    _ = x, u = [], l = [], m = !0
                }, polygonEnd: function () {
                    var e = function () {
                        for (var e = 0, n = 0, i = l.length; n < i; ++n) for (var o, s, a = l[n], u = 1, h = a.length, c = a[0], f = c[0], g = c[1]; u < h; ++u) o = f, s = g, f = (c = a[u])[0], g = c[1], s <= r ? g > r && (f - o) * (r - s) > (g - s) * (t - o) && ++e : g <= r && (f - o) * (r - s) < (g - s) * (t - o) && --e;
                        return e
                    }(), n = m && e, i = (u = Ch(u)).length;
                    (n || i) && (s.polygonStart(), n && (s.lineStart(), o(null, null, 1, s), s.lineEnd()), i && Sh(u, a, e, o, s), s.polygonEnd());
                    _ = s, u = l = h = null
                }
            };

            function k(t, e) {
                i(t, e) && _.point(t, e)
            }

            function w(o, s) {
                var a = i(o, s);
                if (l && h.push([o, s]), y) c = o, f = s, g = a, y = !1, a && (_.lineStart(), _.point(o, s)); else if (a && d) _.point(o, s); else {
                    var u = [p = Math.max(Th, Math.min(Rh, p)), v = Math.max(Th, Math.min(Rh, v))],
                        x = [o = Math.max(Th, Math.min(Rh, o)), s = Math.max(Th, Math.min(Rh, s))];
                    !function (t, e, n, r, i, o) {
                        var s, a = t[0], u = t[1], l = 0, h = 1, c = e[0] - a, f = e[1] - u;
                        if (s = n - a, c || !(s > 0)) {
                            if (s /= c, c < 0) {
                                if (s < l) return;
                                s < h && (h = s)
                            } else if (c > 0) {
                                if (s > h) return;
                                s > l && (l = s)
                            }
                            if (s = i - a, c || !(s < 0)) {
                                if (s /= c, c < 0) {
                                    if (s > h) return;
                                    s > l && (l = s)
                                } else if (c > 0) {
                                    if (s < l) return;
                                    s < h && (h = s)
                                }
                                if (s = r - u, f || !(s > 0)) {
                                    if (s /= f, f < 0) {
                                        if (s < l) return;
                                        s < h && (h = s)
                                    } else if (f > 0) {
                                        if (s > h) return;
                                        s > l && (l = s)
                                    }
                                    if (s = o - u, f || !(s < 0)) {
                                        if (s /= f, f < 0) {
                                            if (s > h) return;
                                            s > l && (l = s)
                                        } else if (f > 0) {
                                            if (s < l) return;
                                            s < h && (h = s)
                                        }
                                        return l > 0 && (t[0] = a + l * c, t[1] = u + l * f), h < 1 && (e[0] = a + h * c, e[1] = u + h * f), !0
                                    }
                                }
                            }
                        }
                    }(u, x, t, e, n, r) ? a && (_.lineStart(), _.point(o, s), m = !1) : (d || (_.lineStart(), _.point(u[0], u[1])), _.point(x[0], x[1]), a || _.lineEnd(), m = !1)
                }
                p = o, v = s, d = a
            }

            return E
        }
    }

    var Ah = Gl();
    Gl();

    function Dh(t) {
        return t
    }

    Gl(), Gl();
    var Fh = 1 / 0, qh = Fh, Gh = -Fh, Yh = Gh, Bh = {
        point: function (t, e) {
            t < Fh && (Fh = t);
            t > Gh && (Gh = t);
            e < qh && (qh = e);
            e > Yh && (Yh = e)
        }, lineStart: ih, lineEnd: ih, polygonStart: ih, polygonEnd: ih, result: function () {
            var t = [[Fh, qh], [Gh, Yh]];
            return Gh = Yh = -(qh = Fh = 1 / 0), t
        }
    };
    Gl();

    function zh(t, e, n, r) {
        return function (i, o) {
            var s, a, u, l = e(o), h = i.invert(r[0], r[1]), c = wh(), f = e(c), g = !1, p = {
                point: v, lineStart: y, lineEnd: m, polygonStart: function () {
                    p.point = _, p.lineStart = x, p.lineEnd = E, a = [], s = []
                }, polygonEnd: function () {
                    p.point = v, p.lineStart = y, p.lineEnd = m, a = Ch(a);
                    var t = function (t, e) {
                        var n = e[0], r = e[1], i = [th(n), -$l(n), 0], o = 0, s = 0;
                        Ah.reset();
                        for (var a = 0, u = t.length; a < u; ++a) if (h = (l = t[a]).length) for (var l, h, c = l[h - 1], f = c[0], g = c[1] / 2 + Vl, p = th(g), v = $l(g), d = 0; d < h; ++d, f = m, p = x, v = E, c = y) {
                            var y = l[d], m = y[0], _ = y[1] / 2 + Vl, x = th(_), E = $l(_), k = m - f,
                                w = k >= 0 ? 1 : -1, b = w * k, I = b > jl, S = p * x;
                            if (Ah.add(Kl(S * w * th(b), v * E + S * $l(b))), o += I ? k + w * Zl : k, I ^ f >= n ^ m >= n) {
                                var N = gh(ch(c), ch(y));
                                dh(N);
                                var M = gh(i, N);
                                dh(M);
                                var P = (I ^ k >= 0 ? -1 : 1) * rh(M[2]);
                                (r > P || r === P && (N[0] || N[1])) && (s += I ^ k >= 0 ? 1 : -1)
                            }
                        }
                        return (o < -1e-6 || o < Xl && Ah < -1e-6) ^ 1 & s
                    }(s, h);
                    a.length ? (g || (o.polygonStart(), g = !0), Sh(a, jh, t, n, o)) : t && (g || (o.polygonStart(), g = !0), o.lineStart(), n(null, null, 1, o), o.lineEnd()), g && (o.polygonEnd(), g = !1), a = s = null
                }, sphere: function () {
                    o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd()
                }
            };

            function v(e, n) {
                var r = i(e, n);
                t(e = r[0], n = r[1]) && o.point(e, n)
            }

            function d(t, e) {
                var n = i(t, e);
                l.point(n[0], n[1])
            }

            function y() {
                p.point = d, l.lineStart()
            }

            function m() {
                p.point = v, l.lineEnd()
            }

            function _(t, e) {
                u.push([t, e]);
                var n = i(t, e);
                f.point(n[0], n[1])
            }

            function x() {
                f.lineStart(), u = []
            }

            function E() {
                _(u[0][0], u[0][1]), f.lineEnd();
                var t, e, n, r, i = f.clean(), l = c.result(), h = l.length;
                if (u.pop(), s.push(u), u = null, h) if (1 & i) {
                    if ((e = (n = l[0]).length - 1) > 0) {
                        for (g || (o.polygonStart(), g = !0), o.lineStart(), t = 0; t < e; ++t) o.point((r = n[t])[0], r[1]);
                        o.lineEnd()
                    }
                } else h > 1 && 2 & i && l.push(l.pop().concat(l.shift())), a.push(l.filter(Xh))
            }

            return p
        }
    }

    function Xh(t) {
        return t.length > 1
    }

    function jh(t, e) {
        return ((t = t.x)[0] < 0 ? t[1] - Ul - Xl : Ul - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Ul - Xl : Ul - e[1])
    }

    var Uh = zh((function () {
        return !0
    }), (function (t) {
        var e, n = NaN, r = NaN, i = NaN;
        return {
            lineStart: function () {
                t.lineStart(), e = 1
            }, point: function (o, s) {
                var a = o > 0 ? jl : -jl, u = Jl(o - n);
                Jl(u - jl) < Xl ? (t.point(n, r = (r + s) / 2 > 0 ? Ul : -Ul), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), t.point(o, r), e = 0) : i !== a && u >= jl && (Jl(n - i) < Xl && (n -= i * Xl), Jl(o - a) < Xl && (o -= a * Xl), r = function (t, e, n, r) {
                    var i, o, s = th(t - n);
                    return Jl(s) > Xl ? Ql((th(e) * (o = $l(r)) * th(n) - th(r) * (i = $l(e)) * th(t)) / (i * o * s)) : (e + r) / 2
                }(n, r, o, s), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), e = 0), t.point(n = o, r = s), i = a
            }, lineEnd: function () {
                t.lineEnd(), n = r = NaN
            }, clean: function () {
                return 2 - e
            }
        }
    }), (function (t, e, n, r) {
        var i;
        if (null == t) i = n * Ul, r.point(-jl, i), r.point(0, i), r.point(jl, i), r.point(jl, 0), r.point(jl, -i), r.point(0, -i), r.point(-jl, -i), r.point(-jl, 0), r.point(-jl, i); else if (Jl(t[0] - e[0]) > Xl) {
            var o = t[0] < e[0] ? jl : -jl;
            i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i)
        } else r.point(e[0], e[1])
    }), [-jl, -Ul]);

    function Vh(t, e) {
        var n = $l(t), r = n > 0, i = Jl(n) > Xl;

        function o(t, e) {
            return $l(t) * $l(e) > n
        }

        function s(t, e, r) {
            var i = [1, 0, 0], o = gh(ch(t), ch(e)), s = fh(o, o), a = o[0], u = s - a * a;
            if (!u) return !r && t;
            var l = n * s / u, h = -n * a / u, c = gh(i, o), f = vh(i, l);
            ph(f, vh(o, h));
            var g = c, p = fh(f, g), v = fh(g, g), d = p * p - v * (fh(f, f) - 1);
            if (!(d < 0)) {
                var y = eh(d), m = vh(g, (-p - y) / v);
                if (ph(m, f), m = hh(m), !r) return m;
                var _, x = t[0], E = e[0], k = t[1], w = e[1];
                E < x && (_ = x, x = E, E = _);
                var b = E - x, I = Jl(b - jl) < Xl;
                if (!I && w < k && (_ = k, k = w, w = _), I || b < Xl ? I ? k + w > 0 ^ m[1] < (Jl(m[0] - x) < Xl ? k : w) : k <= m[1] && m[1] <= w : b > jl ^ (x <= m[0] && m[0] <= E)) {
                    var S = vh(g, (-p + y) / v);
                    return ph(S, f), [m, hh(S)]
                }
            }
        }

        function a(e, n) {
            var i = r ? t : jl - t, o = 0;
            return e < -i ? o |= 1 : e > i && (o |= 2), n < -i ? o |= 4 : n > i && (o |= 8), o
        }

        return zh(o, (function (t) {
            var e, n, u, l, h;
            return {
                lineStart: function () {
                    l = u = !1, h = 1
                }, point: function (c, f) {
                    var g, p = [c, f], v = o(c, f), d = r ? v ? 0 : a(c, f) : v ? a(c + (c < 0 ? jl : -jl), f) : 0;
                    if (!e && (l = u = v) && t.lineStart(), v !== u && (!(g = s(e, p)) || bh(e, g) || bh(p, g)) && (p[0] += Xl, p[1] += Xl, v = o(p[0], p[1])), v !== u) h = 0, v ? (t.lineStart(), g = s(p, e), t.point(g[0], g[1])) : (g = s(e, p), t.point(g[0], g[1]), t.lineEnd()), e = g; else if (i && e && r ^ v) {
                        var y;
                        d & n || !(y = s(p, e, !0)) || (h = 0, r ? (t.lineStart(), t.point(y[0][0], y[0][1]), t.point(y[1][0], y[1][1]), t.lineEnd()) : (t.point(y[1][0], y[1][1]), t.lineEnd(), t.lineStart(), t.point(y[0][0], y[0][1])))
                    }
                    !v || e && bh(e, p) || t.point(p[0], p[1]), e = p, u = v, n = d
                }, lineEnd: function () {
                    u && t.lineEnd(), e = null
                }, clean: function () {
                    return h | (l && u) << 1
                }
            }
        }), (function (n, r, i, o) {
            !function (t, e, n, r, i, o) {
                if (n) {
                    var s = $l(e), a = th(e), u = r * n;
                    null == i ? (i = e + r * Zl, o = e - u / 2) : (i = kh(s, i), o = kh(s, o), (r > 0 ? i < o : i > o) && (i += r * Zl));
                    for (var l, h = i; r > 0 ? h > o : h < o; h -= u) l = hh([s, -a * $l(h), -a * th(h)]), t.point(l[0], l[1])
                }
            }(o, t, e, i, n, r)
        }), r ? [0, -t] : [-jl, t - jl])
    }

    function Zh(t) {
        return function (e) {
            var n = new Hh;
            for (var r in t) n[r] = t[r];
            return n.stream = e, n
        }
    }

    function Hh() {
    }

    function Wh(t, e, n) {
        var r = e[1][0] - e[0][0], i = e[1][1] - e[0][1], o = t.clipExtent && t.clipExtent();
        t.scale(150).translate([0, 0]), null != o && t.clipExtent(null), function (t, e) {
            t && sh.hasOwnProperty(t.type) ? sh[t.type](t, e) : oh(t, e)
        }(n, t.stream(Bh));
        var s = Bh.result(), a = Math.min(r / (s[1][0] - s[0][0]), i / (s[1][1] - s[0][1])),
            u = +e[0][0] + (r - a * (s[1][0] + s[0][0])) / 2, l = +e[0][1] + (i - a * (s[1][1] + s[0][1])) / 2;
        return null != o && t.clipExtent(o), t.scale(150 * a).translate([u, l])
    }

    Hh.prototype = {
        constructor: Hh, point: function (t, e) {
            this.stream.point(t, e)
        }, sphere: function () {
            this.stream.sphere()
        }, lineStart: function () {
            this.stream.lineStart()
        }, lineEnd: function () {
            this.stream.lineEnd()
        }, polygonStart: function () {
            this.stream.polygonStart()
        }, polygonEnd: function () {
            this.stream.polygonEnd()
        }
    };
    var Jh = $l(30 * Wl);

    function Qh(t, e) {
        return +e ? function (t, e) {
            function n(r, i, o, s, a, u, l, h, c, f, g, p, v, d) {
                var y = l - r, m = h - i, _ = y * y + m * m;
                if (_ > 4 * e && v--) {
                    var x = s + f, E = a + g, k = u + p, w = eh(x * x + E * E + k * k), b = rh(k /= w),
                        I = Jl(Jl(k) - 1) < Xl || Jl(o - c) < Xl ? (o + c) / 2 : Kl(E, x), S = t(I, b), N = S[0],
                        M = S[1], P = N - r, L = M - i, C = m * P - y * L;
                    (C * C / _ > e || Jl((y * P + m * L) / _ - .5) > .3 || s * f + a * g + u * p < Jh) && (n(r, i, o, s, a, u, N, M, I, x /= w, E /= w, k, v, d), d.point(N, M), n(N, M, I, x, E, k, l, h, c, f, g, p, v, d))
                }
            }

            return function (e) {
                var r, i, o, s, a, u, l, h, c, f, g, p, v = {
                    point: d, lineStart: y, lineEnd: _, polygonStart: function () {
                        e.polygonStart(), v.lineStart = x
                    }, polygonEnd: function () {
                        e.polygonEnd(), v.lineStart = y
                    }
                };

                function d(n, r) {
                    n = t(n, r), e.point(n[0], n[1])
                }

                function y() {
                    h = NaN, v.point = m, e.lineStart()
                }

                function m(r, i) {
                    var o = ch([r, i]), s = t(r, i);
                    n(h, c, l, f, g, p, h = s[0], c = s[1], l = r, f = o[0], g = o[1], p = o[2], 16, e), e.point(h, c)
                }

                function _() {
                    v.point = d, e.lineEnd()
                }

                function x() {
                    y(), v.point = E, v.lineEnd = k
                }

                function E(t, e) {
                    m(r = t, e), i = h, o = c, s = f, a = g, u = p, v.point = m
                }

                function k() {
                    n(h, c, l, f, g, p, i, o, r, s, a, u, 16, e), v.lineEnd = _, _()
                }

                return v
            }
        }(t, e) : function (t) {
            return Zh({
                point: function (e, n) {
                    e = t(e, n), this.stream.point(e[0], e[1])
                }
            })
        }(t)
    }

    var Kh = Zh({
        point: function (t, e) {
            this.stream.point(t * Wl, e * Wl)
        }
    });

    function $h(t) {
        return function (t) {
            var e, n, r, i, o, s, a, u, l, h, c = 150, f = 480, g = 250, p = 0, v = 0, d = 0, y = 0, m = 0, _ = null,
                x = Uh, E = null, k = Dh, w = .5, b = Qh(N, w);

            function I(t) {
                return [(t = o(t[0] * Wl, t[1] * Wl))[0] * c + n, r - t[1] * c]
            }

            function S(t) {
                return (t = o.invert((t[0] - n) / c, (r - t[1]) / c)) && [t[0] * Hl, t[1] * Hl]
            }

            function N(t, i) {
                return [(t = e(t, i))[0] * c + n, r - t[1] * c]
            }

            function M() {
                o = yh(i = function (t, e, n) {
                    return (t %= Zl) ? e || n ? yh(xh(t), Eh(e, n)) : xh(t) : e || n ? Eh(e, n) : mh
                }(d, y, m), e);
                var t = e(p, v);
                return n = f - t[0] * c, r = g + t[1] * c, P()
            }

            function P() {
                return l = h = null, I
            }

            return I.stream = function (t) {
                return l && h === t ? l : l = Kh(x(i, b(k(h = t))))
            }, I.clipAngle = function (t) {
                return arguments.length ? (x = +t ? Vh(_ = t * Wl, 6 * Wl) : (_ = null, Uh), P()) : _ * Hl
            }, I.clipExtent = function (t) {
                return arguments.length ? (k = null == t ? (E = s = a = u = null, Dh) : Oh(E = +t[0][0], s = +t[0][1], a = +t[1][0], u = +t[1][1]), P()) : null == E ? null : [[E, s], [a, u]]
            }, I.scale = function (t) {
                return arguments.length ? (c = +t, M()) : c
            }, I.translate = function (t) {
                return arguments.length ? (f = +t[0], g = +t[1], M()) : [f, g]
            }, I.center = function (t) {
                return arguments.length ? (p = t[0] % 360 * Wl, v = t[1] % 360 * Wl, M()) : [p * Hl, v * Hl]
            }, I.rotate = function (t) {
                return arguments.length ? (d = t[0] % 360 * Wl, y = t[1] % 360 * Wl, m = t.length > 2 ? t[2] % 360 * Wl : 0, M()) : [d * Hl, y * Hl, m * Hl]
            }, I.precision = function (t) {
                return arguments.length ? (b = Qh(N, w = t * t), P()) : eh(w)
            }, I.fitExtent = function (t, e) {
                return Wh(I, t, e)
            }, I.fitSize = function (t, e) {
                return function (t, e, n) {
                    return Wh(t, [[0, 0], e], n)
                }(I, t, e)
            }, function () {
                return e = t.apply(this, arguments), I.invert = e.invert && S, M()
            }
        }((function () {
            return t
        }))()
    }

    var tc = function (t) {
        return function (e, n) {
            var r = $l(e), i = $l(n), o = t(r * i);
            return [o * i * th(e), o * th(n)]
        }
    }((function (t) {
        return (t = nh(t)) && t / th(t)
    }));

    function ec() {
        return $h(tc).scale(79.4188).clipAngle(179.999)
    }

    function nc(t, e, n, r) {
        var i = t.properties || {}, o = "Feature" === t.type ? t.geometry : t;
        if ("GeometryCollection" === o.type) {
            var s = [];
            return H(t, (function (t) {
                var i = nc(t, e, n, r);
                i && s.push(i)
            })), k(s)
        }
        var a = function (t) {
                var e = In(t).geometry.coordinates, n = [-e[0], -e[1]];
                return ec().rotate(n).scale(c)
            }(o), u = {type: o.type, coordinates: ic(o.coordinates, a)}, l = (new ql.GeoJSONReader).read(u),
            h = M(P(e, n), "meters"), f = ql.BufferOp.bufferOp(l, h, r);
        if (!rc((f = (new ql.GeoJSONWriter).write(f)).coordinates)) return p({
            type: f.type,
            coordinates: oc(f.coordinates, a)
        }, i)
    }

    function rc(t) {
        return Array.isArray(t[0]) ? rc(t[0]) : isNaN(t[0])
    }

    function ic(t, n) {
        return "object" !== e(t[0]) ? n(t) : t.map((function (t) {
            return ic(t, n)
        }))
    }

    function oc(t, n) {
        return "object" !== e(t[0]) ? n.invert(t) : t.map((function (t) {
            return oc(t, n)
        }))
    }

    function sc(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = [];
        if (H(t, (function (t) {
            n.push(t.coordinates)
        })), n.length < 2) throw new Error("Must specify at least 2 geometries");
        var r = Fl.intersection.apply(Fl, [n[0]].concat(a(n.slice(1))));
        return 0 === r.length ? null : 1 === r.length ? m(r[0], e.properties) : I(r, e.properties)
    }

    function ac(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = JSON.stringify(n.properties || {}), i = s(t, 4), o = i[0], a = i[1], u = i[2], l = i[3],
            h = (a + l) / 2, c = (o + u) / 2, f = 2 * e / xe([o, h], [u, h], n), g = f * (u - o),
            p = 2 * e / xe([c, a], [c, l], n), v = p * (l - a), d = g / 2, y = 2 * d, m = Math.sqrt(3) / 2 * v,
            _ = u - o, x = l - a, E = 3 / 4 * y, w = m, b = (_ - y) / (y - d / 2), I = Math.floor(b),
            S = (I * E - d / 2 - _) / 2 - d / 2 + E / 2, N = Math.floor((x - m) / m), M = (x - N * m) / 2,
            P = N * m - x > m / 2;
        P && (M -= m / 4);
        for (var L = [], C = [], R = 0; R < 6; R++) {
            var T = 2 * Math.PI / 6 * R;
            L.push(Math.cos(T)), C.push(Math.sin(T))
        }
        for (var O = [], A = 0; A <= I; A++) for (var D = 0; D <= N; D++) {
            var F = A % 2 == 1;
            if ((0 !== D || !F) && (0 !== D || !P)) {
                var q = A * E + o - S, G = D * w + a + M;
                if (F && (G -= m / 2), !0 === n.triangles) lc([q, G], g / 2, v / 2, JSON.parse(r), L, C).forEach((function (t) {
                    n.mask ? sc(k([n.mask, t])) && O.push(t) : O.push(t)
                })); else {
                    var Y = uc([q, G], g / 2, v / 2, JSON.parse(r), L, C);
                    n.mask ? sc(k([n.mask, Y])) && O.push(Y) : O.push(Y)
                }
            }
        }
        return k(O)
    }

    function uc(t, e, n, r, i, o) {
        for (var s = [], a = 0; a < 6; a++) {
            var u = t[0] + e * i[a], l = t[1] + n * o[a];
            s.push([u, l])
        }
        return s.push(s[0].slice()), m([s], r)
    }

    function lc(t, e, n, r, i, o) {
        for (var s = [], a = 0; a < 6; a++) {
            var u = [];
            u.push(t), u.push([t[0] + e * i[a], t[1] + n * o[a]]), u.push([t[0] + e * i[(a + 1) % 6], t[1] + n * o[(a + 1) % 6]]), u.push(t), s.push(m([u], r))
        }
        return s
    }

    function hc(t) {
        return I(t)
    }

    function cc(t) {
        return m(t && t.geometry.coordinates || [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]])
    }

    function fc(t, e, n) {
        for (var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = [], o = t[0], s = t[1], a = t[2], u = t[3], l = a - o, h = O(e, r.units, "degrees"), c = u - s, f = O(n, r.units, "degrees"), g = Math.floor(Math.abs(l) / h), p = Math.floor(Math.abs(c) / f), v = (l - g * h) / 2, d = (c - p * f) / 2, y = o + v, _ = 0; _ < g; _++) {
            for (var x = s + d, E = 0; E < p; E++) {
                var w = m([[[y, x], [y, x + f], [y + h, x + f], [y + h, x], [y, x]]], r.properties);
                r.mask ? sa(r.mask, w) && i.push(w) : i.push(w), x += f
            }
            y += h
        }
        return k(i)
    }

    function gc(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return fc(t, e, e, n)
    }

    function pc(t, e) {
        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = [], i = e / xe([t[0], t[1]], [t[2], t[1]], n), o = i * (t[2] - t[0]), s = e / xe([t[0], t[1]], [t[0], t[3]], n), a = s * (t[3] - t[1]), u = 0, l = t[0]; l <= t[2];) {
            for (var h = 0, c = t[1]; c <= t[3];) {
                var f = null, g = null;
                u % 2 == 0 && h % 2 == 0 ? (f = m([[[l, c], [l, c + a], [l + o, c], [l, c]]], n.properties), g = m([[[l, c + a], [l + o, c + a], [l + o, c], [l, c + a]]], n.properties)) : u % 2 == 0 && h % 2 == 1 ? (f = m([[[l, c], [l + o, c + a], [l + o, c], [l, c]]], n.properties), g = m([[[l, c], [l, c + a], [l + o, c + a], [l, c]]], n.properties)) : h % 2 == 0 && u % 2 == 1 ? (f = m([[[l, c], [l, c + a], [l + o, c + a], [l, c]]], n.properties), g = m([[[l, c], [l + o, c + a], [l + o, c], [l, c]]], n.properties)) : h % 2 == 1 && u % 2 == 1 && (f = m([[[l, c], [l, c + a], [l + o, c], [l, c]]], n.properties), g = m([[[l, c + a], [l + o, c + a], [l + o, c], [l, c + a]]], n.properties)), n.mask ? (sc(k([n.mask, f])) && r.push(f), sc(k([n.mask, g])) && r.push(g)) : (r.push(f), r.push(g)), c += a, h++
            }
            u++, l += o
        }
        return k(r)
    }

    tc.invert = function (t) {
        return function (e, n) {
            var r = eh(e * e + n * n), i = t(r), o = th(i), s = $l(i);
            return [Kl(e * o, r * s), rh(r && n * o / r)]
        }
    }((function (t) {
        return t
    })), t.along = function (t, e) {
        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = ft(t), i = r.coordinates, o = 0, s = 0; s < i.length && !(e >= o && s === i.length - 1); s++) {
            if (o >= e) {
                var a = e - o;
                if (a) {
                    var u = wn(i[s], i[s - 1]) - 180, l = En(i[s], a, u, n);
                    return l
                }
                return d(i[s])
            }
            o += xe(i[s], i[s + 1], n)
        }
        return d(i[i.length - 1])
    }, t.angle = function (t, e, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        if (!F(r)) throw new Error("options is invalid");
        if (!t) throw new Error("startPoint is required");
        if (!e) throw new Error("midPoint is required");
        if (!n) throw new Error("endPoint is required");
        var i = t, o = e, s = n, a = C(!0 !== r.mercator ? wn(i, o) : yo(i, o)),
            u = C(!0 !== r.mercator ? wn(s, o) : yo(s, o)), l = Math.abs(a - u);
        return !0 === r.explementary ? 360 - l : l
    }, t.applyFilter = Vu, t.area = Ar, t.areaFactors = g, t.bbox = ot, t.bboxClip = function (t, e) {
        var n = ft(t), r = n.type, i = "Feature" === t.type ? t.properties : {}, o = n.coordinates;
        switch (r) {
            case"LineString":
            case"MultiLineString":
                var s = [];
                return "LineString" === r && (o = [o]), o.forEach((function (t) {
                    !function (t, e, n) {
                        var r, i, o, s, a, u = t.length, l = uo(t[0], e), h = [];
                        for (n || (n = []), r = 1; r < u; r++) {
                            for (s = t[r - 1], i = o = uo(a = t[r], e); ;) {
                                if (!(l | i)) {
                                    h.push(s), i !== o ? (h.push(a), r < u - 1 && (n.push(h), h = [])) : r === u - 1 && h.push(a);
                                    break
                                }
                                if (l & i) break;
                                l ? l = uo(s = ao(s, a, l, e), e) : i = uo(a = ao(s, a, i, e), e)
                            }
                            l = o
                        }
                        h.length && n.push(h)
                    }(t, e, s)
                })), 1 === s.length ? x(s[0], i) : w(s, i);
            case"Polygon":
                return m(lo(o, e), i);
            case"MultiPolygon":
                return I(o.map((function (t) {
                    return lo(t, e)
                })), i);
            default:
                throw new Error("geometry " + r + " not supported")
        }
    }, t.bboxPolygon = mn, t.bearing = wn, t.bearingToAzimuth = C, t.bezierSpline = function (t) {
        for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.resolution || 1e4, r = e.sharpness || .85, i = [], o = ft(t).coordinates.map((function (t) {
            return {x: t[0], y: t[1]}
        })), s = new yn({duration: n, points: o, sharpness: r}), a = function (t) {
            var e = s.pos(t);
            Math.floor(t / 100) % 2 == 0 && i.push([e.x, e.y])
        }, u = 0; u < s.duration; u += 10) a(u);
        return a(s.duration), x(i, e.properties)
    }, t.booleanClockwise = bo, t.booleanContains = function (t, e) {
        var n = ft(t), r = ft(e), i = n.type, o = r.type, s = n.coordinates, a = r.coordinates;
        switch (i) {
            case"Point":
                if ("Point" === o) return Ws(s, a);
                throw new Error("feature2 " + o + " geometry not supported");
            case"MultiPoint":
                switch (o) {
                    case"Point":
                        return function (t, e) {
                            var n, r = !1;
                            for (n = 0; n < t.coordinates.length; n++) if (Ws(t.coordinates[n], e.coordinates)) {
                                r = !0;
                                break
                            }
                            return r
                        }(n, r);
                    case"MultiPoint":
                        return function (t, e) {
                            var n, r = h(e.coordinates);
                            try {
                                for (r.s(); !(n = r.n()).done;) {
                                    var i, o = n.value, s = !1, a = h(t.coordinates);
                                    try {
                                        for (a.s(); !(i = a.n()).done;) {
                                            if (Ws(o, i.value)) {
                                                s = !0;
                                                break
                                            }
                                        }
                                    } catch (t) {
                                        a.e(t)
                                    } finally {
                                        a.f()
                                    }
                                    if (!s) return !1
                                }
                            } catch (t) {
                                r.e(t)
                            } finally {
                                r.f()
                            }
                            return !0
                        }(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"LineString":
                switch (o) {
                    case"Point":
                        return Br(r, n, {ignoreEndVertices: !0});
                    case"LineString":
                        return function (t, e) {
                            var n, r = !1, i = h(e.coordinates);
                            try {
                                for (i.s(); !(n = i.n()).done;) {
                                    var o = n.value;
                                    if (Br({
                                        type: "Point",
                                        coordinates: o
                                    }, t, {ignoreEndVertices: !0}) && (r = !0), !Br({
                                        type: "Point",
                                        coordinates: o
                                    }, t, {ignoreEndVertices: !1})) return !1
                                }
                            } catch (t) {
                                i.e(t)
                            } finally {
                                i.f()
                            }
                            return r
                        }(n, r);
                    case"MultiPoint":
                        return function (t, e) {
                            var n, r = !1, i = h(e.coordinates);
                            try {
                                for (i.s(); !(n = i.n()).done;) {
                                    var o = n.value;
                                    if (Br(o, t, {ignoreEndVertices: !0}) && (r = !0), !Br(o, t)) return !1
                                }
                            } catch (t) {
                                i.e(t)
                            } finally {
                                i.f()
                            }
                            if (r) return !0;
                            return !1
                        }(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"Polygon":
                switch (o) {
                    case"Point":
                        return ye(r, n, {ignoreBoundary: !0});
                    case"LineString":
                        return function (t, e) {
                            var n = !1, r = 0, i = ot(t), o = ot(e);
                            if (!Hs(i, o)) return !1;
                            for (; r < e.coordinates.length - 1; r++) {
                                if (ye({
                                    type: "Point",
                                    coordinates: Js(e.coordinates[r], e.coordinates[r + 1])
                                }, t, {ignoreBoundary: !0})) {
                                    n = !0;
                                    break
                                }
                            }
                            return n
                        }(n, r);
                    case"Polygon":
                        return Zs(n, r);
                    case"MultiPoint":
                        return function (t, e) {
                            var n, r = h(e.coordinates);
                            try {
                                for (r.s(); !(n = r.n()).done;) {
                                    if (!ye(n.value, t, {ignoreBoundary: !0})) return !1
                                }
                            } catch (t) {
                                r.e(t)
                            } finally {
                                r.f()
                            }
                            return !0
                        }(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"MultiPolygon":
                if ("Polygon" === o) return function (t, e) {
                    return t.coordinates.some((function (t) {
                        return Zs({type: "Polygon", coordinates: t}, e)
                    }))
                }(n, r);
                throw new Error("feature2 " + o + " geometry not supported");
            default:
                throw new Error("feature1 " + i + " geometry not supported")
        }
    }, t.booleanCrosses = function (t, e) {
        var n = ft(t), r = ft(e), i = n.type, o = r.type;
        switch (i) {
            case"MultiPoint":
                switch (o) {
                    case"LineString":
                        return Qs(n, r);
                    case"Polygon":
                        return $s(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"LineString":
                switch (o) {
                    case"MultiPoint":
                        return Qs(r, n);
                    case"LineString":
                        return function (t, e) {
                            if (gr(t, e).features.length > 0) for (var n = 0; n < t.coordinates.length - 1; n++) for (var r = 0; r < e.coordinates.length - 1; r++) {
                                var i = !0;
                                if (0 !== r && r !== e.coordinates.length - 2 || (i = !1), ta(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], i)) return !0
                            }
                            return !1
                        }(n, r);
                    case"Polygon":
                        return Ks(n, r);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"Polygon":
                switch (o) {
                    case"MultiPoint":
                        return $s(r, n);
                    case"LineString":
                        return Ks(r, n);
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + i + " geometry not supported")
        }
    }, t.booleanDisjoint = Xs, t.booleanEqual = function (t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.precision;
        if ("number" != typeof (r = null == r || isNaN(r) ? 6 : r) || !(r >= 0)) throw new Error("precision must be a positive number");
        var i = ft(t).type, o = ft(e).type;
        if (i !== o) return !1;
        var s = new oa({precision: r});
        return s.compare(sn(t), sn(e))
    }, t.booleanIntersects = sa, t.booleanOverlap = function (t, e) {
        var n = ft(t), r = ft(e), i = n.type, o = r.type;
        if ("MultiPoint" === i && "MultiPoint" !== o || ("LineString" === i || "MultiLineString" === i) && "LineString" !== o && "MultiLineString" !== o || ("Polygon" === i || "MultiPolygon" === i) && "Polygon" !== o && "MultiPolygon" !== o) throw new Error("features must be of the same type");
        if ("Point" === i) throw new Error("Point geometry not supported");
        if (new oa({precision: 6}).compare(t, e)) return !1;
        var s = 0;
        switch (i) {
            case"MultiPoint":
                for (var a = 0; a < n.coordinates.length; a++) for (var u = 0; u < r.coordinates.length; u++) {
                    var l = n.coordinates[a], h = r.coordinates[u];
                    if (l[0] === h[0] && l[1] === h[1]) return !0
                }
                return !1;
            case"LineString":
            case"MultiLineString":
                K(t, (function (t) {
                    K(e, (function (e) {
                        go(t, e).features.length && s++
                    }))
                }));
                break;
            case"Polygon":
            case"MultiPolygon":
                K(t, (function (t) {
                    K(e, (function (e) {
                        gr(t, e).features.length && s++
                    }))
                }))
        }
        return s > 0
    }, t.booleanParallel = function (t, e) {
        if (!t) throw new Error("line1 is required");
        if (!e) throw new Error("line2 is required");
        if ("LineString" !== Ia(t, "line1")) throw new Error("line1 must be a LineString");
        if ("LineString" !== Ia(e, "line2")) throw new Error("line2 must be a LineString");
        for (var n = fi(sn(t)).features, r = fi(sn(e)).features, i = 0; i < n.length; i++) {
            var o = n[i].geometry.coordinates;
            if (!r[i]) break;
            if (!ba(o, r[i].geometry.coordinates)) return !1
        }
        return !0
    }, t.booleanPointInPolygon = ye, t.booleanPointOnLine = Br, t.booleanTouches = function (t, e) {
        var n = ft(t), r = ft(e), i = n.type, o = r.type;
        switch (i) {
            case"Point":
                switch (o) {
                    case"LineString":
                        return aa(n, r);
                    case"MultiLineString":
                        for (var s = !1, a = 0; a < r.coordinates.length; a++) aa(n, {
                            type: "LineString",
                            coordinates: r.coordinates[a]
                        }) && (s = !0);
                        return s;
                    case"Polygon":
                        for (var u = 0; u < r.coordinates.length; u++) if (Br(n, {
                            type: "LineString",
                            coordinates: r.coordinates[u]
                        })) return !0;
                        return !1;
                    case"MultiPolygon":
                        for (u = 0; u < r.coordinates.length; u++) for (a = 0; a < r.coordinates[u].length; a++) if (Br(n, {
                            type: "LineString",
                            coordinates: r.coordinates[u][a]
                        })) return !0;
                        return !1;
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"MultiPoint":
                switch (o) {
                    case"LineString":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) if (s || aa({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, r) && (s = !0), Br({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, r, {ignoreEndVertices: !0})) return !1;
                        return s;
                    case"MultiLineString":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) for (a = 0; a < r.coordinates.length; a++) if (s || aa({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, {type: "LineString", coordinates: r.coordinates[a]}) && (s = !0), Br({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, {type: "LineString", coordinates: r.coordinates[a]}, {ignoreEndVertices: !0})) return !1;
                        return s;
                    case"Polygon":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, {type: "LineString", coordinates: r.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, r, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiPolygon":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) for (a = 0; a < r.coordinates.length; a++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, {type: "LineString", coordinates: r.coordinates[a][0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, {type: "Polygon", coordinates: r.coordinates[a]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"LineString":
                switch (o) {
                    case"Point":
                        return aa(r, n);
                    case"MultiPoint":
                        for (s = !1, u = 0; u < r.coordinates.length; u++) if (s || aa({
                            type: "Point",
                            coordinates: r.coordinates[u]
                        }, n) && (s = !0), Br({
                            type: "Point",
                            coordinates: r.coordinates[u]
                        }, n, {ignoreEndVertices: !0})) return !1;
                        return s;
                    case"LineString":
                        var l = !1;
                        if (aa({type: "Point", coordinates: n.coordinates[0]}, r) && (l = !0), aa({
                            type: "Point",
                            coordinates: n.coordinates[n.coordinates.length - 1]
                        }, r) && (l = !0), !1 === l) return !1;
                        for (u = 0; u < n.coordinates.length; u++) if (Br({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, r, {ignoreEndVertices: !0})) return !1;
                        return l;
                    case"MultiLineString":
                        for (l = !1, u = 0; u < r.coordinates.length; u++) {
                            aa({type: "Point", coordinates: n.coordinates[0]}, {
                                type: "LineString",
                                coordinates: r.coordinates[u]
                            }) && (l = !0), aa({
                                type: "Point",
                                coordinates: n.coordinates[n.coordinates.length - 1]
                            }, {type: "LineString", coordinates: r.coordinates[u]}) && (l = !0);
                            for (a = 0; a < n.coordinates[u].length; a++) if (Br({
                                type: "Point",
                                coordinates: n.coordinates[a]
                            }, {type: "LineString", coordinates: r.coordinates[u]}, {ignoreEndVertices: !0})) return !1
                        }
                        return l;
                    case"Polygon":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, {type: "LineString", coordinates: r.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[u]
                        }, r, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiPolygon":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) {
                            for (a = 0; a < r.coordinates.length; a++) s || Br({
                                type: "Point",
                                coordinates: n.coordinates[u]
                            }, {type: "LineString", coordinates: r.coordinates[a][0]}) && (s = !0);
                            if (ye({type: "Point", coordinates: n.coordinates[u]}, r, {ignoreBoundary: !0})) return !1
                        }
                        return s;
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"MultiLineString":
                switch (o) {
                    case"Point":
                        for (u = 0; u < n.coordinates.length; u++) if (aa(r, {
                            type: "LineString",
                            coordinates: n.coordinates[u]
                        })) return !0;
                        return !1;
                    case"MultiPoint":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) for (a = 0; a < r.coordinates.length; a++) if (s || aa({
                            type: "Point",
                            coordinates: r.coordinates[a]
                        }, {type: "LineString", coordinates: n.coordinates[a]}) && (s = !0), Br({
                            type: "Point",
                            coordinates: r.coordinates[a]
                        }, {type: "LineString", coordinates: n.coordinates[a]}, {ignoreEndVertices: !0})) return !1;
                        return s;
                    case"LineString":
                        for (l = !1, u = 0; u < n.coordinates.length; u++) {
                            aa({type: "Point", coordinates: n.coordinates[u][0]}, r) && (l = !0), aa({
                                type: "Point",
                                coordinates: n.coordinates[u][n.coordinates[u].length - 1]
                            }, r) && (l = !0);
                            for (a = 0; a < r.coordinates.length; a++) if (Br({
                                type: "Point",
                                coordinates: r.coordinates[a]
                            }, {type: "LineString", coordinates: n.coordinates[u]}, {ignoreEndVertices: !0})) return !1
                        }
                        return l;
                    case"MultiLineString":
                        for (l = !1, u = 0; u < n.coordinates.length; u++) for (a = 0; a < r.coordinates.length; a++) {
                            aa({type: "Point", coordinates: n.coordinates[u][0]}, {
                                type: "LineString",
                                coordinates: r.coordinates[a]
                            }) && (l = !0), aa({
                                type: "Point",
                                coordinates: n.coordinates[u][n.coordinates[u].length - 1]
                            }, {type: "LineString", coordinates: r.coordinates[a]}) && (l = !0);
                            for (var h = 0; h < n.coordinates[u].length; h++) if (Br({
                                type: "Point",
                                coordinates: n.coordinates[u][h]
                            }, {type: "LineString", coordinates: r.coordinates[a]}, {ignoreEndVertices: !0})) return !1
                        }
                        return l;
                    case"Polygon":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) for (a = 0; a < n.coordinates.length; a++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[u][a]
                        }, {type: "LineString", coordinates: r.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[u][a]
                        }, r, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiPolygon":
                        for (s = !1, u = 0; u < r.coordinates[0].length; u++) for (a = 0; a < n.coordinates.length; a++) for (h = 0; h < n.coordinates[a].length; h++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[a][h]
                        }, {type: "LineString", coordinates: r.coordinates[0][u]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[a][h]
                        }, {type: "Polygon", coordinates: [r.coordinates[0][u]]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"Polygon":
                switch (o) {
                    case"Point":
                        for (u = 0; u < n.coordinates.length; u++) if (Br(r, {
                            type: "LineString",
                            coordinates: n.coordinates[u]
                        })) return !0;
                        return !1;
                    case"MultiPoint":
                        for (s = !1, u = 0; u < r.coordinates.length; u++) if (s || Br({
                            type: "Point",
                            coordinates: r.coordinates[u]
                        }, {type: "LineString", coordinates: n.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: r.coordinates[u]
                        }, n, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"LineString":
                        for (s = !1, u = 0; u < r.coordinates.length; u++) if (s || Br({
                            type: "Point",
                            coordinates: r.coordinates[u]
                        }, {type: "LineString", coordinates: n.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: r.coordinates[u]
                        }, n, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiLineString":
                        for (s = !1, u = 0; u < r.coordinates.length; u++) for (a = 0; a < r.coordinates[u].length; a++) if (s || Br({
                            type: "Point",
                            coordinates: r.coordinates[u][a]
                        }, {type: "LineString", coordinates: n.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: r.coordinates[u][a]
                        }, n, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"Polygon":
                        for (s = !1, u = 0; u < n.coordinates[0].length; u++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[0][u]
                        }, {type: "LineString", coordinates: r.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[0][u]
                        }, r, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiPolygon":
                        for (s = !1, u = 0; u < r.coordinates[0].length; u++) for (a = 0; a < n.coordinates[0].length; a++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[0][a]
                        }, {type: "LineString", coordinates: r.coordinates[0][u]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[0][a]
                        }, {type: "Polygon", coordinates: r.coordinates[0][u]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            case"MultiPolygon":
                switch (o) {
                    case"Point":
                        for (u = 0; u < n.coordinates[0].length; u++) if (Br(r, {
                            type: "LineString",
                            coordinates: n.coordinates[0][u]
                        })) return !0;
                        return !1;
                    case"MultiPoint":
                        for (s = !1, u = 0; u < n.coordinates[0].length; u++) for (a = 0; a < r.coordinates.length; a++) if (s || Br({
                            type: "Point",
                            coordinates: r.coordinates[a]
                        }, {type: "LineString", coordinates: n.coordinates[0][u]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: r.coordinates[a]
                        }, {type: "Polygon", coordinates: n.coordinates[0][u]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"LineString":
                        for (s = !1, u = 0; u < n.coordinates[0].length; u++) for (a = 0; a < r.coordinates.length; a++) if (s || Br({
                            type: "Point",
                            coordinates: r.coordinates[a]
                        }, {type: "LineString", coordinates: n.coordinates[0][u]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: r.coordinates[a]
                        }, {type: "Polygon", coordinates: n.coordinates[0][u]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiLineString":
                        for (s = !1, u = 0; u < n.coordinates.length; u++) for (a = 0; a < r.coordinates.length; a++) for (h = 0; h < r.coordinates[a].length; h++) if (s || Br({
                            type: "Point",
                            coordinates: r.coordinates[a][h]
                        }, {type: "LineString", coordinates: n.coordinates[u][0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: r.coordinates[a][h]
                        }, {type: "Polygon", coordinates: [n.coordinates[u][0]]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"Polygon":
                        for (s = !1, u = 0; u < n.coordinates[0].length; u++) for (a = 0; a < n.coordinates[0][u].length; a++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[0][u][a]
                        }, {type: "LineString", coordinates: r.coordinates[0]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[0][u][a]
                        }, r, {ignoreBoundary: !0})) return !1;
                        return s;
                    case"MultiPolygon":
                        for (s = !1, u = 0; u < n.coordinates[0].length; u++) for (a = 0; a < r.coordinates[0].length; a++) for (h = 0; h < n.coordinates[0].length; h++) if (s || Br({
                            type: "Point",
                            coordinates: n.coordinates[0][u][h]
                        }, {type: "LineString", coordinates: r.coordinates[0][a]}) && (s = !0), ye({
                            type: "Point",
                            coordinates: n.coordinates[0][u][h]
                        }, {type: "Polygon", coordinates: r.coordinates[0][a]}, {ignoreBoundary: !0})) return !1;
                        return s;
                    default:
                        throw new Error("feature2 " + o + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + i + " geometry not supported")
        }
    }, t.booleanWithin = Xr, t.buffer = function (t, n, r) {
        var i = (r = r || {}).units || "kilometers", o = r.steps || 8;
        if (!t) throw new Error("geojson is required");
        if ("object" !== e(r)) throw new Error("options must be an object");
        if ("number" != typeof o) throw new Error("steps must be an number");
        if (void 0 === n) throw new Error("radius is required");
        if (o <= 0) throw new Error("steps must be greater than 0");
        var s = [];
        switch (t.type) {
            case"GeometryCollection":
                return H(t, (function (t) {
                    var e = nc(t, n, i, o);
                    e && s.push(e)
                })), k(s);
            case"FeatureCollection":
                return U(t, (function (t) {
                    var e = nc(t, n, i, o);
                    e && U(e, (function (t) {
                        t && s.push(t)
                    }))
                })), k(s)
        }
        return nc(t, n, i, o)
    }, t.center = In, t.centerMean = mu, t.centerMedian = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.counter || 10;
        if (!D(n)) throw new Error("counter must be a number");
        var r = e.weight, i = mu(t, {weight: e.weight}), o = k([]);
        U(t, (function (t) {
            var e;
            o.features.push(Sn(t, {properties: {weight: null === (e = t.properties) || void 0 === e ? void 0 : e[r]}}))
        }));
        var s = {tolerance: e.tolerance, medianCandidates: []};
        return _u(i.geometry.coordinates, [0, 0], o, s, n)
    }, t.centerOfMass = function t(e) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        switch (gt(e)) {
            case"Point":
                return d(st(e), n.properties);
            case"Polygon":
                var r = [];
                B(e, (function (t) {
                    r.push(t)
                }));
                var i, o, s, a, u, l, h, c, f = Sn(e, {properties: n.properties}), g = f.geometry.coordinates, p = 0,
                    v = 0, y = 0, m = r.map((function (t) {
                        return [t[0] - g[0], t[1] - g[1]]
                    }));
                for (i = 0; i < r.length - 1; i++) a = (o = m[i])[0], l = o[1], u = (s = m[i + 1])[0], y += c = a * (h = s[1]) - u * l, p += (a + u) * c, v += (l + h) * c;
                if (0 === y) return f;
                var _ = .5 * y, x = 1 / (6 * _);
                return d([g[0] + x * p, g[1] + x * v], n.properties);
            default:
                var E = ve(e);
                return E ? t(E, {properties: n.properties}) : Sn(e, {properties: n.properties})
        }
    }, t.centroid = Sn, t.circle = kn, t.cleanCoords = sn, t.clone = Ie, t.clusterEach = Xu, t.clusterReduce = ju, t.clusters = Wu, t.clustersDbscan = function (t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        !0 !== n.mutate && (t = Ie(t)), n.minPoints = n.minPoints || 3;
        var r = new ga.DBSCAN, i = r.run(Z(t), O(e, n.units), n.minPoints, xe), o = -1;
        return i.forEach((function (e) {
            o++, e.forEach((function (e) {
                var n = t.features[e];
                n.properties || (n.properties = {}), n.properties.cluster = o, n.properties.dbscan = "core"
            }))
        })), r.noise.forEach((function (e) {
            var n = t.features[e];
            n.properties || (n.properties = {}), n.properties.cluster ? n.properties.dbscan = "edge" : n.properties.dbscan = "noise"
        })), t
    }, t.clustersKmeans = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = t.features.length;
        e.numberOfClusters = e.numberOfClusters || Math.round(Math.sqrt(n / 2)), e.numberOfClusters > n && (e.numberOfClusters = n), !0 !== e.mutate && (t = Ie(t));
        var r = Z(t), i = r.slice(0, e.numberOfClusters), o = wa(r, e.numberOfClusters, i), s = {};
        return o.centroids.forEach((function (t, e) {
            s[e] = t
        })), U(t, (function (t, e) {
            var n = o.idxs[e];
            t.properties.cluster = n, t.properties.centroid = s[n]
        })), t
    }, t.collect = function (t, e, n, r) {
        var i = new Nt(6), o = e.features.map((function (t) {
            var e;
            return {
                minX: t.geometry.coordinates[0],
                minY: t.geometry.coordinates[1],
                maxX: t.geometry.coordinates[0],
                maxY: t.geometry.coordinates[1],
                property: null === (e = t.properties) || void 0 === e ? void 0 : e[n]
            }
        }));
        return i.load(o), t.features.forEach((function (t) {
            t.properties || (t.properties = {});
            var e = ot(t), n = i.search({minX: e[0], minY: e[1], maxX: e[2], maxY: e[3]}), o = [];
            n.forEach((function (e) {
                ye([e.minX, e.minY], t) && o.push(e.property)
            })), t.properties[r] = o
        })), t
    }, t.collectionOf = ct, t.combine = function (t) {
        var e = {
            MultiPoint: {coordinates: [], properties: []},
            MultiLineString: {coordinates: [], properties: []},
            MultiPolygon: {coordinates: [], properties: []}
        };
        return U(t, (function (t) {
            var n, r, i, o;
            switch (null === (o = t.geometry) || void 0 === o ? void 0 : o.type) {
                case"Point":
                    e.MultiPoint.coordinates.push(t.geometry.coordinates), e.MultiPoint.properties.push(t.properties);
                    break;
                case"MultiPoint":
                    (n = e.MultiPoint.coordinates).push.apply(n, a(t.geometry.coordinates)), e.MultiPoint.properties.push(t.properties);
                    break;
                case"LineString":
                    e.MultiLineString.coordinates.push(t.geometry.coordinates), e.MultiLineString.properties.push(t.properties);
                    break;
                case"MultiLineString":
                    (r = e.MultiLineString.coordinates).push.apply(r, a(t.geometry.coordinates)), e.MultiLineString.properties.push(t.properties);
                    break;
                case"Polygon":
                    e.MultiPolygon.coordinates.push(t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties);
                    break;
                case"MultiPolygon":
                    (i = e.MultiPolygon.coordinates).push.apply(i, a(t.geometry.coordinates)), e.MultiPolygon.properties.push(t.properties)
            }
        })), k(Object.keys(e).filter((function (t) {
            return e[t].coordinates.length
        })).sort().map((function (t) {
            return p({type: t, coordinates: e[t].coordinates}, {collectedProperties: e[t].properties})
        })))
    }, t.concave = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.maxEdge || 1 / 0, r = on(t),
            i = Ee(r);
        if (i.features = i.features.filter((function (t) {
            var r = t.geometry.coordinates[0][0], i = t.geometry.coordinates[0][1], o = t.geometry.coordinates[0][2],
                s = xe(r, i, e), a = xe(i, o, e), u = xe(r, o, e);
            return s <= n && a <= n && u <= n
        })), i.features.length < 1) return null;
        var o = nn(i);
        return 1 === o.coordinates.length && (o.coordinates = o.coordinates[0], o.type = "Polygon"), p(o)
    }, t.containsNumber = ut, t.convertArea = A, t.convertLength = O, t.convex = ve, t.coordAll = Z, t.coordEach = B, t.coordReduce = z, t.createBins = Uu, t.degreesToRadians = T, t.destination = En, t.difference = function (t) {
        var e = [];
        if (H(t, (function (t) {
            e.push(t.coordinates)
        })), e.length < 2) throw new Error("Must have at least two features");
        var n = t.features[0].properties || {}, r = Fl.difference.apply(Fl, [e[0]].concat(a(e.slice(1))));
        return 0 === r.length ? null : 1 === r.length ? m(r[0], n) : I(r, n)
    }, t.dissolve = function (t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.propertyName;
        ct(t, "Polygon", "dissolve");
        var r = [];
        if (!e.propertyName) return Jr(I(Fl.union.apply(null, t.features.map((function (t) {
            return t.geometry.coordinates
        })))));
        var i = {};
        U(t, (function (t) {
            Object.prototype.hasOwnProperty.call(i, t.properties[n]) || (i[t.properties[n]] = []), i[t.properties[n]].push(t)
        }));
        for (var o = Object.keys(i), s = 0; s < o.length; s++) {
            var a = I(Fl.union.apply(null, i[o[s]].map((function (t) {
                return t.geometry.coordinates
            }))));
            a.properties[n] = o[s], r.push(a)
        }
        return Jr(k(r))
    }, t.distance = xe, t.distanceWeight = bu, t.earthRadius = c, t.ellipse = du, t.envelope = _n, t.explode = Nn, t.factors = f, t.feature = p, t.featureCollection = k, t.featureEach = U, t.featureOf = ht, t.featureReduce = V, t.filterProperties = Hu, t.findPoint = rt, t.findSegment = nt, t.flatten = Jr, t.flattenEach = J, t.flattenReduce = Q, t.flip = function (t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.mutate;
        if (!t) throw new Error("geojson is required");
        return !1 !== n && void 0 !== n || (t = Ie(t)), B(t, (function (t) {
            var e = t[0], n = t[1];
            t[0] = n, t[1] = e
        })), t
    }, t.geojsonType = lt, t.geomEach = H, t.geomReduce = W, t.geometry = v, t.geometryCollection = S, t.getCluster = zu, t.getCoord = st, t.getCoords = at, t.getGeom = ft, t.getType = gt, t.greatCircle = function (t, n, r) {
        if ("object" !== e(r = r || {})) throw new Error("options is invalid");
        var i = r.properties, o = r.npoints, s = r.offset;
        return t = st(t), n = st(n), i = i || {}, o = o || 100, s = s || 10, new ci({x: t[0], y: t[1]}, {
            x: n[0],
            y: n[1]
        }, i).Arc(o, {offset: s}).json()
    }, t.helpers = Y, t.hexGrid = ac, t.interpolate = function (t, n, r) {
        if ("object" !== e(r = r || {})) throw new Error("options is invalid");
        var i = r.gridType, o = r.property, s = r.weight;
        if (!t) throw new Error("points is required");
        if (ct(t, "Point", "input must contain Points"), !n) throw new Error("cellSize is required");
        if (void 0 !== s && "number" != typeof s) throw new Error("weight must be a number");
        o = o || "elevation", i = i || "square", s = s || 1;
        var a, u = ot(t);
        switch (i) {
            case"point":
            case"points":
                a = Zr(u, n, r);
                break;
            case"square":
            case"squares":
                a = gc(u, n, r);
                break;
            case"hex":
            case"hexes":
                a = ac(u, n, r);
                break;
            case"triangle":
            case"triangles":
                a = pc(u, n, r);
                break;
            default:
                throw new Error("invalid gridType")
        }
        var l = [];
        return U(a, (function (e) {
            var n = 0, a = 0;
            U(t, (function (t) {
                var u, l = xe("point" === i ? e : Sn(e), t, r);
                if (void 0 !== o && (u = t.properties[o]), void 0 === u && (u = t.geometry.coordinates[2]), void 0 === u) throw new Error("zValue is missing");
                0 === l && (n = u);
                var h = 1 / Math.pow(l, s);
                a += h, n += h * u
            }));
            var u = Ie(e);
            u.properties[o] = n / a, l.push(u)
        })), k(l)
    }, t.intersect = sc, t.invariant = pt, t.isNumber = D, t.isObject = F, t.isobands = function (t, e, n) {
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r = n.zProperty || "elevation", i = n.commonProperties || {}, s = n.breaksProperties || [];
        if (ct(t, "Point", "Input must contain Points"), !e) throw new Error("breaks is required");
        if (!Array.isArray(e)) throw new Error("breaks is not an Array");
        if (!F(i)) throw new Error("commonProperties is not an Object");
        if (!Array.isArray(s)) throw new Error("breaksProperties is not an Array");
        var a = Mo(t, {zProperty: r, flip: !0}), u = function (t, e, n) {
            for (var r = [], i = 1; i < e.length; i++) {
                var s = +e[i - 1], a = +e[i], u = Ns(Ss(Co(t, s, a - s)));
                r.push(o({groupedRings: u}, n, s + "-" + a))
            }
            return r
        }(a, e, r);
        u = function (t, e, n) {
            var r = ot(n), i = r[2] - r[0], o = r[3] - r[1], s = r[0], a = r[1], u = e[0].length - 1, l = e.length - 1,
                h = i / u, c = o / l, f = function (t) {
                    t[0] = t[0] * h + s, t[1] = t[1] * c + a
                };
            return t.forEach((function (t) {
                t.groupedRings.forEach((function (t) {
                    t.forEach((function (t) {
                        t.forEach(f)
                    }))
                }))
            })), t
        }(u, a, t);
        var l = u.map((function (t, e) {
            if (s[e] && !F(s[e])) throw new Error("Each mappedProperty is required to be an Object");
            var n = Object.assign(Object.assign({}, i), s[e]);
            return n[r] = t[r], I(t.groupedRings, n)
        }));
        return k(l)
    }, t.isolines = function (t, e, n) {
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r = n.zProperty || "elevation", i = n.commonProperties || {}, o = n.breaksProperties || [];
        if (ct(t, "Point", "Input must contain Points"), !e) throw new Error("breaks is required");
        if (!Array.isArray(e)) throw new Error("breaks must be an Array");
        if (!F(i)) throw new Error("commonProperties must be an Object");
        if (!Array.isArray(o)) throw new Error("breaksProperties must be an Array");
        var s = kt(t, {zProperty: r, flip: !0}), a = function (t, e, n, r, i) {
            for (var o = [], s = 1; s < e.length; s++) {
                var a = +e[s], u = Object.assign(Object.assign({}, r), i[s]);
                u[n] = a;
                var l = w(yt(t, a), u);
                o.push(l)
            }
            return o
        }(s, e, r, i, o), u = function (t, e, n) {
            var r = ot(n), i = r[2] - r[0], o = r[3] - r[1], s = r[0], a = r[1], u = e[0].length - 1, l = e.length - 1,
                h = i / u, c = o / l, f = function (t) {
                    t[0] = t[0] * h + s, t[1] = t[1] * c + a
                };
            return t.forEach((function (t) {
                B(t, f)
            })), t
        }(a, s, t);
        return k(u)
    }, t.kinks = function (t) {
        var e = {type: "FeatureCollection", features: []};
        if ("Feature" === t.type && ("Point" === t.geometry.type || "MultiPoint" === t.geometry.type)) throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
        for (var n = Tr(t, !1), r = 0; r < n.length; ++r) {
            var i = n[r];
            e.features.push(d([i[0], i[1]]))
        }
        return e
    }, t.length = Gr, t.lengthToDegrees = L, t.lengthToRadians = P, t.lineArc = Ki, t.lineChunk = function (t, e, n) {
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r = n.units, i = n.reverse;
        if (!t) throw new Error("geojson is required");
        if (e <= 0) throw new Error("segmentLength must be greater than 0");
        var o = [];
        return J(t, (function (t) {
            i && (t.geometry.coordinates = t.geometry.coordinates.reverse()), function (t, e, n, r) {
                var i = Gr(t, {units: n});
                if (i <= e) return r(t);
                var o = i / e;
                Number.isInteger(o) || (o = Math.floor(o) + 1);
                for (var s = 0; s < o; s++) {
                    r(Yr(t, e * s, e * (s + 1), {units: n}), s)
                }
            }(t, e, r, (function (t) {
                o.push(t)
            }))
        })), k(o)
    }, t.lineEach = tt, t.lineIntersect = gr,t.lineOffset = function (t, e, n) {
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r = n.units;
        if (!t) throw new Error("geojson is required");
        if (null == e || isNaN(e)) throw new Error("distance is required");
        var i = gt(t), o = t.properties;
        switch (i) {
            case"LineString":
                return Ds(t, e, r);
            case"MultiLineString":
                var s = [];
                return J(t, (function (t) {
                    s.push(Ds(t, e, r).geometry.coordinates)
                })), w(s, o);
            default:
                throw new Error("geometry " + i + " is not supported")
        }
    },t.lineOverlap = go,t.lineReduce = et,t.lineSegment = fi,t.lineSlice = function (t, e, n) {
        var r = at(n);
        if ("LineString" !== gt(n)) throw new Error("line must be a LineString");
        for (var i, o = pr(n, t), s = pr(n, e), a = [(i = o.properties.index <= s.properties.index ? [o, s] : [s, o])[0].geometry.coordinates], u = i[0].properties.index + 1; u < i[1].properties.index + 1; u++) a.push(r[u]);
        return a.push(i[1].geometry.coordinates), x(a, n.properties)
    },t.lineSliceAlong = Yr,t.lineSplit = function (t, e) {
        if (!t) throw new Error("line is required");
        if (!e) throw new Error("splitter is required");
        var n = gt(t), r = gt(e);
        if ("LineString" !== n) throw new Error("line must be LineString");
        if ("FeatureCollection" === r) throw new Error("splitter cannot be a FeatureCollection");
        if ("GeometryCollection" === r) throw new Error("splitter cannot be a GeometryCollection");
        var i = Hr(e, {precision: 7});
        switch (r) {
            case"Point":
                return Wi(t, i);
            case"MultiPoint":
                return Hi(t, i);
            case"LineString":
            case"MultiLineString":
            case"Polygon":
            case"MultiPolygon":
                return Hi(t, gr(t, i, {ignoreSelfIntersections: !0}))
        }
    },t.lineString = x,t.lineStrings = E,t.lineToPolygon = function (t) {
        var e, n, r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o = i.properties,
            s = null === (e = i.autoComplete) || void 0 === e || e,
            a = null === (n = i.orderCoords) || void 0 === n || n, u = null !== (r = i.mutate) && void 0 !== r && r;
        if (u || (t = Ie(t)), "FeatureCollection" === t.type) {
            var l = [];
            return t.features.forEach((function (t) {
                l.push(at(io(t, {}, s, a)))
            })), I(l, o)
        }
        return io(t, o, s, a)
    },t.mask = function (t, e) {
        var n, r, i = cc(e), o = null;
        return "FeatureCollection" === t.type ? (r = 2 === (n = t).features.length ? Fl.union(n.features[0].geometry.coordinates, n.features[1].geometry.coordinates) : Fl.union.apply(Fl, n.features.map((function (t) {
            return t.geometry.coordinates
        }))), o = hc(r)) : o = hc(Fl.union(t.geometry.coordinates)), o.geometry.coordinates.forEach((function (t) {
            i.geometry.coordinates.push(t[0])
        })), i
    },t.meta = it,t.midpoint = function (t, e) {
        return En(t, xe(t, e) / 2, wn(t, e))
    },t.moranIndex = function (t, e) {
        var n = e.inputField, r = e.threshold || 1e5, i = e.p || 2, o = e.binary || !1,
            s = bu(t, {alpha: e.alpha || -1, binary: o, p: i, standardization: e.standardization || !0, threshold: r}),
            a = [];
        U(t, (function (t) {
            var e = t.properties || {};
            a.push(e[n])
        }));
        for (var u = Iu(a), l = function (t) {
            var e, n = Iu(t), r = 0, i = h(t);
            try {
                for (i.s(); !(e = i.n()).done;) {
                    var o = e.value;
                    r += Math.pow(o - n, 2)
                }
            } catch (t) {
                i.e(t)
            } finally {
                i.f()
            }
            return r / t.length
        }(a), c = 0, f = 0, g = 0, p = 0, v = s.length, d = 0; d < v; d++) {
            for (var y = 0, m = 0; m < v; m++) c += s[d][m] * (a[d] - u) * (a[m] - u), f += s[d][m], g += Math.pow(s[d][m] + s[m][d], 2), y += s[d][m] + s[m][d];
            p += Math.pow(y, 2)
        }
        var _ = c / f / l, x = -1 / (v - 1),
            E = (v * v * (g *= .5) - v * p + f * f * 3) / ((v - 1) * (v + 1) * (f * f)) - x * x, k = Math.sqrt(E);
        return {expectedMoranIndex: x, moranIndex: _, stdNorm: k, zNorm: (_ - x) / k}
    },t.multiLineString = w,t.multiPoint = b,t.multiPolygon = I,t.nearestPoint = tr,t.nearestPointOnLine = pr,t.nearestPointToLine = function (t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.units,
            i = n.properties || {}, o = Er(t);
        if (!o.features.length) throw new Error("points must contain features");
        if (!e) throw new Error("line is required");
        if ("LineString" !== gt(e)) throw new Error("line must be a LineString");
        var s = 1 / 0, a = null;
        return U(o, (function (t) {
            var n = yr(t, e, {units: r});
            n < s && (s = n, a = t)
        })), a && (a.properties = Object.assign(Object.assign({dist: s}, a.properties), i)), a
    },t.planepoint = function (t, e) {
        var n = st(t), r = ft(e).coordinates[0];
        if (r.length < 4) throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
        var i = e.properties || {}, o = i.a, s = i.b, a = i.c, u = n[0], l = n[1], h = r[0][0], c = r[0][1],
            f = void 0 !== o ? o : r[0][2], g = r[1][0], p = r[1][1], v = void 0 !== s ? s : r[1][2], d = r[2][0],
            y = r[2][1], m = void 0 !== a ? a : r[2][2];
        return (m * (u - h) * (l - p) + f * (u - g) * (l - y) + v * (u - d) * (l - c) - v * (u - h) * (l - y) - m * (u - g) * (l - c) - f * (u - d) * (l - p)) / ((u - h) * (l - p) + (u - g) * (l - y) + (u - d) * (l - c) - (u - h) * (l - y) - (u - g) * (l - c) - (u - d) * (l - p))
    },t.point = d,t.pointGrid = Zr,t.pointOnFeature = function (t) {
        for (var e = function (t) {
            if ("FeatureCollection" !== t.type) return "Feature" !== t.type ? k([p(t)]) : k([t]);
            return t
        }(t), n = In(e), r = !1, i = 0; !r && i < e.features.length;) {
            var o, s = e.features[i].geometry, a = !1;
            if ("Point" === s.type) n.geometry.coordinates[0] === s.coordinates[0] && n.geometry.coordinates[1] === s.coordinates[1] && (r = !0); else if ("MultiPoint" === s.type) {
                var u = !1;
                for (o = 0; !u && o < s.coordinates.length;) n.geometry.coordinates[0] === s.coordinates[o][0] && n.geometry.coordinates[1] === s.coordinates[o][1] && (r = !0, u = !0), o++
            } else if ("LineString" === s.type) for (o = 0; !a && o < s.coordinates.length - 1;) Or(n.geometry.coordinates[0], n.geometry.coordinates[1], s.coordinates[o][0], s.coordinates[o][1], s.coordinates[o + 1][0], s.coordinates[o + 1][1]) && (a = !0, r = !0), o++; else if ("MultiLineString" === s.type) for (var l = 0; l < s.coordinates.length;) {
                a = !1, o = 0;
                for (var h = s.coordinates[l]; !a && o < h.length - 1;) Or(n.geometry.coordinates[0], n.geometry.coordinates[1], h[o][0], h[o][1], h[o + 1][0], h[o + 1][1]) && (a = !0, r = !0), o++;
                l++
            } else "Polygon" !== s.type && "MultiPolygon" !== s.type || ye(n, s) && (r = !0);
            i++
        }
        if (r) return n;
        var c = k([]);
        for (i = 0; i < e.features.length; i++) c.features = c.features.concat(Nn(e.features[i]).features);
        return d(tr(n, c).geometry.coordinates)
    },t.pointToLineDistance = yr,t.points = y,t.pointsWithinPolygon = _e,t.polygon = m,t.polygonSmooth = function (t, e) {
        var n = [], r = (e = e || {}).iterations || 1;
        if (!t) throw new Error("inputPolys is required");
        return H(t, (function (t, e, i) {
            var o, s, a;
            switch (t.type) {
                case"Polygon":
                    o = [[]];
                    for (var u = 0; u < r; u++) a = [], s = t, u > 0 && (s = m(o).geometry), Eu(s, a), o = a.slice(0);
                    n.push(m(o, i));
                    break;
                case"MultiPolygon":
                    o = [[[]]];
                    for (var l = 0; l < r; l++) a = [], s = t, l > 0 && (s = I(o).geometry), ku(s, a), o = a.slice(0);
                    n.push(I(o, i));
                    break;
                default:
                    throw new Error("geometry is invalid, must be Polygon or MultiPolygon")
            }
        })), k(n)
    },t.polygonTangents = function (t, e) {
        var n, r, i, o, s = at(t), a = at(e), u = ot(e), l = 0, h = null;
        switch (s[0] > u[0] && s[0] < u[2] && s[1] > u[1] && s[1] < u[3] && (l = (h = tr(t, Nn(e))).properties.featureIndex), gt(e)) {
            case"Polygon":
                n = a[0][l], r = a[0][0], null !== h && h.geometry.coordinates[1] < s[1] && (r = a[0][l]), o = wo(a[0][0], a[0][a[0].length - 1], s);
                var c = Eo(a[0], s, o, i, n, r);
                n = c[0], r = c[1];
                break;
            case"MultiPolygon":
                for (var f = 0, g = 0, p = 0, v = 0; v < a[0].length; v++) {
                    f = v;
                    for (var y = !1, m = 0; m < a[0][v].length; m++) {
                        if (g = m, p === l) {
                            y = !0;
                            break
                        }
                        p++
                    }
                    if (y) break
                }
                n = a[0][f][g], r = a[0][f][g], o = wo(a[0][0][0], a[0][0][a[0][0].length - 1], s), a.forEach((function (t) {
                    var e = Eo(t[0], s, o, i, n, r);
                    n = e[0], r = e[1]
                }))
        }
        return k([d(n), d(r)])
    },t.polygonToLine = to,t.polygonize = function (t) {
        var e = zs.fromGeoJson(t);
        e.deleteDangles(), e.deleteCutEdges();
        var n = [], r = [];
        return e.getEdgeRings().filter((function (t) {
            return t.isValid()
        })).forEach((function (t) {
            t.isHole() ? n.push(t) : r.push(t)
        })), n.forEach((function (t) {
            Bs.findEdgeRingContaining(t, r) && r.push(t)
        })), k(r.map((function (t) {
            return t.toPolygon()
        })))
    },t.polygons = _,t.projection = Cu,t.propEach = X,t.propReduce = j,t.propertiesContainsFilter = Zu,t.radiansToDegrees = R,t.radiansToLength = M,t.random = Bu,t.randomLineString = Fu,t.randomPoint = Au,t.randomPolygon = Du,t.randomPosition = Ru,t.rewind = function (t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.reverse || !1, r = e.mutate || !1;
        if (!t) throw new Error("<geojson> is required");
        if ("boolean" != typeof n) throw new Error("<reverse> must be a boolean");
        if ("boolean" != typeof r) throw new Error("<mutate> must be a boolean");
        !1 === r && (t = Ie(t));
        var i = [];
        switch (t.type) {
            case"GeometryCollection":
                return H(t, (function (t) {
                    Io(t, n)
                })), t;
            case"FeatureCollection":
                return U(t, (function (t) {
                    U(Io(t, n), (function (t) {
                        i.push(t)
                    }))
                })), k(i)
        }
        return Io(t, n)
    },t.rhumbBearing = yo,t.rhumbDestination = _o,t.rhumbDistance = vr,t.round = N,t.sample = function (t, e) {
        if (!t) throw new Error("featurecollection is required");
        if (null == e) throw new Error("num is required");
        if ("number" != typeof e) throw new Error("num must be a number");
        var n = k(function (t, e) {
            var n, r, i = t.slice(0), o = t.length, s = o - e;
            for (; o-- > s;) n = i[r = Math.floor((o + 1) * Math.random())], i[r] = i[o], i[o] = n;
            return i.slice(s)
        }(t.features, e));
        return n
    },t.sector = function (t, n, r, i, o) {
        if (!F(o = o || {})) throw new Error("options is invalid");
        var s = o.properties;
        if (!t) throw new Error("center is required");
        if (null == r) throw new Error("bearing1 is required");
        if (null == i) throw new Error("bearing2 is required");
        if (!n) throw new Error("radius is required");
        if ("object" !== e(o)) throw new Error("options must be an object");
        if (vo(r) === vo(i)) return kn(t, n, o);
        var a = at(t), u = Ki(t, n, r, i, o), l = [[a]];
        return B(u, (function (t) {
            l[0].push(t)
        })), l[0].push(a), m(l, s)
    },t.segmentEach = K,t.segmentReduce = $,t.shortestPath = function (t, e, n) {
        if (!F(n = n || {})) throw new Error("options is invalid");
        var r = n.resolution, i = n.minDistance, o = n.obstacles || k([]);
        if (!t) throw new Error("start is required");
        if (!e) throw new Error("end is required");
        if (r && !D(r) || r <= 0) throw new Error("options.resolution must be a number, greater than 0");
        if (i) throw new Error("options.minDistance is not yet implemented");
        var s = st(t), a = st(e);
        switch (t = d(s), e = d(a), gt(o)) {
            case"FeatureCollection":
                if (0 === o.features.length) return x([s, a]);
                break;
            case"Polygon":
                o = k([p(ft(o))]);
                break;
            default:
                throw new Error("invalid obstacles")
        }
        var u = o;
        u.features.push(t), u.features.push(e);
        var l = ot(Cs(mn(ot(u)), 1.15));
        r || (r = xe([l[0], l[1]], [l[2], l[1]], n) / 100), u.features.pop(), u.features.pop();
        for (var h = l[0], c = l[1], f = l[2], g = l[3], v = r / xe([h, c], [f, c], n) * (f - h), y = r / xe([h, c], [h, g], n) * (g - c), m = f - h, _ = g - c, E = Math.floor(m / v), w = Math.floor(_ / y), b = (m - E * v) / 2, I = [], S = [], N = [], M = [], P = 1 / 0, L = 1 / 0, C = g - (_ - w * y) / 2, R = 0; C >= c;) {
            for (var T = [], O = [], A = h + b, q = 0; A <= f;) {
                var G = d([A, C]), Y = Ca(G, o);
                T.push(Y ? 0 : 1), O.push(A + "|" + C);
                var B = xe(G, t);
                !Y && B < P && (P = B, N = {x: q, y: R});
                var z = xe(G, e);
                !Y && z < L && (L = z, M = {x: q, y: R}), A += v, q++
            }
            S.push(T), I.push(O), C -= y, R++
        }
        var X = new Ma(S, {diagonal: !0}), j = X.grid[N.y][N.x], U = X.grid[M.y][M.x], V = Na.search(X, j, U), Z = [s];
        return V.forEach((function (t) {
            var e = I[t.x][t.y].split("|");
            Z.push([+e[0], +e[1]])
        })), Z.push(a), sn(x(Z))
    },t.simplify = function (t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = void 0 !== e.tolerance ? e.tolerance : 1, r = e.highQuality || !1, i = e.mutate || !1;
        if (!t) throw new Error("geojson is required");
        if (n && n < 0) throw new Error("invalid tolerance");
        return !0 !== i && (t = Ie(t)), H(t, (function (t) {
            !function (t, e, n) {
                var r = t.type;
                if ("Point" === r || "MultiPoint" === r) return t;
                sn(t, !0);
                var i = t.coordinates;
                switch (r) {
                    case"LineString":
                        t.coordinates = pn(i, e, n);
                        break;
                    case"MultiLineString":
                        t.coordinates = i.map((function (t) {
                            return pn(t, e, n)
                        }));
                        break;
                    case"Polygon":
                        t.coordinates = vn(i, e, n);
                        break;
                    case"MultiPolygon":
                        t.coordinates = i.map((function (t) {
                            return vn(t, e, n)
                        }))
                }
            }(t, n, r)
        })), t
    },t.square = xn,t.squareGrid = gc,t.standardDeviationalEllipse = function (t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.steps || 64, r = e.weight, i = e.properties || {};
        if (!D(n)) throw new Error("steps must be a number");
        if (!F(i)) throw new Error("properties must be a number");
        var o = Z(t).length, s = mu(t, {weight: r}), a = 0, u = 0, l = 0;
        U(t, (function (t) {
            var e = t.properties[r] || 1, n = xu(at(t), at(s));
            a += Math.pow(n.x, 2) * e, u += Math.pow(n.y, 2) * e, l += n.x * n.y * e
        }));
        var h = a - u, c = Math.sqrt(Math.pow(h, 2) + 4 * Math.pow(l, 2)), f = 2 * l, g = Math.atan((h + c) / f),
            p = 180 * g / Math.PI, v = 0, d = 0, y = 0;
        U(t, (function (t) {
            var e = t.properties[r] || 1, n = xu(at(t), at(s));
            v += Math.pow(n.x * Math.cos(g) - n.y * Math.sin(g), 2) * e, d += Math.pow(n.x * Math.sin(g) + n.y * Math.cos(g), 2) * e, y += e
        }));
        var m = Math.sqrt(2 * v / y), _ = Math.sqrt(2 * d / y),
            x = du(s, m, _, {units: "degrees", angle: p, steps: n, properties: i}), E = _e(t, k([x])), w = {
                meanCenterCoordinates: at(s),
                semiMajorAxis: m,
                semiMinorAxis: _,
                numberOfFeatures: o,
                angle: p,
                percentageWithinEllipse: 100 * Z(E).length / o
            };
        return x.properties.standardDeviationalEllipse = w, x
    },t.tag = function (t, e, n, r) {
        return t = Ie(t), e = Ie(e), U(t, (function (t) {
            t.properties || (t.properties = {}), U(e, (function (e) {
                void 0 === t.properties[r] && ye(t, e) && (t.properties[r] = e.properties[n])
            }))
        })), t
    },t.tesselate = function (t) {
        if (!t.geometry || "Polygon" !== t.geometry.type && "MultiPolygon" !== t.geometry.type) throw new Error("input must be a Polygon or MultiPolygon");
        var e = {type: "FeatureCollection", features: []};
        return "Polygon" === t.geometry.type ? e.features = $n(t.geometry.coordinates) : t.geometry.coordinates.forEach((function (t) {
            e.features = e.features.concat($n(t))
        })), e
    },t.tin = Ee,t.toMercator = Su,t.toWgs84 = Nu,t.transformRotate = Ls,t.transformScale = Cs,t.transformTranslate = function (t, e, n, r) {
        if (!F(r = r || {})) throw new Error("options is invalid");
        var i = r.units, o = r.zTranslation, s = r.mutate;
        if (!t) throw new Error("geojson is required");
        if (null == e || isNaN(e)) throw new Error("distance is required");
        if (o && "number" != typeof o && isNaN(o)) throw new Error("zTranslation is not a number");
        if (o = void 0 !== o ? o : 0, 0 === e && 0 === o) return t;
        if (null == n || isNaN(n)) throw new Error("direction is required");
        return e < 0 && (e = -e, n += 180), !1 !== s && void 0 !== s || (t = Ie(t)), B(t, (function (t) {
            var r = at(_o(t, e, n, {units: i}));
            t[0] = r[0], t[1] = r[1], o && 3 === t.length && (t[2] += o)
        })), t
    },t.triangleGrid = pc,t.truncate = Hr,t.union = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = [];
        if (H(t, (function (t) {
            n.push(t.coordinates)
        })), n.length < 2) throw new Error("Must have at least 2 geometries");
        var r = Fl.union.apply(Fl, [n[0]].concat(a(n.slice(1))));
        return 0 === r.length ? null : 1 === r.length ? m(r[0], e.properties) : I(r, e.properties)
    },t.unkinkPolygon = function (t) {
        var e = [];
        return J(t, (function (t) {
            "Polygon" === t.geometry.type && U($r(t), (function (n) {
                e.push(m(n.geometry.coordinates, t.properties))
            }))
        })), k(e)
    },t.validateBBox = q,t.validateId = G,t.voronoi = function (t, e) {
        if (!F(e = e || {})) throw new Error("options is invalid");
        var n = e.bbox || [-180, -85, 180, 85];
        if (!t) throw new Error("points is required");
        if (!Array.isArray(n)) throw new Error("bbox is invalid");
        return ct(t, "Point", "points"), k(function () {
            var t = Ta, e = Oa, n = null;

            function r(r) {
                return new pu(r.map((function (n, i) {
                    var o = [Math.round(t(n, i, r) / cu) * cu, Math.round(e(n, i, r) / cu) * cu];
                    return o.index = i, o.data = n, o
                })), n)
            }

            return r.polygons = function (t) {
                return r(t).polygons()
            }, r.links = function (t) {
                return r(t).links()
            }, r.triangles = function (t) {
                return r(t).triangles()
            }, r.x = function (e) {
                return arguments.length ? (t = "function" == typeof e ? e : Ra(+e), r) : t
            }, r.y = function (t) {
                return arguments.length ? (e = "function" == typeof t ? t : Ra(+t), r) : e
            }, r.extent = function (t) {
                return arguments.length ? (n = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], r) : n && [[n[0][0], n[0][1]], [n[1][0], n[1][1]]]
            }, r.size = function (t) {
                return arguments.length ? (n = null == t ? null : [[0, 0], [+t[0], +t[1]]], r) : n && [n[1][0] - n[0][0], n[1][1] - n[0][1]]
            }, r
        }().x((function (t) {
            return t.geometry.coordinates[0]
        })).y((function (t) {
            return t.geometry.coordinates[1]
        })).extent([[n[0], n[1]], [n[2], n[3]]]).polygons(t.features).map(vu))
    },Object.defineProperty(t, "__esModule", {value: !0})
}));